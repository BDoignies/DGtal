/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/
//LICENSE-END
/**
 * @file DistanceTransformation.ih
 * @author David Coeurjolly (\c david.coeurjolly@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Syst√®mes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 *
 * @date 2010/09/30
 *
 * Implementation of inline methods defined in DistanceTransformation.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------

/**
 * Constructor.
 */
template <typename I,typename O,typename SepM>
inline
DGtal::DistanceTransformation<I,O,SepM>::DistanceTransformation()
{
}
/**
 * Destructor.
 */

template <typename I,typename O,typename SepM>
inline
DGtal::DistanceTransformation<I,O,SepM>::~DistanceTransformation()
{
}


template <typename I,typename O, typename SepM>
template <typename Functor>
inline
O 
DGtal::DistanceTransformation<I,O,SepM>::compute(const I & aImage, const Functor & predicate)
{

  //We copy the image extent.
  myLowerBoundCopy = aImage.lowerBound();
  myUpperBoundCopy = aImage.upperBound();

  O output(myLowerBoundCopy,myUpperBoundCopy);
  O swap(myLowerBoundCopy, myUpperBoundCopy);
  bool isSwap =true;

  //First step
  computeFirstStep(aImage, output,predicate);
  
  //We process the dimensions
  for(unsigned int dim = 1; dim < I::staticDimension ; dim++)
    {
      if (isSwap)
	computeOtherSteps( output, swap, dim);
      else
	computeOtherSteps( swap, output, dim);
      
      isSwap = !isSwap;
    }
    
  if (!isSwap)
    return output;
  else
    return swap;
}



template <typename I,typename O,typename SepM>
inline
void
DGtal::DistanceTransformation<I,O,SepM>::checkTypesValidity(const I & aImage)
{
  typename I::Point::UnsignedComponent maxExtent = (aImage.upperBound() - aImage.lowerBound()).normInfinity();

  double bitSize = SeparableMetric::p*log2(I::staticDimension*maxExtent);
  
  if (bitSize > sizeof(typename O::ValueType)*8)
    trace.warning() << "(DistanceTransformation) The output image ValueType range may not be sufficient to store the exact values  according to the input image extent."<<endl;
  
}



template <typename I,typename O,typename SepM>
template <typename Functor>
inline
void
DGtal::DistanceTransformation<I,O,SepM>::computeFirstStep(const I & aImage, O &output, const Functor &predicate) const
{
  trace.beginBlock("DT Step 0");
  Point row = myLowerBoundCopy;
 
  //We process the dimensions to construct a Point
  //@todo use span_iterator
  for(unsigned int dim = 1; dim < I::staticDimension ; dim++)
    {
      trace.info() << "Processing dim="<<dim<<endl;
      
      for(int k = myLowerBoundCopy[dim] ; k <= myUpperBoundCopy[dim]; k++)
	{
	  row[dim] = k;
	  computeFirstStep1D( aImage,output,row, predicate );
	}
      row[dim] = myLowerBoundCopy[dim];
    }
  
  trace.endBlock();
}


template <typename I,typename O,typename SepM>
inline
void
DGtal::DistanceTransformation<I,O,SepM>::computeOtherSteps(const O &input, O &output, const DimensionType dim) const
{
  std::string title = "DT Step ";
  trace.beginBlock(title);
  trace.endBlock();
  
}

////////////////////////// Phase X
template <typename I,typename O,typename SepM>
template <typename ForegroundPredicate>
void 
DGtal::DistanceTransformation<I,O,SepM>::computeFirstStep1D(const I & aImage, 
							    O & output, 
							    const Point &row,
							    const ForegroundPredicate &isForeground) const
{
  Point prec=row;
  Point point=row;
 
  trace.info() << "Propagating from "<<row<<endl;
 
  //PRECOND : output can store 2*(myUpperBoundCopy[0] -  myLowerBoundCopy[0]) in its valuetype
  if( isForeground(aImage,point) )
    output.setValue(point, myUpperBoundCopy[0] -  myLowerBoundCopy[0]);
  else
    output.setValue(point, 0);
  
   
  //Forward scan
  for ( point[0] = myLowerBoundCopy[0] + 1; point[0] < myUpperBoundCopy[0]; point[0]++ )
    {
      if ( isForeground(aImage,point) )
	{
	  trace.info()<< "else: " << 1+output(prec)<<endl;
	  output.setValue(point, 1 + output(prec));      
	}
      else
	output.setValue(point, 0);


      prec[0] = point[0];
    }
  
  
  //prec is the the rightmost point of "point'
  prec[0] =  myUpperBoundCopy[0];
  
  //Backward scan
  for ( point[0] = myUpperBoundCopy[0] - 1; point[0] >=  myLowerBoundCopy[0]; point[0]-- )
    {
      if ( output( prec ) < output ( point ) )
	output.setValue(point, 1 + output( prec ) );
      prec[0] = point[0];
    } 
}

//                                                                           //
///////////////////////////////////////////////////////////////////////////////


