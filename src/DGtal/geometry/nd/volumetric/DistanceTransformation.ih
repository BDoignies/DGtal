/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/
//LICENSE-END
/**
 * @file DistanceTransformation.ih
 * @author David Coeurjolly (\c david.coeurjolly@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Syst√®mes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 *
 * @date 2010/09/30
 *
 * Implementation of inline methods defined in DistanceTransformation.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
#include <boost/lexical_cast.hpp>
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------

/**
 * Constructor.
 */
template <typename I, typename O, typename SepM>
inline
DGtal::DistanceTransformation<I, O, SepM>::DistanceTransformation()
{
}
/**
 * Destructor.
 */

template <typename I, typename O, typename SepM>
inline
DGtal::DistanceTransformation<I, O, SepM>::~DistanceTransformation()
{
}


template <typename I, typename O, typename SepM>
template <typename Functor>
inline
O
DGtal::DistanceTransformation<I, O, SepM>::compute ( const I & aImage, const Functor & predicate )
{

  //We trace type validdity check result;
  checkTypesValidity ( aImage );

  //We copy the image extent.
  myLowerBoundCopy = aImage.lowerBound();
  myUpperBoundCopy = aImage.upperBound();
  myExtent = myUpperBoundCopy - myLowerBoundCopy;

  myInfinity  = myMetric.power(static_cast<typename I::Integer>(I::staticDimension) * myExtent.normInfinity() + 1);

  O output ( myLowerBoundCopy, myUpperBoundCopy );
  O swap ( myLowerBoundCopy, myUpperBoundCopy );
  bool isSwap = true;

  //First step
  computeFirstStep ( aImage, output, predicate );

//return output;

  typename		O::ConstIterator it = output.begin();

  //We process the dimensions
  for ( unsigned int dim = 1; dim < I::staticDimension ; dim++ )
  {
    if ( isSwap )
      computeOtherSteps ( output, swap, dim );
    else
      computeOtherSteps ( swap, output, dim );

    isSwap = !isSwap;
  }

  if ( !isSwap )
    return swap;
  else
    return output;
}



template <typename I, typename O, typename SepM>
inline
void
DGtal::DistanceTransformation<I, O, SepM>::checkTypesValidity ( const I & aImage )
{
  typename I::Point::UnsignedComponent maxExtent = ( aImage.upperBound() - aImage.lowerBound() ).normInfinity();

  //Estimate worst-case bit size (special case for p=0 == Linfinity
  double bitSize;

  if (SeparableMetric::p != 0)
    bitSize = SeparableMetric::p * (log ((double) I::staticDimension * 2 * maxExtent ) / log(2.0));
  else
    bitSize =  sizeof ( typename I::ValueType ) * 8;

  if ( bitSize > sizeof ( typename O::ValueType ) * 8 )
    trace.warning() << "(DistanceTransformation) The output image ValueType range may not be sufficient to store the exact values  according to the input image extent." << endl;

}



template <typename I, typename O, typename SepM>
template <typename Functor>
inline
void
DGtal::DistanceTransformation<I, O, SepM>::computeFirstStep ( const I & aImage, O &output, const Functor &predicate ) const
{
  trace.beginBlock ( "DT dim 0" );
  Point row = myLowerBoundCopy;

  typedef typename Domain::ConstIterator ConstDomIt;
  typedef typename O::Size Size;
  
  //We setup the subdomain iterator
  //the iterator will scan dimension using the order:
  // {n-1, n-2, ... 1} (we skip the '0' dimension.
  std::vector<Size> subdomain;
  subdomain.reserve(I::staticDimension - 1);
  for (unsigned int k = 1; k < I::staticDimension ; k++)
    subdomain.push_back( I::staticDimension - k );

  Domain localDomain(myLowerBoundCopy, myUpperBoundCopy);

  //We process the dimensions to construct a Point
  for (ConstDomIt it = localDomain.subDomainBegin( subdomain ),
      itend = localDomain.subDomainEnd( subdomain ); it != itend; ++it)
  {
    // trace.info()  << "Processing 1D slice starting at =" << (*it) << endl;
    computeFirstStep1D ( aImage, output, (*it), predicate );
  }

  trace.endBlock();
}


template <typename I, typename O, typename SepM>
inline
void
DGtal::DistanceTransformation<I, O, SepM>::computeOtherSteps ( const O &input, O &output, const Dimension dim ) const
{
  std::string title = "DT dim " +  boost::lexical_cast<string>( dim ); ;
  trace.beginBlock ( title );


  typedef typename Domain::ConstIterator ConstDomIt;
  typedef typename O::Size Size;
  
  //We setup the subdomain iterator
  //the iterator will scan dimension using the order:
  // {n-1, n-2, ... 1} (we skip the '0' dimension.
  std::vector<Size> subdomain;
  subdomain.reserve(I::staticDimension - 1);
  for (unsigned int k = 0; k < I::staticDimension ; k++)
    if ( (I::staticDimension - 1 - k) != dim)
      subdomain.push_back( I::staticDimension - 1 - k );

 

  Domain localDomain(myLowerBoundCopy, myUpperBoundCopy);

  Size maxSize = myExtent.normInfinity();

  //Stacks used in the envelope computation
  Integer *s;
  Integer *t;
  s = (Integer*)malloc(sizeof(Integer)*maxSize);
  t = (Integer*)malloc(sizeof(Integer)*maxSize);
  
  ASSERT( s != NULL);
  ASSERT( t != NULL);
  
  //We process the dimensions to construct a Point
  for (ConstDomIt it = localDomain.subDomainBegin( subdomain ),
      itend = localDomain.subDomainEnd( subdomain ); it != itend; ++it)
  {
    //trace.info()  << "Processing 1D slice starting at =" << (*it) << endl;
    computeOtherStep1D ( input, output, (*it), dim, s, t );
  }

  trace.endBlock();

}

//////////////////////////////////////////////////////////////////////:
////////////////////////// Phase X
template <typename I, typename O, typename SepM>
template <typename ForegroundPredicate>
void
DGtal::DistanceTransformation<I, O, SepM>::computeFirstStep1D ( const I & aImage,
    O & output,
    const Point &row,
    const ForegroundPredicate &isForeground ) const
{
  Point prec = row;
  Point point = row;

  //PRECOND : output can store 2*(myUpperBoundCopy[0] -  myLowerBoundCopy[0]) in its valuetype
  //INFTY = something > myUpperBoundCopy[0] -  myLowerBoundCopy[0]
  if ( isForeground ( aImage, point ) )
    output.setValue ( point, myInfinity );
  else
    output.setValue ( point, 0 );

  //Forward scan
  for ( point[0] = myLowerBoundCopy[0] + 1; point[0] <= myUpperBoundCopy[0]; point[0]++ )
  {
    // trace.warning() << point << " ";
    if ( isForeground ( aImage, point ) )
      output.setValue ( point, 1 + output ( prec ) );
    else
      output.setValue ( point, 0 );

    prec[0] = point[0];
  }


  //prec is the the rightmost point of "point'
  prec[0] =  myUpperBoundCopy[0];

  //Backward scan
  for ( point[0] = myUpperBoundCopy[0] - 1; point[0] >=  myLowerBoundCopy[0]; point[0]-- )
  {
    if ( output ( prec ) < output ( point ) )
      output.setValue ( point, 1 + output ( prec ) );
    prec[0] = point[0];
  }

  //final computation
  for ( point[0] = myLowerBoundCopy[0]; point[0] <= myUpperBoundCopy[0]; point[0]++ )
    if (output( point) < myInfinity)
      output.setValue ( point, myMetric.power( output ( point ) ));
    else
      output.setValue ( point, myInfinity);
}


//////////////////////////////////////////////////////////////////////:
////////////////////////// Other Phases
template <typename I, typename O, typename SepM>
void
DGtal::DistanceTransformation<I, O, SepM>::computeOtherStep1D ( const O & input,
    O & output,
    const Point &row,
    const Size dim,
    Integer s[],
    Integer t[] ) const
{
  typedef typename IntegerTraits<Integer>::SignedVersion SI;
  SI w;
  SI q = 0;

  Point sQ = row;
  Point pU = row;

  //init of the stack structure
  pU[dim] = myLowerBoundCopy[dim];
  while ((( input ( pU) == myInfinity))
      && (pU[dim] <= myUpperBoundCopy[dim]))
    pU[dim] ++;


  ASSERT( pU[dim] <= myUpperBoundCopy[dim]);///@todo otherwise, the image has no object (fixme)

  q = 0;
  s[q] = pU[dim]; //myLowerBoundCopy[dim];
  sQ[dim] = s[q];
  t[q] = myLowerBoundCopy[dim];

  //Forward Scan
 // trace.warning() << "start pU= " << pU << " input(pU)=" << input(pU) << endl;

  for ( int u = pU[dim] + 1; u <= myUpperBoundCopy[dim] ; u++ )
  {
    pU[ dim ] = u;
    if ( input( pU ) == myInfinity )
    {
      //    trace.info() << "Ctd " << pU << endl;
      continue;
    }

   //  trace.warning() << "pU= " << pU << " input(pU)=" << input(pU) << endl;
   //  trace.warning() << "sQ= " << sQ << " input(sQ)=" << input(sQ) << " t[q] = " << t[q] << "q="<<q<< endl;

    while ( ( q >= 0 ) &&
        ( myMetric.F ( t[q], s[q], input ( sQ ) ) >
            myMetric.F ( t[q], u, input ( pU ) ) ) )
    {
      //trace.info() << "Pop q=" << q << endl;
      q--;
      sQ[dim] = s[q];
    }

    if ( q < 0 )
    {
      q = 0;
      s[0] = u;
      sQ[dim] = u;
    }
    else
    {
      sQ[dim] = s[q];
      w = 1 + myMetric.Sep ( s[q],
          input ( sQ ),
          u,
          input ( pU ) );

      if (( w <= myUpperBoundCopy[dim] ) && (w>= myLowerBoundCopy[dim]))
      {
        q++;
        s[q] = u;
        sQ[dim] = u;
     //  			trace.info() << "Push sq=" << sQ << endl;
        t[q] = w;
      }
    }
  }

  Point last = row;

 //trace.error() << "q=" << q << endl;
  sQ[dim] = s[q];
  //trace.error() << "sQ= " << sQ << " input(sQ)=" << input(sQ) << " t[q] = " << t[q] << endl;
  //Backward Scan
  for (last[dim] = myUpperBoundCopy[dim];
      last[dim] >= myLowerBoundCopy[dim] ;
      last[dim]-- )
  {
    //trace.info() << "dt="<<myMetric.F ( last[dim] , s[q], input ( sQ ) )<<endl;
    output.setValue ( last, myMetric.F ( last[dim] , s[q], input ( sQ ) ) );
    if (( last[dim] == t[q] ) && (q > 0))
    {
      q--;
      sQ[dim] = s[q];
    }
  }
}


//                                                                           //
///////////////////////////////////////////////////////////////////////////////


