/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file DistanceTransformation.ih
 * @author David Coeurjolly (\c david.coeurjolly@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Syst√®mes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 *
 * @date 2010/09/30
 *
 * Implementation of inline methods defined in DistanceTransformation.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
#include <boost/lexical_cast.hpp>
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------

/**
 * Constructor.
 */
template <typename I, typename O, typename SepM>
inline
DGtal::DistanceTransformation<I, O, SepM>::DistanceTransformation()
{
}
/**
 * Destructor.
 */

template <typename I, typename O, typename SepM>
inline
DGtal::DistanceTransformation<I, O, SepM>::~DistanceTransformation()
{
}




template <typename I, typename O, typename SepM>
inline
void
DGtal::DistanceTransformation<I, O, SepM>::checkTypesValidity ( const I & aImage )
{
  typename I::Point::UnsignedComponent maxExtent = ( aImage.upperBound() - aImage.lowerBound() ).normInfinity();

  //Estimate worst-case bit size (special case for p=0 == Linfinity
  double bitSize;

  if (SeparableMetric::p != 0)
    bitSize = SeparableMetric::p * (log ((double) I::dimension * 2 * maxExtent ) / log(2.0));
  else
    bitSize =  sizeof ( typename I::Value ) * 8;

  if ( bitSize > sizeof ( typename O::Value ) * 8 )
    trace.warning() << "(DistanceTransformation) The output image Value range may not be sufficient to store the exact values  according to the input image extent." << endl;

}

template <typename I, typename O, typename SepM>
template <typename Functor>
inline
O
DGtal::DistanceTransformation<I, O, SepM>::compute ( const I & aImage, const Functor & predicate )
{

  //We trace type validdity check result;
  checkTypesValidity ( aImage );

  //We copy the image extent.
  myLowerBoundCopy = aImage.lowerBound();
  myUpperBoundCopy = aImage.upperBound();
  myExtent = myUpperBoundCopy - myLowerBoundCopy;

  myInfinity  = myMetric.power(static_cast<typename I::Integer>(I::dimension) * 
			       myExtent.normInfinity() + 1);
  myDomain = Domain(myLowerBoundCopy,myUpperBoundCopy);
 
  
  O output ( myLowerBoundCopy, myUpperBoundCopy );
  O swap ( myLowerBoundCopy, myUpperBoundCopy );
  bool isSwap = true;

  //First step
  computeFirstStep ( aImage, output, predicate );
  
  //We process the dimensions swaping the temporary buffers
  for ( Dimension dim = 1; dim < I::dimension ; dim++ )
  {
    if ( isSwap )
      computeOtherSteps ( output, swap, dim );
    else
      computeOtherSteps ( swap, output, dim );

    isSwap = !isSwap;
  }

  if ( !isSwap )
    return swap;
  else
    return output;
}



template <typename I, typename O, typename SepM>
template <typename Functor>
inline
void
DGtal::DistanceTransformation<I, O, SepM>::computeFirstStep ( const I & aImage, O &output, const Functor &predicate ) const
{
  trace.beginBlock ( "DT dimension 0" );
  Point row = myLowerBoundCopy;

  typedef typename Domain::ConstSubRange::const_iterator ConstDomIt;
  
  //We setup the subdomain iterator
  //the iterator will scan dimension using the order:
  // {n-1, n-2, ... 1} (we skip the '0' dimension.
  std::vector<Dimension> subdomain;
  subdomain.reserve(I::dimension - 1);
  for (Dimension k = 1; k < I::dimension ; k++)
    subdomain.push_back( I::dimension - k );

  //We process the dimensions to construct a Point
  for (ConstDomIt it = myDomain.subRange( subdomain ).begin(),
	 itend = myDomain.subRange( subdomain ).end(); it != itend; ++it)
  {
    // trace.info()  << "Processing 1D slice starting at =" << (*it) << endl;
    computeFirstStep1D ( aImage, output, (*it), predicate );
  }

  trace.endBlock();
}


template <typename I, typename O, typename SepM>
inline
void
DGtal::DistanceTransformation<I, O, SepM>::computeOtherSteps ( const O &input, O &output, const Dimension dim ) const
{
  std::string title = "DT dimension " +  boost::lexical_cast<string>( dim ); ;
  trace.beginBlock ( title );

  typedef typename Domain::ConstSubRange::const_iterator ConstDomIt;
  
  //We setup the subdomain iterator
  //the iterator will scan dimension using the order:
  // {n-1, n-2, ... 1} (we skip the '0' dimension.
  std::vector<Size> subdomain;
  subdomain.reserve(I::dimension - 1);
  for (unsigned int k = 0; k < I::dimension ; k++)
    if ( (I::dimension - 1 - k) != dim)
      subdomain.push_back( I::dimension - 1 - k );

  Dimension maxSize = myExtent.normInfinity();

  //Stacks used in the envelope computation
  Integer *s = new Integer[maxSize+1];
  Integer *t = new Integer[maxSize+1];
  
  ASSERT( s != NULL);
  ASSERT( t != NULL);
  
  //We process the dimensions to construct a Point
  for (ConstDomIt it = myDomain.subRange( subdomain ).begin(),
	 itend = myDomain.subRange( subdomain ).end(); it != itend; ++it)
    computeOtherStep1D ( input, output, (*it), dim, s, t );

  free(s);
  free(t);
  trace.endBlock();

}

//////////////////////////////////////////////////////////////////////:
////////////////////////// Phase X
template <typename I, typename O, typename SepM>
template <typename ForegroundPredicate>
void
DGtal::DistanceTransformation<I, O, SepM>::computeFirstStep1D ( const I & aImage,
    O & output,
    const Point &starting,
    const ForegroundPredicate &isForeground ) const
{
  //PRECOND : output can store 2*(myUpperBoundCopy[0] -  myLowerBoundCopy[0]) in its valuetype
  //INFTY = something > myUpperBoundCopy[0] -  myLowerBoundCopy[0]
  
  typename Domain::ConstSubRange scanline = myDomain.subRange(0,starting);
  typename Domain::ConstIterator it = scanline.begin();
  typename Domain::ConstIterator itend = scanline.end();
  typename Domain::ConstIterator prevIt = scanline.begin();
 
  //First cell
  if ( isForeground ( aImage, (*it) ) )
    output.setValue ( (*it), myInfinity );
  else
    output.setValue ( (*it), 0 );
  ++it;

  //Forward scan (starting at the second cell)
  for( ;
       it != itend;
       ++it,++prevIt)
    {
      if ( isForeground ( aImage, (*it) ) )
	output.setValue ( (*it), 1 + output ( *prevIt ) );
      else
	output.setValue ( (*it), 0 );
    }
  
  typename Domain::ReverseConstIterator rit = scanline.rbegin();
  typename Domain::ReverseConstIterator rPrevIt = scanline.rbegin();
  typename Domain::ReverseConstIterator ritend = scanline.rend();
  //rPrevIt is the rightmost point of "rit"
  ++rit;
  
  //Backward scan
  for( ; 
      rit != ritend;
      ++rit,++rPrevIt )
    {
      if ( output ( *rPrevIt ) < output ( *rit ) )
	output.setValue ( (*rit) , 1 + output ( *rPrevIt ) );
    }
  
  //final computation
  for ( it = scanline.begin(),itend = scanline.end();
	it != itend;
	++it )
    if (output( *it ) < myInfinity)
      output.setValue ( (*it), myMetric.power( output ( *it ) ));
    else
      output.setValue ( (*it), myInfinity);
}

//////////////////////////////////////////////////////////////////////:
////////////////////////// Other Phases
template <typename I, typename O, typename SepM>
void
DGtal::DistanceTransformation<I, O, SepM>::computeOtherStep1D ( const O & input,
								O & output,
								const Point &startingPoint,
								const Dimension dim,
								Integer s[],
								Integer t[] ) const
{
  Integer w;
  Integer q = 0;

  Point sQ = startingPoint;
  Point pU = startingPoint;

  //trace.info()<<"Enter startingPoint="<<startingPoint<<endl;

  //init of the stack structure
  pU[dim] = myLowerBoundCopy[dim];
  while ((pU[dim] <= myUpperBoundCopy[dim]) 
	 && (input ( pU ) == myInfinity))
    pU[dim] ++;

  // trace.info()<<"Shift"<<endl;

  //the 1D slice  has no object point
  //ASSERT( pU[dim] <= myUpperBoundCopy[dim] );
  if ( pU[dim] > myUpperBoundCopy[dim] )
    {
      for(typename O::SpanIterator it= output.spanBegin(startingPoint,dim),
	    itend=output.spanEnd(startingPoint,dim); 
	  it != itend; ++it)
	output.setValue(it, myInfinity);
      return;
    }
  
  q = 0;
  s[q] = pU[dim]; //myLowerBoundCopy[dim];
  sQ[dim] = s[q];
  t[q] = myLowerBoundCopy[dim];

  //Forward Scan
 // trace.warning() << "start pU= " << pU << " input(pU)=" << input(pU) << endl;

  for ( int u = pU[dim] + 1; u <= myUpperBoundCopy[dim] ; u++ )
  {
    pU[ dim ] = u;
    if ( input( pU ) == myInfinity )
    {
      //    trace.info() << "Ctd " << pU << endl;
      continue;
    }

   //  trace.warning() << "pU= " << pU << " input(pU)=" << input(pU) << endl;
   //  trace.warning() << "sQ= " << sQ << " input(sQ)=" << input(sQ) << " t[q] = " << t[q] << "q="<<q<< endl;

    while ( ( q >= 0 ) &&
        ( myMetric.F ( t[q], s[q], input ( sQ ) ) >
	  myMetric.F ( t[q], u, input ( pU ) ) ) )
    {
      //trace.info() << "Pop q=" << q << endl;
      q--;
      ///@todo optimize the test here
      if (q>=0)
	sQ[dim] = s[q];
    }

    if ( q < 0 )
    {
      q = 0;
      s[0] = u;
      sQ[dim] = u;
    }
    else
    {
      sQ[dim] = s[q];
      w = 1 + myMetric.Sep ( s[q],
          input ( sQ ),
          u,
          input ( pU ) );

      if (( w <= myUpperBoundCopy[dim] ) && (w>= myLowerBoundCopy[dim]))
      {
        q++;
        s[q] = u;
        sQ[dim] = u;
     //  			trace.info() << "Push sq=" << sQ << endl;
        t[q] = w;
      }
    }
  }

  Point last = startingPoint;

  ASSERT(q>=0);

 //trace.error() << "q=" << q << endl;
  sQ[dim] = s[q];
  //trace.error() << "sQ= " << sQ << " input(sQ)=" << input(sQ) << " t[q] = " << t[q] << endl;
 
  //Backward Scan
  for (last[dim] = myUpperBoundCopy[dim];
      last[dim] >= myLowerBoundCopy[dim] ;
      last[dim]-- )
  {
    //trace.info() << "dt="<<myMetric.F ( last[dim] , s[q], input ( sQ ) )<<endl;
    ASSERT(myMetric.F ( last[dim] , s[q], input ( sQ ) ) >=0);
    output.setValue ( last, myMetric.F ( last[dim] , s[q], input ( sQ ) ) );
    if (( last[dim] == t[q] ) && (q > 0))
    {
      q--;
      sQ[dim] = s[q];
    }
  }
}


//                                                                           //
///////////////////////////////////////////////////////////////////////////////


