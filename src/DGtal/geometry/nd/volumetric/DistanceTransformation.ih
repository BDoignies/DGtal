/**
 * @file DistanceTransformation.ih
 * @author David Coeurjolly (\c david.coeurjolly@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Syst√®mes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 *
 * @date 2010/09/30
 *
 * Implementation of inline methods defined in DistanceTransformation.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------

/**
 * Constructor.
 */
template <typename I,typename O,typename SepM>
inline
DGtal::DistanceTransformation<I,O,SepM>::DistanceTransformation()
{
}
/**
 * Destructor.
 */

template <typename I,typename O,typename SepM>
inline
DGtal::DistanceTransformation<I,O,SepM>::~DistanceTransformation()
{
}


template <typename I,typename O, typename SepM>
template <typename Functor>
inline
O 
DGtal::DistanceTransformation<I,O,SepM>::compute(const I & aImage)
{
  O output(aImage.lowerBound(), aImage.upperBound());
  O swap(aImage.lowerBound(), aImage.upperBound());
  bool isSwap =true;

  //First step
  computeFirstStep<Functor>(aImage, output);
  
  //We process the dimensions
  for(unsigned int dim = 1; dim < I::staticDimension ; dim++)
    {
      if (isSwap)
	computeOtherSteps( output, swap, dim);
      else
	computeOtherSteps( swap, output, dim);
      
      isSwap = !isSwap;
    }
    
  if (!isSwap)
    return output;
  else
    return swap;
}



template <typename I,typename O,typename SepM>
inline
void
DGtal::DistanceTransformation<I,O,SepM>::checkTypesValidity(const I & aImage)
{
  typename I::Point::UnsignedComponent maxExtent = (aImage.upperBound() - aImage.lowerBound()).normInfinity();

  double bitSize = SeparableMetric::p*log2(I::staticDimension*maxExtent);
  
  if (bitSize > sizeof(typename O::ValueType)*8)
    trace.warning() << "(DistanceTransformation) The output image ValueType range may not be sufficient to store the exact values  according to the input image extent."<<endl;
  
}



template <typename I,typename O,typename SepM>
template <typename Functor>
inline
void
DGtal::DistanceTransformation<I,O,SepM>::computeFirstStep(const I & aImage, O &output)
{
  Functor isForeground;
  
  trace.beginBlock("DT Step 0");
  trace.endBlock();
}


template <typename I,typename O,typename SepM>
inline
void
DGtal::DistanceTransformation<I,O,SepM>::computeOtherSteps(const O &input, O &output, const DimensionType dim)
{
  std::string title = "DT Step ";
  trace.beginBlock(title);
  trace.endBlock();
  
}



//                                                                           //
///////////////////////////////////////////////////////////////////////////////


