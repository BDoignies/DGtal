/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file ReverseDistanceTransformation.ih
 * @author David Coeurjolly (\c david.coeurjolly@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Syst√®mes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 *
 * @date 2010/09/30
 *
 * Implementation of inline methods defined in ReverseDistanceTransformation.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
#include <boost/lexical_cast.hpp>
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------

/**
 * Constructor.
 */
template <typename I, typename O, typename SepM>
inline
DGtal::ReverseDistanceTransformation<I, O, SepM>::ReverseDistanceTransformation(typename O::Value aObjectValue, 
										typename O::Value aBackgroundValue): 
  myObjectValue(aObjectValue), myBackgroundValue(aBackgroundValue)
{
}

/**
 * Destructor.
 */

template <typename I, typename O, typename SepM>
inline
DGtal::ReverseDistanceTransformation<I, O, SepM>::~ReverseDistanceTransformation()
{
}



template <typename I, typename O, typename SepM>
inline
O
DGtal::ReverseDistanceTransformation<I, O, SepM>::compute ( const I & aImage )
{

  //We copy the image extent.
  myLowerBoundCopy = aImage.lowerBound();
  myUpperBoundCopy = aImage.upperBound();
  myExtent = myUpperBoundCopy - myLowerBoundCopy;
  myDomain = Domain(myLowerBoundCopy,myUpperBoundCopy);
  
  I output ( myLowerBoundCopy, myUpperBoundCopy );
  I swap ( myLowerBoundCopy, myUpperBoundCopy );
  bool isSwap = true;
 
  //We copy inpu image
  typename I::Iterator ito=output.begin();
  for(typename I::ConstIterator it=aImage.begin(), itend = aImage.end();
      it != itend;
      ++it,++ito)
    output.setValue(ito, (*it) );
  
  trace.info()<<"Output"<<endl;
  
  typename I::ConstIterator it2 = output.begin();
  for (unsigned int y = 2; y < 16; y++)
    {
    for (unsigned int x = 2; x < 16; x++)
    {
      std::cerr << (*it2) << " ";
      ++it2;
    }
    std::cerr << std::endl;
  }


  //We process the dimensions swaping the temporary buffers
  for ( Dimension dim = 0; dim < I::dimension ; dim++ )
  {
    if ( isSwap )
      computeSteps ( output, swap, dim );
    else
      computeSteps ( swap, output, dim );
    
    isSwap = !isSwap;
  }
  
  if ( !isSwap )
    return castValues(swap);
  else
    return castValues(output);
}

template <typename I, typename O, typename SepM>
inline
O
DGtal::ReverseDistanceTransformation<I, O, SepM>::castValues ( const I &input ) const
{
  //We threshold input values
  O output(myLowerBoundCopy, myUpperBoundCopy);
  typename O::Iterator ito = output.begin();
  for(typename I::ConstIterator it=input.begin(),
	itend = input.end();
      it != itend;
      ++it,++ito)
    if ( (*it)  > 0)
      output.setValue(ito, myObjectValue);
    else
      output.setValue(ito, myBackgroundValue);
  return output;
}



template <typename I, typename O, typename SepM>
inline
void
DGtal::ReverseDistanceTransformation<I, O, SepM>::computeSteps ( const I &input, 
								 I &output, 
								 const Dimension dim ) const
{
  std::string title = "RDT dimension " +  boost::lexical_cast<string>( dim ); ;
  trace.beginBlock ( title );
  
  trace.error()<<"In"<<endl;

 typename I::ConstIterator it2 = input.begin();
  for (unsigned int y = 2; y < 16; y++)
    {
    for (unsigned int x = 2; x < 16; x++)
    {
      std::cerr << (*it2) << " ";
      ++it2;
    }
    std::cerr << std::endl;
  }

  typedef typename Domain::ConstSubRange::const_iterator ConstDomIt;
  
  //We setup the subdomain iterator
  //the iterator will scan dimension using the order:
  // {n-1, n-2, ... 1} (we skip the '0' dimension.
  std::vector<Dimension> subdomain;
  subdomain.reserve(I::dimension - 1);
  for(Dimension k = 0; k < I::dimension ; k++)
    if ( (I::dimension - 1 - k) != dim)
      subdomain.push_back( I::dimension - 1 - k );

  Dimension maxSize = myExtent.normInfinity();

  //Stacks used in the envelope computation
  Coordinate *s = new Coordinate[maxSize+1];
  Coordinate *t = new Coordinate[maxSize+1];
  
  ASSERT( s != NULL);
  ASSERT( t != NULL);
  
  //We process the dimensions to construct a Point
  for (ConstDomIt it = myDomain.subRange( subdomain ).begin(),
	 itend = myDomain.subRange( subdomain ).end(); it != itend; ++it)
    computeStep1D ( input, output, (*it), dim, s, t );
  
  free(s);
  free(t);
  
  trace.info()<<"out"<<endl;
  
  typename I::ConstIterator it = output.begin();
  for (unsigned int y = 2; y < 16; y++)
    {
      for (unsigned int x = 2; x < 16; x++)
	{
	  std::cerr << (*it) << " ";
	  ++it;
	}
      std::cerr << std::endl;
    }
  
  
  
  trace.endBlock();

}

//////////////////////////////////////////////////////////////////////:

//////////////////////////////////////////////////////////////////////:
template <typename I, typename O, typename SepM>
void
DGtal::ReverseDistanceTransformation<I, O, SepM>::computeStep1D ( const I & input,
								  I & output,
								  const Point &startingPoint,
								  const Dimension dim,
								  Coordinate s[],
								  Coordinate t[] ) const
{
  Coordinate w;
  Coordinate q = 0;

  Point sQ = startingPoint;
  Point pU = startingPoint;

  //trace.info()<<"Enter startingPoint="<<startingPoint<<endl;

  //init of the stack structure
  pU[dim] = myLowerBoundCopy[dim];
  while ((pU[dim] <= myUpperBoundCopy[dim]) 
	 && (input ( pU ) == 0))
    pU[dim] ++;

  // trace.info()<<"Shift"<<endl;

  //the 1D slice  has no object point
  //ASSERT( pU[dim] <= myUpperBoundCopy[dim] );
  if ( pU[dim] > myUpperBoundCopy[dim] )
    {
      for(typename I::SpanIterator it= output.spanBegin(startingPoint,dim),
	    itend=output.spanEnd(startingPoint,dim); 
	  it != itend; ++it)
	output.setValue(it, 0);
      return;
    }
  
  q = 0;
  s[q] = pU[dim]; //myLowerBoundCopy[dim];
  sQ[dim] = s[q];
  t[q] = myLowerBoundCopy[dim];

  //Forward Scan
 // trace.warning() << "start pU= " << pU << " input(pU)=" << input(pU) << endl;

  for ( int u = pU[dim] + 1; u <= myUpperBoundCopy[dim] ; u++ )
  {
    pU[ dim ] = u;
    if ( input( pU ) == 0 )
    {
      //    trace.info() << "Ctd " << pU << endl;
      continue;
    }

   //  trace.warning() << "pU= " << pU << " input(pU)=" << input(pU) << endl;
   //  trace.warning() << "sQ= " << sQ << " input(sQ)=" << input(sQ) << " t[q] = " << t[q] << "q="<<q<< endl;

    while ( ( q >= 0 ) &&
        ( myMetric.reversedF ( t[q], s[q], input ( sQ ) ) >
	  myMetric.reversedF ( t[q], u, input ( pU ) ) ) )
    {
      //trace.info() << "Pop q=" << q << endl;
      q--;
      ///@todo optimize the test here
      if (q>=0)
	sQ[dim] = s[q];
    }

    if ( q < 0 )
    {
      q = 0;
      s[0] = u;
      sQ[dim] = u;
    }
    else
    {
      sQ[dim] = s[q];
      w = 1 + myMetric.Sep ( s[q],
          input ( sQ ),
          u,
          input ( pU ) );

      if (( w <= myUpperBoundCopy[dim] ) && (w>= myLowerBoundCopy[dim]))
      {
        q++;
        s[q] = u;
        sQ[dim] = u;
     //  			trace.info() << "Push sq=" << sQ << endl;
        t[q] = w;
      }
    }
  }

  Point last = startingPoint;

  ASSERT(q>=0);

 //trace.error() << "q=" << q << endl;
  sQ[dim] = s[q];
  //trace.error() << "sQ= " << sQ << " input(sQ)=" << input(sQ) << " t[q] = " << t[q] << endl;
 
  //Backward Scan
  for (last[dim] = myUpperBoundCopy[dim];
      last[dim] >= myLowerBoundCopy[dim] ;
      last[dim]-- )
  {
    if (myMetric.reversedF ( last[dim] , s[q], input ( sQ )) > 0 )
      output.setValue ( last, myMetric.reversedF ( last[dim] , s[q], input ( sQ ) ) );
    else
      output.setValue ( last, 0 );
      
    if (( last[dim] == t[q] ) && (q > 0))
    {
      q--;
      sQ[dim] = s[q];
    }
  }
}


//                                                                           //
///////////////////////////////////////////////////////////////////////////////


