/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file FirstOrderIncrementalMetricHelpers.ih
 * @author Tristan Roussillon (\c tristan.roussillon@liris.cnrs.fr ) Laboratoire d'InfoRmatique en
 * Image et Syst√®mes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 * @date 2012/01/16
 *
 * Header file for module FirstOrderIncrementalMetricHelpers.cpp
 * Implementation of inline methods defined in FirstOrderIncrementalMetricHelpers.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////


template <DGtal::Dimension dim>
inline
DGtal::L2FirstOrderIncrementalMetricHelper<dim>
::L2FirstOrderIncrementalMetricHelper(const double& aGridStep)
  : myUnknownValue( numeric_limits<Value>::max() )
{
  for (Dimension k = 0; k < dimension; ++k)
    myGridStepsVector[k] = aGridStep; 
}

template <DGtal::Dimension dim>
inline
DGtal::L2FirstOrderIncrementalMetricHelper<dim>
::L2FirstOrderIncrementalMetricHelper(const boost::array<double, dimension>& aGridStepsVector)
  : myGridStepsVector(aGridStepsVector), 
    myUnknownValue( numeric_limits<Value>::max() )
{
}

template <DGtal::Dimension dim>
inline
DGtal::L2FirstOrderIncrementalMetricHelper<dim>
::L2FirstOrderIncrementalMetricHelper(const L2FirstOrderIncrementalMetricHelper& other)
  : myGridStepsVector(other.myGridStepsVector), 
    myUnknownValue(other.myUnknownValue)
{
}

    

template <DGtal::Dimension dim>
inline
DGtal::L2FirstOrderIncrementalMetricHelper<dim>
::~L2FirstOrderIncrementalMetricHelper()
{
}

template <DGtal::Dimension dim>
inline
typename DGtal::L2FirstOrderIncrementalMetricHelper<dim>::Value
DGtal::L2FirstOrderIncrementalMetricHelper<dim>::compute(const Values& aValueList) const
{
  //extract the dimensions where the value is initialized
  Dimensions relevantDimensions;

  for(Dimension k = 0; k < dimension; ++k)
    {
      if ( aValueList[k] != unknownValue() )
	{
	  relevantDimensions.insert(k); 
	}
    }
  return compute(aValueList, relevantDimensions); 
}

template <DGtal::Dimension dim>
inline
typename DGtal::L2FirstOrderIncrementalMetricHelper<dim>::Value
DGtal::L2FirstOrderIncrementalMetricHelper<dim>::compute(const Values& aValueList, Dimensions& aDimensionList) const
{

  unsigned int c = aDimensionList.size();
  ASSERT( c > 0 ); 
  if ( c == 1 )
    {
      Dimension k = *aDimensionList.begin(); 
      Value d = aValueList.at(k); 
      Value dres = d + myGridStepsVector.at(k);
      ASSERT(dres > 0); 
      return dres; 
    } 
  else 
    {
      //max computation
      typename Dimensions::const_iterator it = aDimensionList.begin();  
      typename Dimensions::const_iterator itEnd = aDimensionList.end();  
      typename Dimensions::const_iterator itMax = it;  
      double max = 0;
      for ( ; it != itEnd; ++it)
	{
	  Value d = aValueList.at(*it); 
	  if (d > max) 
	    {
	      max = d;
	      itMax = it; 
	    }
	}
      //function computation
      if ( gradientNorm( max, aValueList ) > 1 )
	{
	  aDimensionList.erase(itMax); 
	  return compute(aValueList, aDimensionList); 
	}
      else 
	{ //resolution
	  double a = 0; 
	  double b = 0; 
	  double c = -1; 
	  it = aDimensionList.begin();  
	  for ( ; it != itEnd; ++it)
	    {
	      double step = myGridStepsVector.at(*it);
	      Value d = aValueList.at(*it);
	      a += ( 1 / (step*step) ); 
	      b -= ( (2*d) / (step*step) );
	      c += ( (d*d) / (step*step) ); 
	    }
	  //std::cerr << a << " " << b << " " << c  << std::endl; 
	  double disc = b*b - 4*a*c;
	  ASSERT(disc >= 0); 
	  //std::cerr << disc << std::endl; 
	  //greatest solution
	  Value dres = ( ( -b + std::sqrt(disc) ) / (2*a) );
	  ASSERT(dres > 0); 
	  return dres; 
	}
    }
}

template <DGtal::Dimension dim>
inline
bool
DGtal::L2FirstOrderIncrementalMetricHelper<dim>::isValid () const
{
  return true; 
}

template <DGtal::Dimension dim>
inline
void
DGtal::L2FirstOrderIncrementalMetricHelper<dim>::selfDisplay ( std::ostream & out ) const
{
   out << "L2"; 
}

template <DGtal::Dimension dim>
inline
double
DGtal::L2FirstOrderIncrementalMetricHelper<dim>::gradientNorm(const Value& aValue, const Values& aValueList) const
{
  double sum = 0; 
  for(Dimension k = 0; k < dimension; ++k)
    {
      sum += ( std::pow(std::abs(aValue - aValueList[k]), 2.0) 
	       / myGridStepsVector[k] ); 
    }
  return sum; 
}

template <DGtal::Dimension dim>
inline
typename DGtal::L2FirstOrderIncrementalMetricHelper<dim>::Value
DGtal::L2FirstOrderIncrementalMetricHelper<dim>::unknownValue() const
{
  return myUnknownValue; 
}


template <DGtal::Dimension dim, typename TValue>
inline
DGtal::LInfinityFirstOrderIncrementalMetricHelper<dim, TValue>
::LInfinityFirstOrderIncrementalMetricHelper(const Value& aGridStep)
  : myUnknownValue( numeric_limits<Value>::max() )
{
  for (Dimension k = 0; k < dimension; ++k)
    myGridStepsVector[k] = aGridStep; 
}

template <DGtal::Dimension dim, typename TValue>
inline
DGtal::LInfinityFirstOrderIncrementalMetricHelper<dim, TValue>
::LInfinityFirstOrderIncrementalMetricHelper(const boost::array<Value, dimension>& aGridStepsVector)
  : myGridStepsVector(aGridStepsVector), 
    myUnknownValue( numeric_limits<Value>::max() )
{
}

template <DGtal::Dimension dim, typename TValue>
inline
DGtal::LInfinityFirstOrderIncrementalMetricHelper<dim, TValue>
::LInfinityFirstOrderIncrementalMetricHelper(const LInfinityFirstOrderIncrementalMetricHelper& other)
  : myGridStepsVector(other.myGridStepsVector), 
    myUnknownValue(other.myUnknownValue)
{
}

    

template <DGtal::Dimension dim, typename TValue>
inline
DGtal::LInfinityFirstOrderIncrementalMetricHelper<dim, TValue>
::~LInfinityFirstOrderIncrementalMetricHelper()
{
}

template <DGtal::Dimension dim, typename TValue>
inline
typename DGtal::LInfinityFirstOrderIncrementalMetricHelper<dim, TValue>::Value
DGtal::LInfinityFirstOrderIncrementalMetricHelper<dim, TValue>::compute(const Values& aValueList) const
{
  Dimensions relevantDimensions;
   //extract the dimensions where the value is initialized
  for(Dimension k = 0; k < dimension; ++k)
    {
      if ( aValueList[k] != unknownValue() )
	  relevantDimensions.insert(k); 
    }

  return compute(aValueList, relevantDimensions); 
}

template <DGtal::Dimension dim, typename TValue>
inline
typename DGtal::LInfinityFirstOrderIncrementalMetricHelper<dim, TValue>::Value
DGtal::LInfinityFirstOrderIncrementalMetricHelper<dim, TValue>::compute(const Values& aValueList, Dimensions& aDimensionList) const
{

  unsigned int c = aDimensionList.size();
  ASSERT( c > 0 ); 
  if ( c == 1 )
    {
      Dimension k = *aDimensionList.begin(); 
      return aValueList.at(k) + myGridStepsVector.at(k); 
    } 
  else 
    {
      //max computation
      Value max = 0;
      typename set<Dimension>::const_iterator it = aDimensionList.begin(); 
      typename set<Dimension>::const_iterator itEnd = aDimensionList.end(); 
      for ( ; it != itEnd; ++it) 
          {
          Value d = aValueList.at(*it);  
          if (d > max) max = d; 
          }   
      return max; 
    }
}

template <DGtal::Dimension dim, typename TValue>
inline
bool
DGtal::LInfinityFirstOrderIncrementalMetricHelper<dim, TValue>::isValid () const
{
  return true; 
}

template <DGtal::Dimension dim, typename TValue>
inline
void
DGtal::LInfinityFirstOrderIncrementalMetricHelper<dim, TValue>::selfDisplay ( std::ostream & out ) const
{
   out << "Linf"; 
}

template <DGtal::Dimension dim, typename TValue>
inline
typename DGtal::LInfinityFirstOrderIncrementalMetricHelper<dim, TValue>::Value
DGtal::LInfinityFirstOrderIncrementalMetricHelper<dim, TValue>::unknownValue() const
{
  return myUnknownValue; 
}



///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions                                        //

template <DGtal::Dimension dim>
inline
std::ostream&
DGtal::operator<< ( std::ostream & out, 
		    const L2FirstOrderIncrementalMetricHelper<dim> & object )
{
  object.selfDisplay( out );
  return out;
}


template <DGtal::Dimension dim, typename TValue>
inline
std::ostream&
DGtal::operator<< ( std::ostream & out, 
		    const LInfinityFirstOrderIncrementalMetricHelper<dim, TValue> & object )
{
  object.selfDisplay( out );
  return out;
}
