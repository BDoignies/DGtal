/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file FMMPointFunctors.ih
 * @author Tristan Roussillon (\c
 * tristan.roussillon@liris.cnrs.fr ) Laboratoire d'InfoRmatique en
 * Image et Syst√®mes d'information - LIRIS (CNRS, UMR 5205), CNRS,
 * France
 *
 *
 * @date 2012/02/21
 *
 * @brief Implementation of inline methods defined in FMMPointFunctors.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
//////////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------
template <typename TImage, typename TSet>
inline
DGtal::L2FirstOrderLocalDistance<TImage,TSet>::L2FirstOrderLocalDistance
  (Image& aImg, TSet& aSet): myImgPtr(&aImg), mySetPtr(&aSet)
{
}

//-----------------------------------------------------------------------------
template <typename TImage, typename TSet>
inline
DGtal::L2FirstOrderLocalDistance<TImage,TSet>::L2FirstOrderLocalDistance
  (const L2FirstOrderLocalDistance& other): myImgPtr(other.myImgPtr), mySetPtr(other.mySetPtr)
{
}

//-----------------------------------------------------------------------------
template <typename TImage, typename TSet>
inline
DGtal::L2FirstOrderLocalDistance<TImage,TSet>&
DGtal::L2FirstOrderLocalDistance<TImage,TSet>::operator=
  (const L2FirstOrderLocalDistance& other)
{
  if( this != &other)
  {
    myImgPtr = other.myImgPtr; 
    mySetPtr = other.mySetPtr; 
  }
  return *this; 
}

//-----------------------------------------------------------------------------
template <typename TImage, typename TSet>
inline
DGtal::L2FirstOrderLocalDistance<TImage,TSet>::~L2FirstOrderLocalDistance
  ()
{
}

//-----------------------------------------------------------------------------
template <typename TImage, typename TSet>
inline
typename DGtal::L2FirstOrderLocalDistance<TImage, TSet>::Value
DGtal::L2FirstOrderLocalDistance<TImage, TSet>::operator()
  (const Point& aPoint)
{

  //distance values
  Values v; 
  v.reserve(Point::dimension); 

  //two 1-neighbors
  Point neighbor1 = aPoint; 
  Point neighbor2 = aPoint;
 
  typename Point::Iterator it1 = neighbor1.begin(); 
  typename Point::Iterator it2 = neighbor2.begin(); 
  typename Point::ConstIterator it = aPoint.begin(); 
  typename Point::ConstIterator itEnd = aPoint.end(); 
  for ( ; it != itEnd; ++it, ++it1, ++it2)
    {//for each dimension

      typename Point::Coordinate c = *it; 
      *it1 = (c+1); 
      *it2 = (c-1);

      //neighboring values
      Value d, d1, d2 = 0; 
      bool flag1 = findAndGetValue( *myImgPtr, *mySetPtr, neighbor1, d1 );
      bool flag2 = findAndGetValue( *myImgPtr, *mySetPtr, neighbor2, d2 );
      if ( flag1 || flag2 ) 
	{
	  if ( flag1 && flag2 )
	    { //take the minimal value
	      if (std::abs(d1) < std::abs(d2))
		d = d1;
	      else 
		d = d2; 
	    } else 
	    {
	      if (flag1) d = d1;
	      if (flag2) d = d2; 
	    }

	  v.push_back(d); 
	}

      *it1 = c; 
      *it2 = c;
    } //end for each dimension

  //computation of the new value
    return this->compute(v); 
}


//-----------------------------------------------------------------------------
template <typename TImage, typename TSet>
inline
typename DGtal::L2FirstOrderLocalDistance<TImage, TSet>::Value
DGtal::L2FirstOrderLocalDistance<TImage, TSet>::compute
(Values& aValueList) const
{
  ASSERT(aValueList.size() > 0); 

  unsigned int nb = aValueList.size();
  if ( nb == 1 )
    {
      Value d = aValueList.back();
      if (d >= 0) return d + 1.0; 
      else return d - 1.0; 
    } 
  else 
    {
      //function computation
      typename Values::iterator itMax = 
	std::max_element( aValueList.begin(), aValueList.end(), details::absComparator ); 
      if ( gradientNorm( *itMax, aValueList ) > 1 )
	{
	  aValueList.erase( itMax ); 
	  return this->compute(aValueList); 
	}
      else 
	{ //resolution
	  double a = 0; 
	  double b = 0; 
	  double c = -1; 

	  for (typename Values::iterator it = aValueList.begin(); 
	       it != aValueList.end(); ++it)
	    {
	      Value d = *it; 

	      a += 1; 
	      b -= static_cast<double>(2*d);
	      c += static_cast<double>(d*d); 
	    }
 
	  //discriminant
	  double disc = b*b - 4*a*c;
	  ASSERT(disc >= 0); 
	  //greatest solution
	  double dres1 = ( ( -b + std::sqrt(disc) ) / (2*a) );
	  double dres2 = ( ( -b - std::sqrt(disc) ) / (2*a) );
    if ( std::abs(dres1) > std::abs(dres2) ) return static_cast<Value>(dres1); 
    else return static_cast<Value>(dres2); 
	}
    }

}

//-----------------------------------------------------------------------------
template <typename TImage, typename TSet>
inline
typename DGtal::L2FirstOrderLocalDistance<TImage, TSet>::Value
DGtal::L2FirstOrderLocalDistance<TImage, TSet>
::gradientNorm(const Value& aValue, const Values& aValueList) const
{
  double sum = 0; 
  for (typename Values::const_iterator it = aValueList.begin(); 
       it != aValueList.end(); ++it)
    {
      Value d = std::abs(aValue - *it); 
      sum += (d*d); 
    }
  return sum; 
}

//-----------------------------------------------------------------------------
template <typename TImage, typename TSet>
inline
void
DGtal::L2FirstOrderLocalDistance<TImage, TSet>
::selfDisplay ( std::ostream & out ) const
{
  out << "L2"; 
}

///////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------
template <typename TImage, typename TSet>
inline
DGtal::LInfFirstOrderLocalDistance<TImage,TSet>::LInfFirstOrderLocalDistance
  (Image& aImg, TSet& aSet): myImgPtr(&aImg), mySetPtr(&aSet)
{
}

//-----------------------------------------------------------------------------
template <typename TImage, typename TSet>
inline
DGtal::LInfFirstOrderLocalDistance<TImage,TSet>::LInfFirstOrderLocalDistance
  (const LInfFirstOrderLocalDistance& other): myImgPtr(other.myImgPtr), mySetPtr(other.mySetPtr)
{
}

//-----------------------------------------------------------------------------
template <typename TImage, typename TSet>
inline
DGtal::LInfFirstOrderLocalDistance<TImage,TSet>&
DGtal::LInfFirstOrderLocalDistance<TImage,TSet>::operator=
  (const LInfFirstOrderLocalDistance& other)
{
  if( this != &other)
  {
    myImgPtr = other.myImgPtr; 
    mySetPtr = other.mySetPtr; 
  }
  return *this; 
}

//-----------------------------------------------------------------------------
template <typename TImage, typename TSet>
inline
DGtal::LInfFirstOrderLocalDistance<TImage,TSet>::~LInfFirstOrderLocalDistance
  ()
{
}
//-----------------------------------------------------------------------------
template <typename TImage, typename TSet>
inline
typename DGtal::LInfFirstOrderLocalDistance<TImage, TSet>::Value
DGtal::LInfFirstOrderLocalDistance<TImage, TSet>::operator()
  (const Point& aPoint)
{

  //distance values
  Values v; 
  v.reserve(Point::dimension); 

  //two 1-neighbors
  Point neighbor1 = aPoint; 
  Point neighbor2 = aPoint;
 
  typename Point::Iterator it1 = neighbor1.begin(); 
  typename Point::Iterator it2 = neighbor2.begin(); 
  typename Point::ConstIterator it = aPoint.begin(); 
  typename Point::ConstIterator itEnd = aPoint.end(); 
  for ( ; it != itEnd; ++it, ++it1, ++it2)
    {//for each dimension

      typename Point::Coordinate c = *it; 
      *it1 = (c+1); 
      *it2 = (c-1);

      //neighboring values
      Value d, d1, d2 = 0; 
      bool flag1 = findAndGetValue( *myImgPtr, *mySetPtr, neighbor1, d1 );
      bool flag2 = findAndGetValue( *myImgPtr, *mySetPtr, neighbor2, d2 );
      if ( flag1 || flag2 ) 
	{
	  if ( flag1 && flag2 )
	    { //take the minimal value
 	      if (std::abs(d1) < std::abs(d2))
		d = d1;
	      else 
		d = d2; 
	    } else 
	    {
	      if (flag1) d = d1;
	      if (flag2) d = d2; 
	    }

	  v.push_back(d); 
	  
	}
      
      *it1 = c; 
      *it2 = c;
    } //end for each dimension

  //computation of the new value
  return this->compute(v); 

}

//-----------------------------------------------------------------------------
template <typename TImage, typename TSet>
inline
typename DGtal::LInfFirstOrderLocalDistance<TImage, TSet>::Value
DGtal::LInfFirstOrderLocalDistance<TImage, TSet>::compute
(Values& aValueList) const
{

  ASSERT(aValueList.size() > 0); 

  unsigned int nb = aValueList.size();
  if ( nb == 1 )
    {
      Value d = aValueList.back();
      if (d >= 0) ++d; 
      else --d; 
      return d; 
    } 
  else 
    { //max element
      typename Values::iterator it = 
	std::max_element( aValueList.begin(), aValueList.end(), details::absComparator ); 
      return *it; 
    }
}

//-----------------------------------------------------------------------------
template <typename TImage, typename TSet>
inline
void
DGtal::LInfFirstOrderLocalDistance<TImage, TSet>
::selfDisplay ( std::ostream & out ) const
{
  out << "LInf"; 
}

///////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------
template <typename TImage, typename TSet>
inline
DGtal::L1FirstOrderLocalDistance<TImage,TSet>::L1FirstOrderLocalDistance
  (Image& aImg, TSet& aSet): myImgPtr(&aImg), mySetPtr(&aSet)
{
}

//-----------------------------------------------------------------------------
template <typename TImage, typename TSet>
inline
DGtal::L1FirstOrderLocalDistance<TImage,TSet>::L1FirstOrderLocalDistance
  (const L1FirstOrderLocalDistance& other): myImgPtr(other.myImgPtr), mySetPtr(other.mySetPtr)
{
}

//-----------------------------------------------------------------------------
template <typename TImage, typename TSet>
inline
DGtal::L1FirstOrderLocalDistance<TImage,TSet>&
DGtal::L1FirstOrderLocalDistance<TImage,TSet>::operator=
  (const L1FirstOrderLocalDistance& other)
{
  if( this != &other)
  {
    myImgPtr = other.myImgPtr; 
    mySetPtr = other.mySetPtr; 
  }
  return *this;
}

//-----------------------------------------------------------------------------
template <typename TImage, typename TSet>
inline
DGtal::L1FirstOrderLocalDistance<TImage,TSet>::~L1FirstOrderLocalDistance
  ()
{
}
//-----------------------------------------------------------------------------
template <typename TImage, typename TSet>
inline
typename DGtal::L1FirstOrderLocalDistance<TImage, TSet>::Value
DGtal::L1FirstOrderLocalDistance<TImage, TSet>::operator()
  (const Point& aPoint)
{

  //distance values
  Values v; 
  v.reserve(2*Point::dimension); 

  //two 1-neighbors
  Point neighbor1 = aPoint; 
  Point neighbor2 = aPoint;
 
  typename Point::Iterator it1 = neighbor1.begin(); 
  typename Point::Iterator it2 = neighbor2.begin(); 
  typename Point::ConstIterator it = aPoint.begin(); 
  typename Point::ConstIterator itEnd = aPoint.end(); 
  for ( ; it != itEnd; ++it, ++it1, ++it2)
    {//for each dimension

      typename Point::Coordinate c = *it; 
      *it1 = (c+1); 
      *it2 = (c-1);

      //neighboring values
      Value d1, d2 = 0; 
      bool flag1 = findAndGetValue( *myImgPtr, *mySetPtr, neighbor1, d1 );
      bool flag2 = findAndGetValue( *myImgPtr, *mySetPtr, neighbor2, d2 );
      if (flag1) v.push_back( d1 );
      if (flag2) v.push_back( d2 ); 

      *it1 = c; 
      *it2 = c;
    } //end for each dimension

  //computation of the new value
  return this->compute(v); 

}

//-----------------------------------------------------------------------------
template <typename TImage, typename TSet>
inline
typename DGtal::L1FirstOrderLocalDistance<TImage, TSet>::Value
DGtal::L1FirstOrderLocalDistance<TImage, TSet>::compute
(Values& aValueList) const
{
  ASSERT(aValueList.size() > 0); 

  //min (in absolute values) 
  typename Values::iterator it = 
	std::min_element( aValueList.begin(), aValueList.end(), details::absComparator ); 
  Value vmin = *it; 

  //sign
  if (vmin >= 0) 
    return vmin + 1; 
  else 
    return vmin - 1; 
}

//-----------------------------------------------------------------------------
template <typename TImage, typename TSet>
inline
void
DGtal::L1FirstOrderLocalDistance<TImage, TSet>
::selfDisplay ( std::ostream & out ) const
{
  out << "L1"; 
}
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// Helper classes defined in the compilation unit (anonymous namespace)
// see operator() below
namespace
{
    //
    template<bool complementToOne>
    struct ValueBetween0And1 
    {
      template<typename Value>
      static Value get(const Value& v)
      { 
	ASSERT( (v>=0)&&(v<=1) ); 
	return v; 
      }
    }; 
    //specialization
    template< >
    struct ValueBetween0And1<true> 
    {
      template<typename Value>
      static Value get(const Value& v) 
      { 
	ASSERT( (v>=0)&&(v<=1) ); 
	return (1 - v); 
      }
    }; 
}

///////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------
template <typename TKSpace, typename TMap, bool isIndirect>
inline
DGtal::L2FirstOrderLocalDistanceFromCells<TKSpace,TMap,isIndirect>
::L2FirstOrderLocalDistanceFromCells
  (const KSpace& aK, Map& aMap): myKSpace(&aK), myMap(&aMap)
{
}

//-----------------------------------------------------------------------------
template <typename TKSpace, typename TMap, bool isIndirect>
inline
DGtal::L2FirstOrderLocalDistanceFromCells<TKSpace,TMap,isIndirect>
::L2FirstOrderLocalDistanceFromCells
  (const L2FirstOrderLocalDistanceFromCells& other)
: myKSpace(other.myKSpace), myMap(other.myMap)
{
}

//-----------------------------------------------------------------------------
template <typename TKSpace, typename TMap, bool isIndirect>
inline
DGtal::L2FirstOrderLocalDistanceFromCells<TKSpace,TMap,isIndirect>&
DGtal::L2FirstOrderLocalDistanceFromCells<TKSpace,TMap,isIndirect>
::operator=
  (const L2FirstOrderLocalDistanceFromCells& other)
{
  if( this != &other)
  {
    myMap = other.myMap; 
    myKSpace = other.myKSpace; 
  }
  return *this; 
}

//-----------------------------------------------------------------------------
template <typename TKSpace, typename TMap, bool isIndirect>
inline
DGtal::L2FirstOrderLocalDistanceFromCells<TKSpace,TMap,isIndirect>
::~L2FirstOrderLocalDistanceFromCells
  ()
{
}

//-----------------------------------------------------------------------------
template <typename TKSpace, typename TMap, bool isIndirect>
inline
typename DGtal::L2FirstOrderLocalDistanceFromCells<TKSpace,TMap,isIndirect>::Value
DGtal::L2FirstOrderLocalDistanceFromCells<TKSpace,TMap,isIndirect>::operator()
  (const Point& aPoint)
{

  //distance values
  Values v; 
  v.reserve(Point::dimension); 

  Cell spel = myKSpace->uSpel( aPoint );  
  for ( typename KSpace::DirIterator q = myKSpace->uDirs( spel ); 
	(q != 0); ++q ) 
    { //for each dimension
      const DGtal::Dimension dir = *q;

      /// for the direct orientation
      Cell surfel1 = myKSpace->uIncident( spel, dir, true );
      //ASSERT( myKSpace->uIsSurfel( surfel1 ) ); 
      ASSERT( myKSpace->uDim( surfel1 )  == (KSpace::dimension - 1) );

      /// for the indirect orientation
      Cell surfel2 = myKSpace->uIncident( spel, dir, false ); 
      //ASSERT( myKSpace->uIsSurfel( surfel2 ) ); 
      ASSERT( myKSpace->uDim( surfel2 )  == (KSpace::dimension - 1) );

      //neighboring values
      Value d = 0; 
      typename Map::iterator it1 = myMap->find( surfel1 );  
      typename Map::iterator it2 = myMap->find( surfel2 ); 
      bool flag1 = ( it1 != myMap->end() );
      bool flag2 = ( it2 != myMap->end() );
      if ( flag1 || flag2 ) 
	{
	  if ( flag1 && flag2 )
	    { //take the minimal value
	      ASSERT( (it1->second >= 0)&&(it1->second <= 1) ); 
	      ASSERT( (it2->second >= 0)&&(it2->second <= 1) ); 
	      if (it1->second < it2->second)
		d = ValueBetween0And1<isIndirect>
		  ::get( it1->second );
	      else 
		d = ValueBetween0And1<isIndirect>
		  ::get( it2->second ); 
	    } else 
	    {
	      if (flag1) 
		{
		  ASSERT( (it1->second >= 0)&&(it1->second <= 1) ); 
		  d = ValueBetween0And1<isIndirect>
		  ::get( it1->second );
		}
	      if (flag2) 
		{
		  ASSERT( (it2->second >= 0)&&(it2->second <= 1) ); 
		  d = ValueBetween0And1<isIndirect>
		  ::get( it2->second );
		}
	    }

	  if (d == 0) return 0;
 
	  v.push_back(d); 
	}

    } //end for each dimension

  //computation of the new value
  return this->compute(v); 
}


//-----------------------------------------------------------------------------
template <typename TKSpace, typename TMap, bool isIndirect>
inline
typename DGtal::L2FirstOrderLocalDistanceFromCells<TKSpace,TMap,isIndirect>::Value
DGtal::L2FirstOrderLocalDistanceFromCells<TKSpace,TMap,isIndirect>::compute
(Values& aValueList) const
{
  ASSERT(aValueList.size() > 0); 

  unsigned int nb = aValueList.size();
  if ( nb == 1 )
    {
      return aValueList.back();
    } 
  else 
    { //resolution
      double a = 0; 

      for (typename Values::iterator it = aValueList.begin(); 
	   it != aValueList.end(); ++it)
	{
	  Value d = *it; 
	  a += ( 1.0 / static_cast<double>( d*d ) ); 
	}

      return static_cast<Value>( std::sqrt(a) / a ); 
    }
}

//-----------------------------------------------------------------------------
template <typename TKSpace, typename TMap, bool isIndirect>
inline
void
DGtal::L2FirstOrderLocalDistanceFromCells<TKSpace,TMap, isIndirect>
::selfDisplay ( std::ostream & out ) const
{
  out << "L2"; 
}

