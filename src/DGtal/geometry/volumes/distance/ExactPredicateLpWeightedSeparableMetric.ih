/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file ExactLpWeightedSeparableMetric.ih
 * @author David Coeurjolly (\c david.coeurjolly@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Syst√®mes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 *
 * @date 2012/11/02
 *
 * Implementation of inline methods defined in ExactLpWeightedSeparableMetric.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------
template <typename T, DGtal::uint32_t p,  typename P>
inline
DGtal::ExactPredicateLpWeightedSeparableMetric<T,p,P>::ExactPredicateLpWeightedSeparableMetric()
{
}
//------------------------------------------------------------------------------
template <typename T, DGtal::uint32_t p,  typename P>
inline
DGtal::ExactPredicateLpWeightedSeparableMetric<T,p,P>::~ExactPredicateLpWeightedSeparableMetric()
{
}
//------------------------------------------------------------------------------
template <typename T, DGtal::uint32_t p,  typename P>
inline
typename DGtal::ExactPredicateLpWeightedSeparableMetric<T,p,P>::Promoted
DGtal::ExactPredicateLpWeightedSeparableMetric<T,p,P>::exactDistanceRepresentation (const Point &aP,
                                                                                      const Point &aQ) const
{
  Promoted res= NumberTraits<Promoted>::ZERO;
  for(DGtal::Dimension d=0; d< Point::dimension ; ++d)
    {
      res += BasicMathFunctions::power(static_cast<Promoted>(abs(aP[d]-aQ[d])), p);
    }
  return res;
}
//------------------------------------------------------------------------------
template <typename T,DGtal::uint32_t p,  typename P>
inline
typename DGtal::ExactPredicateLpWeightedSeparableMetric<T,p,P>::Weight
DGtal::ExactPredicateLpWeightedSeparableMetric<T,p,P>::powerDistance (const Point &aP,
                                                                        const Point &aQ,
                                                                        const Weight &aW) const
{
  return exactDistanceRepresentation(aP,aQ) - aW;
}
//------------------------------------------------------------------------------
template <typename T, DGtal::uint32_t p,  typename P>
inline
DGtal::Closest
DGtal::ExactPredicateLpWeightedSeparableMetric<T,p,P>::closestWeighted (const Point &origin, 
                                                                        const Point &first,  
                                                                        const Weight &wf,
                                                                        const Point &second,
                                                                        const Weight &ws) const
{
  Promoted a,b;
      
  a = exactDistanceRepresentation(origin, first) - wf;
  b = exactDistanceRepresentation(origin, second) - ws;
  
  if (a<b)
    return ClosestFIRST;
  else
    if (a>b)
      return ClosestSECOND;
    else
      return ClosestBOTH;
}
//------------------------------------------------------------------------------
template <typename T, DGtal::uint32_t p,  typename P>
inline
typename DGtal::ExactPredicateLpWeightedSeparableMetric<T,p,P>::Abscissa 
DGtal::ExactPredicateLpWeightedSeparableMetric<T,p,P>::binarySearchHidden(const Abscissa &udim, 
                                                                            const Abscissa &vdim,
                                                                            const Promoted &nu,
                                                                            const Promoted &nv,
                                                                            const Abscissa &lower,
                                                                            const Abscissa &upper) const
{   
  ASSERT(  (nu +  BasicMathFunctions::power( static_cast<Promoted>(abs( udim - lower)),  p)) <=
           (nv +  BasicMathFunctions::power( static_cast<Promoted>( abs( vdim - lower)), p)));
  
  //Recurrence stop 
  if ( (upper - lower) <= NumberTraits<Abscissa>::ONE)
    return lower;
  
  Abscissa mid = (lower + upper)/2;
  Promoted nuUpdated = nu +  BasicMathFunctions::power( static_cast<Promoted>(abs( udim - mid )), p);
  Promoted nvUpdated = nv +  BasicMathFunctions::power( static_cast<Promoted>(abs( vdim - mid )), p);
      
  //Recursive call
  if ( nuUpdated < nvUpdated)
    return binarySearchHidden(udim,vdim,nu,nv,mid,upper);
  else
    return binarySearchHidden(udim,vdim,nu,nv,lower,mid);
      
}
//------------------------------------------------------------------------------
template <typename T, DGtal::uint32_t p ,  typename P>
inline
bool 
DGtal::ExactPredicateLpWeightedSeparableMetric<T,p,P>::hiddenByWeighted(const Point &u, 
                                                                          const Weight &wu,
                                                                          const Point &v,
                                                                          const Weight &wv,
                                                                          const Point &w, 
                                                                          const Weight &ww,
                                                                          const Point &startingPoint,
                                                                          const Point &endPoint,
                                                                          const typename Point::UnsignedComponent dim) const
{
  //Interval bound for the binary search
  Abscissa lower = startingPoint[dim];
  Abscissa upper = endPoint[dim];
      
 
  //Partial norm computation
  // (sum_{i!=dim}  |u_i-v_i|^p
  Promoted nu = NumberTraits<Promoted>::ZERO;
  Promoted nv = NumberTraits<Promoted>::ZERO;
  Promoted nw = NumberTraits<Promoted>::ZERO;
  for(DGtal::Dimension i  = 0 ; i < Point::dimension ; i++)
    if (i != dim)
      {
        nu += BasicMathFunctions::power ( static_cast<Promoted>(abs(u[i]  - startingPoint[i])) , p);
        nv += BasicMathFunctions::power ( static_cast<Promoted>(abs(v[i] - startingPoint[i] )) , p);
        nw += BasicMathFunctions::power ( static_cast<Promoted>(abs(w[i] - startingPoint[i] )) , p);
      }
 
  //Intersection of voronoi boundary
     
  //Optimization if vw lies before starting
  if ((nv + BasicMathFunctions::power( static_cast<Promoted>(abs( v[dim] - lower)),  p)) >
      (nw + BasicMathFunctions::power( static_cast<Promoted>(abs( w[dim] - lower)), p)))
    {
      if(startingPoint[1]==7)
        trace.info()<<"Testing "<<u<<"  "<<v<<"  "<<w<<" --> "<<(int)true<<std::endl;
      return true;
    }
  //Optimization if vw lies before starting   
  if ((nu + BasicMathFunctions::power( static_cast<Promoted>(abs( u[dim] - lower)),  p)) >
      (nv + BasicMathFunctions::power( static_cast<Promoted>(abs( v[dim] - lower)), p)))
    {
      if(startingPoint[1]==7)
        trace.info()<<"Testing "<<u<<"  "<<v<<"  "<<w<<" --> "<<(int)false<<std::endl;
      return false;
    }
  
  //Binary search
  Abscissa uv = binarySearchHidden(u[dim],v[dim],nu,nv,lower,upper); 
  Abscissa vw = binarySearchHidden(v[dim],w[dim],nv,nw,lower,upper);

  if(startingPoint[1]==7)
    trace.info()<<"Testing "<<u<<"  "<<v<<"  "<<w<<" --> "<<(int)(uv> vw)<<std::endl;
 
  if ( uv > vw )
    return true;
  else
    return false;
      
}
//------------------------------------------------------------------------------
template <typename T, DGtal::uint32_t p,  typename P>
inline
void
DGtal::ExactPredicateLpWeightedSeparableMetric<T,p,P>::selfDisplay ( std::ostream & out ) const
{
  out << "[ExactPredicateLpWeightedSeparableMetric] p="<<p;
}
//------------------------------------------------------------------------------
template <typename T, DGtal::uint32_t p,  typename P>
inline
bool
DGtal::ExactPredicateLpWeightedSeparableMetric<T,p,P>::isValid() const
{
    return true;
}
//------------------------------------------------------------------------------
template <typename T, DGtal::uint32_t p,  typename P>
inline
std::ostream&
DGtal::operator<< ( std::ostream & out, 
                    const ExactPredicateLpWeightedSeparableMetric<T,p,P> & object )
{
  object.selfDisplay( out );
  return out;
}

///////////////////////////////////////////////////////////////////////////////
//            L_2 specialization                                             //
///////////////////////////////////////////////////////////////////////////////


// ----------------------- Standard services ------------------------------
template <typename T,  typename P>
inline
DGtal::ExactPredicateLpWeightedSeparableMetric<T,2,P>::ExactPredicateLpWeightedSeparableMetric()
{
}
//------------------------------------------------------------------------------
template <typename T,  typename P>
inline
DGtal::ExactPredicateLpWeightedSeparableMetric<T,2,P>::~ExactPredicateLpWeightedSeparableMetric()
{
}
//------------------------------------------------------------------------------
template <typename T, typename P>
inline
typename DGtal::ExactPredicateLpWeightedSeparableMetric<T,2,P>::Promoted
DGtal::ExactPredicateLpWeightedSeparableMetric<T,2,P>::exactDistanceRepresentation (const Point &aP,
                                                                                      const Point &aQ) const
{
  Promoted res= NumberTraits<Promoted>::ZERO;
  for(DGtal::Dimension d=0; d< Point::dimension ; ++d)
    {
      res += static_cast<Promoted>(aP[d]-aQ[d])*static_cast<Promoted>(aP[d]-aQ[d]);
    }
  return res;
}
//------------------------------------------------------------------------------
template <typename T, typename P>
inline
typename DGtal::ExactPredicateLpWeightedSeparableMetric<T,2,P>::Weight
DGtal::ExactPredicateLpWeightedSeparableMetric<T,2,P>::powerDistance (const Point &aP,
                                                                        const Point &aQ,
                                                                        const Weight &aW) const
{
  return exactDistanceRepresentation(aP,aQ) - aW;
}
//------------------------------------------------------------------------------
template <typename T,  typename P>
inline
DGtal::Closest
DGtal::ExactPredicateLpWeightedSeparableMetric<T,2,P>::closestWeighted (const Point &origin, 
                                                                          const Point &first, 
                                                                          const Weight &wF,
                                                                          const Point &second,
                                                                          const Weight &wS) const
{
  Promoted a=NumberTraits<Promoted>::ZERO,
    b=NumberTraits<Promoted>::ZERO;
      
  a = exactDistanceRepresentation(origin,first) - wF;
  b = exactDistanceRepresentation(origin,second) - wS;

  if (a<b)
    return ClosestFIRST;
  else
    if (a>b)
      return ClosestSECOND;
    else
      return ClosestBOTH;
}
//------------------------------------------------------------------------------
template <typename T,  typename P>
inline
typename DGtal::ExactPredicateLpWeightedSeparableMetric<T,2,P>::Abscissa 
DGtal::ExactPredicateLpWeightedSeparableMetric<T,2,P>::binarySearchHidden(const Abscissa &udim, 
                                                                            const Abscissa &vdim,
                                                                            const Promoted &nu,
                                                                            const Promoted &nv,
                                                                            const Abscissa &lower,
                                                                            const Abscissa &upper) const
{   
  ASSERT(false && "Not Necessary for l_2");
  
}
//------------------------------------------------------------------------------
template <typename T,   typename P>
inline
bool 
DGtal::ExactPredicateLpWeightedSeparableMetric<T,2,P>::hiddenByWeighted(const Point &u, 
                                                                          const Weight &wu,
                                                                          const Point &v,
                                                                          const Weight &wv,
                                                                          const Point &w, 
                                                                          const Weight &ww,
                                                                          const Point &startingPoint,
                                                                          const Point &endPoint,
                                                                          const typename Point::UnsignedComponent dim) const
{
  Promoted a,b, c;

  a = v[dim] - u[dim];
  b = w[dim] - v[dim];
  c = a + b;  
  
  Promoted d2_v=NumberTraits<Promoted>::ZERO, d2_u=NumberTraits<Promoted>::ZERO ,d2_w=NumberTraits<Promoted>::ZERO;

  for(DGtal::Dimension i  = 0 ; i < Point::dimension ; i++)
    if (i != dim)
      {
        d2_u += static_cast<Promoted>(u[i] - startingPoint[i] ) *static_cast<Promoted>(u[i] - startingPoint[i] );
        d2_v += static_cast<Promoted>(v[i] - startingPoint[i] ) *static_cast<Promoted>(v[i] - startingPoint[i] );
        d2_w += static_cast<Promoted>(w[i] - startingPoint[i] ) *static_cast<Promoted>(w[i] - startingPoint[i] );
      }
 
  return (c * d2_v -  b*d2_u - a*d2_w - a*b*c) > 0 ;       
}
//------------------------------------------------------------------------------
template <typename T,   typename P>
inline
void
DGtal::ExactPredicateLpWeightedSeparableMetric<T,2,P>::selfDisplay ( std::ostream & out ) const
{
  out << "[ExactPredicateLpWeightedSeparableMetric] p=2";
}
//------------------------------------------------------------------------------
template <typename T,  typename P>
inline
bool
DGtal::ExactPredicateLpWeightedSeparableMetric<T,2,P>::isValid() const
{
    return true;
}
