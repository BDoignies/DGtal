/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file FMM.ih
 * @author Tristan Roussillon (\c
 * tristan.roussillon@liris.cnrs.fr ) Laboratoire d'InfoRmatique en
 * Image et Syst√®mes d'information - LIRIS (CNRS, UMR 5205), CNRS,
 * France
 *
 *
 * @date 2012/01/17
 *
 * @brief Implementation of inline methods defined in FMM.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------


template <typename TMetric, typename TPointPredicate>
inline
DGtal::FMM<TMetric, TPointPredicate>::FMM(AcceptedPointSet& aSet, const Metric& aM, const PointPredicate& aPointPredicate): 
myAcceptedPoints( aSet ), myM( aM ), myPointPredicate( aPointPredicate ), 
myAreaThreshold( std::numeric_limits<Area>::max() ), 
myMetricValueThreshold( std::numeric_limits<MetricValue>::max() )
{
  if (myAcceptedPoints.size() == 0) throw InputException(); 
  init(); 
}


template <typename TMetric, typename TPointPredicate>
inline
DGtal::FMM<TMetric, TPointPredicate>::FMM(AcceptedPointSet& aSet, const Metric& aM, const PointPredicate& aPointPredicate, const Area& aAreaThreshold, const MetricValue& aMetricValueThreshold): 
myAcceptedPoints( aSet ), myM( aM ), myPointPredicate( aPointPredicate ), 
myAreaThreshold( aAreaThreshold ), 
myMetricValueThreshold( aMetricValueThreshold )
{
  if (myAcceptedPoints.size() == 0) throw InputException(); 
  init();
}


template <typename TMetric, typename TPointPredicate>
inline
DGtal::FMM<TMetric, TPointPredicate>::~FMM()
{
}

///////////////////////////////////////////////////////////////////////////////
// Static functions :


template <typename TMetric, typename TPointPredicate>
template <typename TIteratorOnPoints>
void
DGtal::FMM<TMetric, TPointPredicate>
::initInnerPoints(const TIteratorOnPoints& itb, const TIteratorOnPoints& ite, 
		  AcceptedPointSet& aMap, 
		  const MetricValue& aMetricValue)
{
  TIteratorOnPoints it = itb; 
  for ( ; it != ite; ++it) 
    {
      aMap.insert( PointMetricValue(*it,aMetricValue) ); 
    }
}

template <typename TMetric, typename TPointPredicate>
template <typename TIteratorOnPairs>
void
DGtal::FMM<TMetric, TPointPredicate>
::initIncidentPoints(const TIteratorOnPairs& itb, const TIteratorOnPairs& ite, 
		     AcceptedPointSet& aMap, 
		     const MetricValue& aMetricValue, 
		     bool aFlagIsPositive)
{
  MetricValue k = -1; 
  if (aFlagIsPositive) k = 1; 

  TIteratorOnPairs it = itb; 
  for ( ; it != ite; ++it) 
    {
      Point inner( it->first ); 
      Point outer( it->second ); 
      aMap.insert( PointMetricValue(inner,k*aMetricValue) ); 
      aMap.insert( PointMetricValue(outer,-k*aMetricValue) ); 
    }
}

///////////////////////////////////////////////////////////////////////////////
// Interface - public :


template <typename TMetric, typename TPointPredicate>
inline
void
DGtal::FMM<TMetric, TPointPredicate>::compute()
{
  while ( addNewAcceptedPoint() )
    {   }
}


template <typename TMetric, typename TPointPredicate>
inline
bool
DGtal::FMM<TMetric, TPointPredicate>::isValid() const
{
  //area threshold
  if (myAcceptedPoints.size() >= myAreaThreshold) return false;

  //distance threshold
  MetricValue max = 0; 
  {
    typename AcceptedPointSet::const_iterator it = myAcceptedPoints.begin(); 
    typename AcceptedPointSet::const_iterator itEnd = myAcceptedPoints.end(); 
    for ( ; it != itEnd; ++it)
      {
	if (it->second > max) max = it->second; 
      }
  }
  if (max >= myMetricValueThreshold) return false; 

  //point predicate
  bool flagIsOk = true;  
  {
    typename AcceptedPointSet::const_iterator it = myAcceptedPoints.begin(); 
    typename AcceptedPointSet::const_iterator itEnd = myAcceptedPoints.end(); 
    for ( ; ( (it != itEnd)&&(flagIsOk == true) ); ++it)
      {
	if (myPointPredicate(it->first) == false) flagIsOk = false;  
      }
  }
  if (!flagIsOk) return false; 

  return true; 
}

template <typename TMetric, typename TPointPredicate>
inline
void
DGtal::FMM<TMetric, TPointPredicate>::selfDisplay ( std::ostream & out ) const
{
   out << "[FMM]" << std::endl;
   out << myAcceptedPoints.size() << " accepted points (< " << myAreaThreshold << ")" << std::endl; 
   out << myCandidatePoints.size() << " candidates " << std::endl; 
   out << myM << " metric " << std::endl; 
   //min and max distance
   MetricValue min = std::numeric_limits<MetricValue>::infinity(); 
   MetricValue max = 0; 
  typename AcceptedPointSet::const_iterator it = myAcceptedPoints.begin(); 
  typename AcceptedPointSet::const_iterator itEnd = myAcceptedPoints.end(); 
  for ( ; it != itEnd; ++it)
    {
      if (it->second < min) min = it->second; 
      if (it->second > max) max = it->second; 
    }
  out << "min: " << min << " (abs < " << myMetricValueThreshold << ")" << std::endl; 
  out << "max: " << max << " (abs < " << myMetricValueThreshold << ")" << std::endl;
  out << "[/FMM]" << std::endl;
}


///////////////////////////////////////////////////////////////////////////////
// Internals

template <typename TMetric, typename TPointPredicate>
inline
void
DGtal::FMM<TMetric, TPointPredicate>::init()
{
  typename AcceptedPointSet::const_iterator it = myAcceptedPoints.begin(); 
  typename AcceptedPointSet::const_iterator itEnd = myAcceptedPoints.end(); 
  for ( ; it != itEnd; ++it)
    {
      update(it->first); 
    }
}

template <typename TMetric, typename TPointPredicate>
inline
bool
DGtal::FMM<TMetric, TPointPredicate>::addNewAcceptedPoint()
{

  if ( (myAcceptedPoints.size()+1) < myAreaThreshold )
    {//if a new point can be accepted

      bool flagStop = false; 
      typename CandidatePointSet::iterator it = myCandidatePoints.begin();  
      typename CandidatePointSet::iterator itEnd = myCandidatePoints.end();  
      while ( (it != itEnd) && (!flagStop) )
	{ //while there are candidates and no point has been accepted

	  //pair of min distance
	  PointMetricValue minPair = *it; 

	  if ( std::abs(minPair.second) < myMetricValueThreshold ) 
	    { //if distance below a given threshold

	      //the point of min distance is removed from the set of candidates
	      myCandidatePoints.erase(*it); 
	      //it is inserted into the set of accepted points
	      std::pair<typename AcceptedPointSet::iterator, bool> 
		result = myAcceptedPoints.insert(minPair);
	      if (result.second) //if it was really inserted 
		{ //the set of candidates is updated with 
		  //the neigbors of the new accepted point
		  update(minPair.first); 
		  flagStop = true; 
		}      
	      else 
		{ //otherwise it has already been accepted
		  //with a smaller distance and the next candidate
		  //should be considered
		  it = myCandidatePoints.begin(); 
		}

	    }//end if distance below a given threshold
	  else return false; 

	} //end while there are candidates

      return flagStop; //true if a point has been accepted 

    } //end if a new point can be accepted
  else return false; 
}

template <typename TMetric, typename TPointPredicate>
inline
void
DGtal::FMM<TMetric, TPointPredicate>::update(const Point& aPoint)
{
 
  //neigbors
  Point neighbor = aPoint; 
  for (Dimension k = 0; k < dimension; ++k)
    {
      typename Point::Coordinate c = neighbor.at(k); 
      neighbor.at(k) = (c+1); 
      addNewCandidate(neighbor); 
      neighbor.at(k) = (c-1); 
      addNewCandidate(neighbor); 
      neighbor.at(k) = c; 
    }
}

template <typename TMetric, typename TPointPredicate>
inline
bool
DGtal::FMM<TMetric, TPointPredicate>::addNewCandidate(const Point& aPoint)
{

  //if it is not already accepted 
  //and if it lies within the computation domain
  if ( ( myAcceptedPoints.find(aPoint) == myAcceptedPoints.end() ) 
       && (myPointPredicate(aPoint)) ) 
    {
      MetricValue d = myM(aPoint,myAcceptedPoints); 
      PointMetricValue newPair( aPoint, d ); 
      //insert the new candidate with its distance
      std::pair<typename CandidatePointSet::iterator, bool> 
	result = myCandidatePoints.insert(newPair);
      return result.second; 
    } 
  else return false; 
}


///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions                                        //

template <typename TMetric, typename TPointPredicate>
inline
std::ostream&
DGtal::operator<< ( std::ostream & out, 
      const FMM<TMetric, TPointPredicate> & object )
{
  object.selfDisplay( out );
  return out;
}

//                                                                           //
///////////////////////////////////////////////////////////////////////////////


