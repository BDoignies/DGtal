/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file ArithmeticalDSS.ih
 * @author Tristan Roussillon (\c tristan.roussillon@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Syst√®mes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 *
 * @date 2013/06/28
 *
 * Implementation of inline methods defined in ArithmeticalDSS.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------

template <typename TC, typename TI, unsigned short adj>
inline
DGtal::ArithmeticalDSS<TC, TI, adj>
::ArithmeticalDSS(const Integer& aA, const Integer& aB, 
		  const Integer& aMu, const Integer& aOmega, 
		  const Point& aF, const Point& aL,
		  const Point& aUf, const Point& aUl,
		  const Point& aLf, const Point& aLl)
:
  myA(aA), myB(aB), myMu(aMu), myOmega(aOmega),
  myF(aF), myL(aL),
  myUf(aUf), myUl(aUl), myLf(aLf), myLl(aLl) 
{
  //TODO + isValid
  myStep1 = Vector(0,0); 
  myStep2 = Vector(0,0); 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
DGtal::ArithmeticalDSS<TC, TI, adj>
::ArithmeticalDSS(const Integer& aA, const Integer& aB, 
		  const Integer& aMu, 
		  const Point& aF, const Point& aL,
		  const Point& aUf, const Point& aUl,
		  const Point& aLf, const Point& aLl)
:
  myA(aA), myB(aB), myMu(aMu), 
  myOmega( remainder( DGtal::ArithmeticalDSSKernel<TC,adj>::shift(myA, myB) ) ),
  myF(aF), myL(aL),
  myUf(aUf), myUl(aUl), myLf(aLf), myLl(aLl) 
{
  //TODO + isValid
  myStep1 = Vector(0,0); 
  myStep2 = Vector(0,0); 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
DGtal::ArithmeticalDSS<TC, TI, adj>
::ArithmeticalDSS(const Point& aF, const Point& aL)
{
  //first and last points
  myF = aF; 
  myL = aL; 

  //upper leaning points 
  myUf = myF; 
  myUl = myF; 

  //irreductible direction vector
  Vector u2 = aL - aF; 
  IntegerComputer<Coordinate> computer; 
  Coordinate gcd = computer.gcd(u2[0], u2[1]); 
  Vector u = Vector(u2[0]/gcd, u2[1]/gcd);

  //Bezout
  Vector v = computer.extendedEuclid(-u[1], u[0], 1); 

  //Shift
  Vector s = DGtal::ArithmeticalDSSKernel<TC,adj>::shift(u[1], u[0]); 

  //(a, b, mu, omega) parameters
  myA = u[1]; 
  myB = u[0]; 
  myMu = remainder( myF ); 
  myOmega = remainder(s); 

  //lower leaning points
  myLf = myF + v + s; 
  myLl = myF + (gcd-1)*u + v + s; 


  //TODO + isValid
  myStep1 = Vector(0,0); 
  myStep2 = Vector(0,0); 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
DGtal::ArithmeticalDSS<TC, TI, adj>
::ArithmeticalDSS(const ArithmeticalDSS<TC, TI, adj>& aOther)
: 
  myA(aOther.myA), myB(aOther.myB), myMu(aOther.myMu), myOmega(aOther.myOmega),
  myF(aOther.myF), myL(aOther.myL),
  myUf(aOther.myUf), myUl(aOther.myUl), myLf(aOther.myLf), myLl(aOther.myLl),
  myStep1(aOther.myStep1), myStep2(aOther.myStep2)
{}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
DGtal::ArithmeticalDSS<TC, TI, adj>&
DGtal::ArithmeticalDSS<TC, TI, adj>
::operator=(const ArithmeticalDSS<TC, TI, adj>& aOther)
{
  if ( this != &aOther )
    {
      myA = aOther.myA;
      myB = aOther.myB;
      myMu = aOther.myMu;
      myOmega = aOther.myOmega;
      myF = aOther.myF;
      myL = aOther.myL;
      myUf = aOther.myUf;
      myLf = aOther.myLf;
      myUl = aOther.myUl;
      myLl = aOther.myLl;
      myStep1 = aOther.myStep1; 
      myStep2 = aOther.myStep2; 
    }
  return *this;
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
bool
DGtal::ArithmeticalDSS<TC, TI, adj>
::operator==(const ArithmeticalDSS<TC, TI, adj>& aOther)
{
  return ( ( (myOmega == aOther.myOmega) &&
	     (myUf == aOther.myUf) && 
	     (myUl == aOther.myUl) &&  
	     (myLf == aOther.myLf) &&  
	     (myLl == aOther.myLl) && 
	     (myF == aOther.myF) &&  
	     (myL == aOther.myL) ) || 
	   ( (myOmega == aOther.myOmega) &&
	     (myUf == aOther.myLl) && 
	     (myUl == aOther.myLf) &&  
	     (myLf == aOther.myUl) &&  
	     (myLl == aOther.myUf) && 
	     (myF == aOther.myL) &&  
	     (myL == aOther.myF) ) );
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
bool
DGtal::ArithmeticalDSS<TC, TI, adj>
::operator!=(const ArithmeticalDSS<TC, TI, adj>& aOther)
{
  return !( (*this) == aOther ); 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
DGtal::ArithmeticalDSS<TC, TI, adj>::~ArithmeticalDSS()
{
}

///////////////////////////////////////////////////////////////////////////////
// Interface - public :


//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
bool
DGtal::ArithmeticalDSS<TC, TI, adj>::isValid() const
{

  if (myF == myL) { 

    //special case with one point
    if ( (myA==0)
  	 &&(myB==0)
  	 &&(myMu==0)
  	 &&(myOmega==0)
  	 &&(myUf==myF)
  	 &&(myLf==myF)
  	 &&(myUl==myL)
  	 &&(myLl==myL) ) 
      return true;
    else return false; 

  } else {

    //general case
    Integer gcd = IntegerComputer<Integer>::staticGcd(myA, myB); 
    if (gcd != NumberTraits<Integer>::ONE) 
      return false; //a,b should be relatively prime
    else
      {
	//remainders of leaning points
	if (remainder(myUf) != myMu) return false;
	else if (remainder(myUl) != myMu) return false;
	else if (remainder(myLf) != myMu+myOmega-1) return false;
	else if (remainder(myLl) != myMu+myOmega-1) return false;
	else 
	  {
	    //number of patterns
	    Vector vu = myUl - myUf; 
	    Coordinate gcdu = IntegerComputer<Coordinate>::staticGcd(vu[0], vu[1]); 
	    if ( (myB*static_cast<Integer>(gcdu) != static_cast<Coordinate>(vu[0]))
		 || (myA*static_cast<Integer>(gcdu) != static_cast<Coordinate>(vu[1])) )
	      return false;  
	    Vector vl = myLl - myLf; 
	    Coordinate gcdl = IntegerComputer<Coordinate>::staticGcd(vl[0], vl[1]); 
	    if ( (myB*static_cast<Integer>(gcdl) != static_cast<Coordinate>(vl[0]))
		 || (myA*static_cast<Integer>(gcdl) != static_cast<Coordinate>(vl[1])) )
	      return false; 
	    return true;
	  }
      }
  }
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::Integer
DGtal::ArithmeticalDSS<TC, TI, adj>::a() const
{
  return myA; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::Integer
DGtal::ArithmeticalDSS<TC, TI, adj>::b() const
{
  return myB; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::Integer
DGtal::ArithmeticalDSS<TC, TI, adj>::mu() const
{
  return myMu; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::Integer
DGtal::ArithmeticalDSS<TC, TI, adj>::omega() const
{
  return myOmega; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::Point
DGtal::ArithmeticalDSS<TC, TI, adj>::back() const
{
  return myF; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::Point
DGtal::ArithmeticalDSS<TC, TI, adj>::front() const
{
  return myL; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::Point
DGtal::ArithmeticalDSS<TC, TI, adj>::Uf() const
{
  return myUf; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::Point
DGtal::ArithmeticalDSS<TC, TI, adj>::Ul() const
{
  return myUl; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::Point
DGtal::ArithmeticalDSS<TC, TI, adj>::Lf() const
{
  return myLf; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::Point
DGtal::ArithmeticalDSS<TC, TI, adj>::Ll() const
{
  return myLl; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::Integer
DGtal::ArithmeticalDSS<TC, TI, adj>::remainder(const Point& aPoint) const
{
  return myA * static_cast<Integer>(aPoint[0])
    - myB * static_cast<Integer>(aPoint[1]);
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::Integer
DGtal::ArithmeticalDSS<TC, TI, adj>::orthogonalPosition(const Point& aPoint) const
{
  return myB * static_cast<Integer>(aPoint[0])
    + myA * static_cast<Integer>(aPoint[1]);
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
bool
DGtal::ArithmeticalDSS<TC, TI, adj>::isInDSL(const Point& aPoint) const
{
  Integer r = remainder(aPoint);
  return ( (r >= myMu)&&(r < myMu+myOmega) );
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
bool
DGtal::ArithmeticalDSS<TC, TI, adj>::isInDSS(const Point& aPoint) const
{
  if (isInDSL(aPoint))
    {
      Integer s = orthogonalPosition(aPoint);
      Integer s1 = orthogonalPosition(myF);
      Integer s2 = orthogonalPosition(myL);
      if (s1 < s2)
	return ( (s >= s1)&&(s <= s2) );
      else 
	return ( (s >= s2)&&(s <= s1) );
    }
  else 
    return false; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
bool
DGtal::ArithmeticalDSS<TC, TI, adj>::operator()(const Point& aPoint) const
{
  return isInDSS(aPoint); 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator
DGtal::ArithmeticalDSS<TC, TI, adj>::begin() const
{
  return ConstIterator(this, myF);
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator
DGtal::ArithmeticalDSS<TC, TI, adj>::end() const
{
  ConstIterator it(this, myL); 
  it++; 
  return it;
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::ConstReverseIterator
DGtal::ArithmeticalDSS<TC, TI, adj>::rbegin() const
{
  return ConstReverseIterator( end() );
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::ConstReverseIterator
DGtal::ArithmeticalDSS<TC, TI, adj>::rend() const
{
  return ConstReverseIterator( begin() );
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
void
DGtal::ArithmeticalDSS<TC, TI, adj>::selfDisplay ( std::ostream & out ) const
{
  out << "[ArithmeticalDSS] ";
  out << "(" << myA << "," << myB << "," << myMu << "," << myOmega << ")" << std::endl; 
  out << "from " << myF << " to " << myL << std::endl; 
  out << "by steps " << myStep1 << " " << myStep2 << std::endl; 
  out << "upper leaning points: " << myUf << " " << myUl << std::endl;  
  out << "lower leaning points: " << myLf << " " << myLl; 
}

///////////////////////////////////////////////////////////////////////////////
//                   Iterators services                                      //
///////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator::ConstIterator()
  : myDSS(0), myCurrentPoint()
{
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator
::ConstIterator( const ArithmeticalDSS* aDSS, const Point& aPoint )
  : myDSS(aDSS), myCurrentPoint(aPoint)
{
  mySteps = DGtal::ArithmeticalDSSKernel<TC, adj>
    ::steps(myDSS->a(), myDSS->b());  

  myQuantityToAdd = myDSS->remainder(mySteps.first);
  Vector shift = mySteps.second - mySteps.first; 
  myQuantityToRemove = -myDSS->remainder(shift); 
  myLowerBound = myDSS->mu();
  myUpperBound = myDSS->mu() + myDSS->omega();
  myCurrentRemainder = myDSS->remainder( myCurrentPoint ); 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator::
ConstIterator( const ConstIterator & aOther )
  : myDSS( aOther.myDSS ), myCurrentPoint( aOther.myCurrentPoint ),
    mySteps( aOther.mySteps ), 
    myQuantityToAdd( aOther.myQuantityToAdd ), 
    myQuantityToRemove( aOther.myQuantityToRemove ), 
    myUpperBound( aOther.myUpperBound ), 
    myLowerBound( aOther.myLowerBound ), 
    myCurrentRemainder( aOther.myCurrentRemainder ) 
{ } 


//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator& 
DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator::
operator= ( const ConstIterator & aOther ) 
{
  if (this != &aOther)
    {
      myDSS = aOther.myDSS; 
      myCurrentPoint = aOther.myCurrentPoint; 
      mySteps = aOther.mySteps; 
      myQuantityToAdd = aOther.myQuantityToAdd; 
      myQuantityToRemove = aOther.myQuantityToRemove; 
      myUpperBound = aOther.myUpperBound; 
      myLowerBound = aOther.myLowerBound; 
      myCurrentRemainder = aOther.myCurrentRemainder; 
    }
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator::~ConstIterator()
{
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::Point 
DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator::
operator*() const
{
  return myCurrentPoint;
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
void
DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator::
next()
{
  myCurrentRemainder += myQuantityToAdd; 
  if ( myCurrentRemainder < myUpperBound )
    {
      myCurrentPoint += mySteps.first; 
    }
  else
    {
      myCurrentRemainder -= myQuantityToRemove; 
      myCurrentPoint += mySteps.second; 
    }
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator&
DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator::
operator++()
{
  this->next(); 
  return *this;
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator
DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator::
operator++(int)
{
  ConstIterator tmp(*this);
  this->next();
  return tmp;
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
void
DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator::
previous()
{
  myCurrentRemainder -= myQuantityToAdd; 
  if ( myCurrentRemainder >= myLowerBound )
    {
      myCurrentPoint -= mySteps.first; 
    }
  else
    {
      myCurrentRemainder += myQuantityToRemove; 
      myCurrentPoint -= mySteps.second; 
    }
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator&
DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator::
operator--()
{
  this->previous();
  return *this;
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator
DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator::
operator--(int)
{
  ConstIterator tmp(*this);
  this->previous();
  return tmp;
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
bool
DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator::
operator==(const ConstIterator& aOther) const
{
  ASSERT( myDSS == aOther.myDSS );
  return myCurrentPoint == aOther.myCurrentPoint;
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
bool
DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator::
operator!=(const ConstIterator& aOther) const
{
  ASSERT( myDSS == aOther.myDSS );
  return myCurrentPoint != aOther.myCurrentPoint;
}

///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions                                        //

template <typename TC, typename TI, unsigned short adj>
inline
std::ostream&
DGtal::operator<< ( std::ostream & out, 
		  const ArithmeticalDSS<TC, TI, adj> & object )
{
  object.selfDisplay( out );
  return out;
}

//                                                                           //
///////////////////////////////////////////////////////////////////////////////


