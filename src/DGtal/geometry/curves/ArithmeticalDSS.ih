/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file ArithmeticalDSS.ih
 * @author Tristan Roussillon (\c tristan.roussillon@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Syst√®mes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 *
 * @date 2013/06/28
 *
 * Implementation of inline methods defined in ArithmeticalDSS.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------

template <typename TC, typename TI, unsigned short adj>
inline
DGtal::ArithmeticalDSS<TC, TI, adj>
::ArithmeticalDSS(const Coordinate& aA, const Coordinate& aB, 
		  const Integer& aMu, const Integer& aOmega, 
		  const Point& aF, const Point& aL,
		  const Point& aUf, const Point& aUl,
		  const Point& aLf, const Point& aLl)
  :
  myF(aF), myL(aL),
  myUf(aUf), myUl(aUl), myLf(aLf), myLl(aLl),
  mySteps( DGtal::ArithmeticalDSSKernel<TC,adj>::steps(aA, aB) ), 
  myShift( DGtal::ArithmeticalDSSKernel<TC,adj>::shift(aA, aB) ),
  myA(aA), myB(aB), myMu(aMu), myOmega(aOmega)
{
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
DGtal::ArithmeticalDSS<TC, TI, adj>
::ArithmeticalDSS(const Coordinate& aA, const Coordinate& aB, 
		  const Point& aF, const Point& aL,
		  const Point& aUf, const Point& aUl,
		  const Point& aLf, const Point& aLl)
  :
  myF(aF), myL(aL),
  myUf(aUf), myUl(aUl), myLf(aLf), myLl(aLl),
  mySteps( DGtal::ArithmeticalDSSKernel<TC,adj>::steps(aA, aB) ), 
  myShift( DGtal::ArithmeticalDSSKernel<TC,adj>::shift(aA, aB) ),
  myA(aA), myB(aB), myMu( remainder( aUf ) ), 
  myOmega( remainder( myShift ) )
{
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
DGtal::ArithmeticalDSS<TC, TI, adj>
::ArithmeticalDSS(const Point& aF, const Point& aL)
{
  //first and last points
  myF = aF; 
  myL = aL; 

  if (myF == myL)
    {
      //leaning points 
      myUf = myF; 
      myUl = myL; 
      myLf = myF; 
      myLl = myL; 

      //(a, b, mu, omega) parameters
      myA = 0; 
      myB = 0; 
      myMu = remainder( myUf ); 
      myOmega = 0; 
    }
  else 
    {

      //upper leaning points 
      myUf = myF; 
      myUl = myL; 

      //irreductible direction vector
      Vector u2 = aL - aF; 
      IntegerComputer<Coordinate> computer; 
      Coordinate gcd = computer.gcd(u2[0], u2[1]); 
      Vector u = Vector(u2[0]/gcd, u2[1]/gcd);

      //shift
      myShift = DGtal::ArithmeticalDSSKernel<TC,adj>::shift(u[1], u[0]); 

      //steps
      mySteps = DGtal::ArithmeticalDSSKernel<TC,adj>::steps(u[1], u[0]); 

      //(a, b, mu, omega) parameters
      myA = u[1]; 
      myB = u[0]; 
      myMu = remainder( myUf ); 
      myOmega = remainder( myShift ); 

      if (mySteps.second == Vector(0,0))
	{ //specific case

	  //lower leaning points
	  myLf = myF; 
	  myLl = myL; 

	}
      else 
	{ //general case
	  //Bezout
	  Vector v = computer.extendedEuclid(-u[1], u[0], 1); 

	  //lower leaning points
	  myLf = myF + v + myShift; 
	  myLl = myF + (gcd-1)*u + v + myShift; 
	}
    }
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
DGtal::ArithmeticalDSS<TC, TI, adj>
::ArithmeticalDSS(const ArithmeticalDSS<TC, TI, adj>& aOther)
  : 
  myF(aOther.myF), myL(aOther.myL),
  myUf(aOther.myUf), myUl(aOther.myUl), myLf(aOther.myLf), myLl(aOther.myLl),
  mySteps(aOther.mySteps), myShift(aOther.myShift),
  myA(aOther.myA), myB(aOther.myB), myMu(aOther.myMu), myOmega(aOther.myOmega)
{}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
DGtal::ArithmeticalDSS<TC, TI, adj>&
DGtal::ArithmeticalDSS<TC, TI, adj>
::operator=(const ArithmeticalDSS<TC, TI, adj>& aOther)
{
  if ( this != &aOther )
    {
      myA = aOther.myA;
      myB = aOther.myB;
      myMu = aOther.myMu;
      myOmega = aOther.myOmega;
      myF = aOther.myF;
      myL = aOther.myL;
      myUf = aOther.myUf;
      myLf = aOther.myLf;
      myUl = aOther.myUl;
      myLl = aOther.myLl;
      mySteps = aOther.mySteps; 
      myShift = aOther.myShift; 
    }
  return *this;
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
bool
DGtal::ArithmeticalDSS<TC, TI, adj>
::operator==(const ArithmeticalDSS<TC, TI, adj>& aOther)
{
  return ( ( (myOmega == aOther.myOmega) &&
	     (myUf == aOther.myUf) && 
	     (myUl == aOther.myUl) &&  
	     (myLf == aOther.myLf) &&  
	     (myLl == aOther.myLl) && 
	     (myF == aOther.myF) &&  
	     (myL == aOther.myL) ) || 
	   ( (myOmega == aOther.myOmega) &&
	     (myUf == aOther.myLl) && 
	     (myUl == aOther.myLf) &&  
	     (myLf == aOther.myUl) &&  
	     (myLl == aOther.myUf) && 
	     (myF == aOther.myL) &&  
	     (myL == aOther.myF) ) );
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
bool
DGtal::ArithmeticalDSS<TC, TI, adj>
::operator!=(const ArithmeticalDSS<TC, TI, adj>& aOther)
{
  return !( (*this) == aOther ); 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
DGtal::ArithmeticalDSS<TC, TI, adj>::~ArithmeticalDSS()
{
}

///////////////////////////////////////////////////////////////////////////////
// Interface - public :


//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
bool
DGtal::ArithmeticalDSS<TC, TI, adj>::isValid() const
{

  if (myF == myL) { 

    //special case with one point
    if ( (myA==0)
  	 &&(myB==0)
  	 &&(myMu==0)
  	 &&(myOmega==0)
  	 &&(myUf==myF)
  	 &&(myLf==myF)
  	 &&(myUl==myL)
  	 &&(myLl==myL)
	 &&(myShift==Vector(0,0))
	 &&(mySteps.first==Vector(0,0))
	 &&(mySteps.second==Vector(0,0)) ) 
      return true;
    else return false; 

  } else {

    //general case
    Integer gcd = IntegerComputer<Integer>::staticGcd(myA, myB); 
    if (gcd != NumberTraits<Integer>::ONE) 
      return false; //a,b should be relatively prime
    else
      {
	//remainders of leaning points
	if (remainder(myUf) != myMu) return false;
	else if (remainder(myUl) != myMu) return false;
	else if (remainder(myLf) != myMu+myOmega-1) return false;
	else if (remainder(myLl) != myMu+myOmega-1) return false;
	else 
	  {
	    //number of patterns
	    Vector vu = myUl - myUf; 
	    Coordinate gcdu = IntegerComputer<Coordinate>::staticGcd(vu[0], vu[1]); 
	    if ( (myB*static_cast<Integer>(gcdu) != static_cast<Coordinate>(vu[0]))
		 || (myA*static_cast<Integer>(gcdu) != static_cast<Coordinate>(vu[1])) )
	      return false;  
	    Vector vl = myLl - myLf; 
	    Coordinate gcdl = IntegerComputer<Coordinate>::staticGcd(vl[0], vl[1]); 
	    if ( (myB*static_cast<Integer>(gcdl) != static_cast<Coordinate>(vl[0]))
		 || (myA*static_cast<Integer>(gcdl) != static_cast<Coordinate>(vl[1])) )
	      return false; 
	    //steps and shift
	    if (mySteps != DGtal::ArithmeticalDSSKernel<TC,adj>::steps(myA, myB))
	      return false; 
	    if (myShift != DGtal::ArithmeticalDSSKernel<TC,adj>::shift(myA, myB))
	      return false; 
	    if ( (mySteps.second != Vector(0,0) )
		 &&( (mySteps.first - mySteps.second) != myShift ) )
	      return false; 

	    return true;
	  }
      }
  }
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::Coordinate
DGtal::ArithmeticalDSS<TC, TI, adj>::a() const
{
  return myA; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::Coordinate
DGtal::ArithmeticalDSS<TC, TI, adj>::b() const
{
  return myB; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::Integer
DGtal::ArithmeticalDSS<TC, TI, adj>::mu() const
{
  return myMu; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::Integer
DGtal::ArithmeticalDSS<TC, TI, adj>::omega() const
{
  return myOmega; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::Point
DGtal::ArithmeticalDSS<TC, TI, adj>::back() const
{
  return myF; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::Point
DGtal::ArithmeticalDSS<TC, TI, adj>::front() const
{
  return myL; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::Point
DGtal::ArithmeticalDSS<TC, TI, adj>::Uf() const
{
  return myUf; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::Point
DGtal::ArithmeticalDSS<TC, TI, adj>::Ul() const
{
  return myUl; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::Point
DGtal::ArithmeticalDSS<TC, TI, adj>::Lf() const
{
  return myLf; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::Point
DGtal::ArithmeticalDSS<TC, TI, adj>::Ll() const
{
  return myLl; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::Vector
DGtal::ArithmeticalDSS<TC, TI, adj>::shift() const
{
  return myShift; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::Steps
DGtal::ArithmeticalDSS<TC, TI, adj>::steps() const
{
  return mySteps; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::Integer
DGtal::ArithmeticalDSS<TC, TI, adj>::remainder(const Point& aPoint) const
{
  return myA * static_cast<Integer>(aPoint[0])
    - myB * static_cast<Integer>(aPoint[1]);
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::Integer
DGtal::ArithmeticalDSS<TC, TI, adj>::orthogonalPosition(const Point& aPoint) const
{
  return myB * static_cast<Integer>(aPoint[0])
    + myA * static_cast<Integer>(aPoint[1]);
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
bool
DGtal::ArithmeticalDSS<TC, TI, adj>::isInDSL(const Point& aPoint) const
{
  Integer r = remainder(aPoint);
  return ( (r >= myMu)&&(r < myMu+myOmega) );
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
bool
DGtal::ArithmeticalDSS<TC, TI, adj>::isInDSS(const Point& aPoint) const
{
  if (isInDSL(aPoint))
    {
      Integer s = orthogonalPosition(aPoint);
      Integer s1 = orthogonalPosition(myF);
      Integer s2 = orthogonalPosition(myL);
      if (s1 < s2)
	return ( (s >= s1)&&(s <= s2) );
      else 
	return ( (s >= s2)&&(s <= s1) );
    }
  else 
    return false; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
bool
DGtal::ArithmeticalDSS<TC, TI, adj>::operator()(const Point& aPoint) const
{
  return isInDSS(aPoint); 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator
DGtal::ArithmeticalDSS<TC, TI, adj>::begin() const
{
  return ConstIterator(this, myF);
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator
DGtal::ArithmeticalDSS<TC, TI, adj>::end() const
{
  ConstIterator it(this, myL); 
  it++; 
  return it;
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::ConstReverseIterator
DGtal::ArithmeticalDSS<TC, TI, adj>::rbegin() const
{
  return ConstReverseIterator( end() );
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::ConstReverseIterator
DGtal::ArithmeticalDSS<TC, TI, adj>::rend() const
{
  return ConstReverseIterator( begin() );
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
void
DGtal::ArithmeticalDSS<TC, TI, adj>::selfDisplay ( std::ostream & out ) const
{
  out << "[ArithmeticalDSS] ";
  out << "(" << myA << "," << myB << "," << myMu << "," << myOmega << ")" << std::endl; 
  out << "from " << myF << " to " << myL << std::endl; 
  out << "by steps " << mySteps.first << " " << mySteps.second << std::endl; 
  out << "upper leaning points: " << myUf << " " << myUl << std::endl;  
  out << "lower leaning points: " << myLf << " " << myLl; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
void
DGtal::ArithmeticalDSS<TC, TI, adj>::setSlope(const Coordinate& aA, const Coordinate& aB) 
{
  myA = aA; 
  myB = aB; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
void
DGtal::ArithmeticalDSS<TC, TI, adj>::setMuOmega(const Integer& aMu, const Integer& aOmega) 
{
  myMu = aMu; 
  myOmega = aOmega; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
unsigned short int
DGtal::ArithmeticalDSS<TC, TI, adj>::
isExtendable( const Point& aNewPoint,
	      const Vector& aStep, 
	      const Point& aEndPoint ) const
{
  std::cerr << "steps: " << aStep << std::endl; 

  //if the two last points are confounded OK
  if (aStep == Vector(0,0)) 
    return 9; 

  //if the first step does not exist yet OK
  else if (mySteps.first == Vector(0,0)) 
    return 1; 

  //if the two last points are not connected KO 
  else if (remainder(aStep) > myOmega) 
    return 0;

  //if the first step exists and
  //if the second step does not exist
  else if (mySteps.second == Vector(0,0))
    {
      //if the first step exists and is repeated OK
      if (aStep == mySteps.first) 
  	return 2; 
      else 
  	{
  	  //if the two steps are compatible
	  Integer q = remainder(mySteps.first - (aNewPoint-aEndPoint));
	  //if weakly exterior on the left OK
	  if (q == myOmega) 
	    return 3; 
	  //if weakly exterior on the right OK
	  else if (-q == myOmega) 
	    return 4;
	  //otherwise KO
  	  else
	    return 0; 
  	}
    }
  //if the two steps are initialized 
  else 
    {
      //if there are less than two steps
      if (isOneOfTheTwoSteps(aStep)) 
  	{
      	Integer r = remainder(aNewPoint);

	std::cerr << aNewPoint << " : " << r 
		  << " ["<< myMu << ";" << myMu+myOmega << "]" 
		  << std::endl; 

  	//if strongly exterior KO
  	if ( (r < myMu-1)||(r > myMu+myOmega) )
  	  return 0;
  	//otherwise OK
  	else 
  	  { 
  	    if (r == myMu)
  	      return 5; 
  	    else if (r == myMu+myOmega-1)
  	      return 6;
  	    else if (r == myMu-1)
  	      return 7;
  	    else if (r == myMu+myOmega)
  	      return 8;
  	    else 
  	      return 9; 
  	  }

  	} 
      //if there are more than two steps KO
      else  
  	return 0;
  }
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
bool
DGtal::ArithmeticalDSS<TC, TI, adj>::
extend( const Point& aNewPoint, const Vector& aStep, 
	Point& aEndPoint, 
	Point& aFirstLeft,  Point& aLastLeft,
	Point& aFirstRight,  Point& aLastRight )
{
  bool flag = true;
 
  unsigned int res = isExtendable(aNewPoint, aStep, aEndPoint); 
  switch (res)
    {
    case 1: //first step init
      aEndPoint = aNewPoint; 
      aLastLeft = aEndPoint; 
      aLastRight = aEndPoint;
      setSlope( aStep[1], aStep[0] ); 
      mySteps.first = aStep; 
      myShift = DGtal::ArithmeticalDSSKernel<TC,adj>::shift(myA, myB); 
      setMuOmega( remainder(myUl), remainder(myShift) );
      break; 
    case 2: //first step repeated
      aEndPoint = aNewPoint; 
      aLastLeft = aEndPoint; 
      aLastRight = aEndPoint;
      break; 
    case 3: //second step init on the left
      setSlope( myUl[1]-myUf[1]+aStep[1], myUl[0]-myUf[0]+aStep[0] );  
      aEndPoint = aNewPoint; 
      aLastLeft = aEndPoint; 
      aFirstRight = aLastRight;
      mySteps = DGtal::ArithmeticalDSSKernel<TC,adj>::steps(myA, myB);
      myShift = mySteps.first-mySteps.second; 
      setMuOmega( remainder(myUl), remainder(myShift) );
      break; 
    case 4: //second step init on the right
      setSlope( myLl[1]-myLf[1]+aStep[1], myLl[0]-myLf[0]+aStep[0] );  
      aEndPoint = aNewPoint; 
      aLastRight = aEndPoint; 
      aFirstLeft = aLastLeft;
      mySteps = DGtal::ArithmeticalDSSKernel<TC,adj>::steps(myA, myB);
      myShift = mySteps.first-mySteps.second; 
      setMuOmega( remainder(myUl), remainder(myShift) );
      break; 
    case 5: //weakly interior on the left
      aEndPoint = aNewPoint; 
      aLastLeft = aEndPoint; 
      break; 
    case 6: //weakly interior on the right
      aEndPoint = aNewPoint; 
      aLastRight = aEndPoint; 
      break; 
    case 7: //weakly exterior on the left
      aEndPoint = aNewPoint; 
      aLastLeft = aEndPoint; 
      aFirstRight = aLastRight;
      setSlope( (myUl[1] - myUf[1]), (myUl[0] - myUf[0]) ); 
      setMuOmega( remainder(myUl), remainder(myShift) );
      break; 
    case 8: //weakly exterior on the right
      aEndPoint = aNewPoint; 
      aLastRight = aEndPoint; 
      aFirstLeft = aLastLeft;
      setSlope( (myLl[1] - myLf[1]), (myLl[0] - myLf[0]) ); 
      setMuOmega( remainder(myUl), remainder(myShift) );
      break; 
    case 9: //strongly interior
      aEndPoint = aNewPoint; 
      break; 
    default: 
      flag = false; 
    }

  return flag; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
bool
DGtal::ArithmeticalDSS<TC, TI, adj>::
extendForward( const Point& aNewPoint )
{
  return extend( aNewPoint, (aNewPoint - myL), myL, 
		 myUf, myUl, myLf, myLl ); 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
bool
DGtal::ArithmeticalDSS<TC, TI, adj>::
extendBackward( const Point& aNewPoint )
{
  return extend( aNewPoint, (myF - aNewPoint), myF, 
		 myUl, myUf, myLl, myLf ); 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
bool
DGtal::ArithmeticalDSS<TC, TI, adj>::
updateLeaningPoints( const Vector& aDirection, 
		     const Point& aFirst, 
		     const Point& aLast, 
		     const Point& aBezout, 
		     const Point& aFirstAtOppositeSide, 
		     Point& aLastAtOppositeSide, 
		     Point& aFirstAtRemovalSide,
		     const Point& aLastAtRemovalSide)
{
  if (aFirstAtOppositeSide == aLastAtOppositeSide)
    {
      Vector newDirection = aFirstAtOppositeSide - aBezout; 
      Coordinate k; //number of repetition of newDirection
      
      Vector toLastAtRemovalSide = aLastAtRemovalSide - aFirst; 
      k = DGtal::ArithmeticalDSSKernel<TC,adj>::norm(toLastAtRemovalSide[1], toLastAtRemovalSide[0])
	/ DGtal::ArithmeticalDSSKernel<TC,adj>::norm(newDirection[1], newDirection[0]); 
      aFirstAtRemovalSide = aLastAtRemovalSide - newDirection*k; 

      Vector toLast = aLast - aFirstAtOppositeSide; 
      k = DGtal::ArithmeticalDSSKernel<TC,adj>::norm(toLast[1], toLast[0])
	/ DGtal::ArithmeticalDSSKernel<TC,adj>::norm(newDirection[1], newDirection[0]);
      aLastAtOppositeSide = aFirstAtOppositeSide + newDirection*k; 
      return true; 
    }
  else 
    {
      aFirstAtRemovalSide += aDirection; 
      return false; 
    }
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
template <typename TIterator>
inline
bool
DGtal::ArithmeticalDSS<TC, TI, adj>::
retract( Point& aFirst, 
	 TIterator aIt,
	 const Point& aLast, 
	 Point& aBezout, 
	 Point& aLeaningPoint, 
	 Point& aFirstUpper, 
	 Point& aLastUpper, 
	 Point& aFirstLower,
	 Point& aLastLower)
{
  //next point computation
  ++aIt; 
  Point next = *aIt; 
  //if the next point is the last one
  if (next == aLast)
    {
      aFirst = next; 
      aFirstUpper = next; 
      aFirstLower = next; 
      ASSERT( aLastUpper == next ); 
      ASSERT( aLastLower == next ); 
      setSlope(0,0); 
      setMuOmega(0,0);
      ASSERT( mySteps.second == Vector(0,0) ); 
      mySteps.first = Vector(0,0); 
      myShift = Vector(0,0); 
      return false; 
    }
  //otherwise
  else
    {
      bool res = false; 
      //update of the leaning points
      if (aFirst == aFirstUpper)
	{
	  aBezout = aFirstUpper + myShift; 
	  aLeaningPoint = aFirstLower; 
	  res = updateLeaningPoints( Vector(myB, myA), 
				     next, aLast, 
				     aBezout, 
				     aFirstLower, aLastLower, 
				     aFirstUpper, aLastUpper );
	}
      if (aFirst == aFirstLower) 
	{
	  aBezout = aFirstLower - myShift; 
	  aLeaningPoint = aFirstUpper; 
	  res = updateLeaningPoints( Vector(myB, myA),
				     next, aLast, 
				     aBezout, 
				     aFirstUpper, aLastUpper, 
				     aFirstLower, aLastLower ); 
	}
      //update of the first point
      aFirst = next; 

      return res; 

    }
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
void
DGtal::ArithmeticalDSS<TC, TI, adj>::
updateParameters( const Vector& aNewDirection )
{
  //update of the slope
  setSlope( aNewDirection[1], aNewDirection[0] ); 
  //update of the steps and shift
  if (myUf == myLf) 
    {
      ASSERT( myUl == myLl );
      mySteps = DGtal::ArithmeticalDSSKernel<TC,adj>::steps(myA, myB); 
      myShift = DGtal::ArithmeticalDSSKernel<TC,adj>::shift(myA, myB); 
    }
  //update of mu and omega
  setMuOmega( remainder(myUf), remainder(myShift) ); 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
bool
DGtal::ArithmeticalDSS<TC, TI, adj>::
retractForward()
{
  if (myF == myL)
    return false; 
  else 
    {

      Point bezout, leaningPoint; 
      if ( retract (myF, begin(), myL, 
		    bezout, leaningPoint, 
		    myUf, myUl, myLf, myLl ) )
	updateParameters( leaningPoint - bezout ); 
     
      return true; 
    }
} 

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
bool
DGtal::ArithmeticalDSS<TC, TI, adj>::
retractBackward()
{
  if (myF == myL)
    return false; 
  else 
    {

      Point bezout, leaningPoint; 
      if ( retract (myL, rbegin(), myF, 
		    bezout, leaningPoint, 
		    myUl, myUf, myLl, myLf ) )
	updateParameters( bezout - leaningPoint ); 

      return true; 
    }
} 

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
bool
DGtal::ArithmeticalDSS<TC, TI, adj>::
isOneOfTheTwoSteps(const Vector& aStep) const
{
  ASSERT( mySteps.first != Vector(0,0) ); 
  ASSERT( mySteps.second != Vector(0,0) ); 
  return ( (aStep == mySteps.first) || (aStep == mySteps.second ) ); 
}

///////////////////////////////////////////////////////////////////////////////
//                     Drawing services                                      //
///////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::PointD
DGtal::ArithmeticalDSS<TC, TI, adj>::
project( const Point& aM, double aR ) const
{
  //casts
  double aa = (double) NumberTraits<Coordinate>::castToInt64_t(myA);
  double bb = (double) NumberTraits<Coordinate>::castToInt64_t(myB);
  double xm = (double) NumberTraits<Integer>::castToInt64_t(aM[0]);
  double ym = (double) NumberTraits<Integer>::castToInt64_t(aM[1]);

  //computation
  double d2 = ( aa * aa + bb * bb );
  double s = bb * xm + aa * ym;
  double xp = ( bb * s + aa * aR ) / d2;
  double yp = ( aa * s - bb * aR ) / d2;
  
  return PointD( xp, yp );
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::PointD
DGtal::ArithmeticalDSS<TC, TI, adj>::
project( const Point& aM, const Point& aP ) const
{
  double r = (double) NumberTraits<Integer>::castToInt64_t(remainder(aP));
  return project(aM,r);
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
std::string
DGtal::ArithmeticalDSS<TC, TI, adj>::
className() const
{
  return "ArithmeticalDSS";
}
///////////////////////////////////////////////////////////////////////////////
//                   Iterators services                                      //
///////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator::ConstIterator()
  : myDSSPtr(0), myCurrentPoint()
{
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator
::ConstIterator( const ArithmeticalDSS* aDSS, const Point& aPoint )
  : myDSSPtr(aDSS), myCurrentPoint(aPoint)
{
  myQuantityToAdd = myDSSPtr->remainder(myDSSPtr->mySteps.first);
  myQuantityToRemove = myQuantityToAdd - myDSSPtr->remainder(myDSSPtr->mySteps.second); 
  myLowerBound = myDSSPtr->mu();
  myUpperBound = myDSSPtr->mu() + myDSSPtr->omega();
  myCurrentRemainder = myDSSPtr->remainder( myCurrentPoint ); 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator::
ConstIterator( const ConstIterator & aOther )
  : myDSSPtr( aOther.myDSSPtr ), myCurrentPoint( aOther.myCurrentPoint ),
    myQuantityToAdd( aOther.myQuantityToAdd ), 
    myQuantityToRemove( aOther.myQuantityToRemove ), 
    myUpperBound( aOther.myUpperBound ), 
    myLowerBound( aOther.myLowerBound ), 
    myCurrentRemainder( aOther.myCurrentRemainder ) 
{ } 


//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator& 
DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator::
operator= ( const ConstIterator & aOther ) 
{
  if (this != &aOther)
    {
      myDSSPtr = aOther.myDSSPtr; 
      myCurrentPoint = aOther.myCurrentPoint; 
      myQuantityToAdd = aOther.myQuantityToAdd; 
      myQuantityToRemove = aOther.myQuantityToRemove; 
      myUpperBound = aOther.myUpperBound; 
      myLowerBound = aOther.myLowerBound; 
      myCurrentRemainder = aOther.myCurrentRemainder; 
    }
  return *this; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator::~ConstIterator()
{
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::Point 
DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator::
operator*() const
{
  return myCurrentPoint;
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
void
DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator::
next()
{
  myCurrentRemainder += myQuantityToAdd; 
  if ( myCurrentRemainder < myUpperBound )
    {
      myCurrentPoint += myDSSPtr->mySteps.first; 
    }
  else
    {
      myCurrentRemainder -= myQuantityToRemove; 
      myCurrentPoint += myDSSPtr->mySteps.second; 
    }
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator&
DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator::
operator++()
{
  this->next(); 
  return *this;
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator
DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator::
operator++(int)
{
  ConstIterator tmp(*this);
  this->next();
  return tmp;
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
void
DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator::
previous()
{
  myCurrentRemainder -= myQuantityToAdd; 
  if ( myCurrentRemainder >= myLowerBound )
    {
      myCurrentPoint -= myDSSPtr->mySteps.first; 
    }
  else
    {
      myCurrentRemainder += myQuantityToRemove; 
      myCurrentPoint -= myDSSPtr->mySteps.second; 
    }
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator&
DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator::
operator--()
{
  this->previous();
  return *this;
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator
DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator::
operator--(int)
{
  ConstIterator tmp(*this);
  this->previous();
  return tmp;
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
bool
DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator::
operator==(const ConstIterator& aOther) const
{
  ASSERT( myDSSPtr == aOther.myDSSPtr );
  return myCurrentPoint == aOther.myCurrentPoint;
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
bool
DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator::
operator!=(const ConstIterator& aOther) const
{
  ASSERT( myDSSPtr == aOther.myDSSPtr );
  return myCurrentPoint != aOther.myCurrentPoint;
}

///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions                                        //

template <typename TC, typename TI, unsigned short adj>
inline
std::ostream&
DGtal::operator<< ( std::ostream & out, 
		    const ArithmeticalDSS<TC, TI, adj> & object )
{
  object.selfDisplay( out );
  return out;
}

//                                                                           //
///////////////////////////////////////////////////////////////////////////////


