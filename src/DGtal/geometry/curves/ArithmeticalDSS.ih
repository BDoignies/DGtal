/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file ArithmeticalDSS.ih
 * @author Tristan Roussillon (\c tristan.roussillon@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Syst√®mes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 *
 * @date 2013/06/28
 *
 * Implementation of inline methods defined in ArithmeticalDSS.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------

template <typename TC, typename TI, unsigned short adj>
inline
DGtal::ArithmeticalDSS<TC, TI, adj>
::ArithmeticalDSS(const Coordinate& aA, const Coordinate& aB, 
		  const Integer& aMu, const Integer& aOmega, 
		  const Point& aF, const Point& aL,
		  const Point& aUf, const Point& aUl,
		  const Point& aLf, const Point& aLl)
  :
  myF(aF), myL(aL),
  myUf(aUf), myUl(aUl), myLf(aLf), myLl(aLl),
  mySteps( DGtal::ArithmeticalDSSKernel<TC,adj>::steps(aA, aB) ), 
  myShift( DGtal::ArithmeticalDSSKernel<TC,adj>::shift(aA, aB) ),
  myA(aA), myB(aB), myMu(aMu), myOmega(aOmega)
{
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
DGtal::ArithmeticalDSS<TC, TI, adj>
::ArithmeticalDSS(const Coordinate& aA, const Coordinate& aB, 
		  const Point& aF, const Point& aL,
		  const Point& aUf, const Point& aUl,
		  const Point& aLf, const Point& aLl)
  :
  myF(aF), myL(aL),
  myUf(aUf), myUl(aUl), myLf(aLf), myLl(aLl),
  mySteps( DGtal::ArithmeticalDSSKernel<TC,adj>::steps(aA, aB) ), 
  myShift( DGtal::ArithmeticalDSSKernel<TC,adj>::shift(aA, aB) ),
  myA(aA), myB(aB), myMu( remainder( aUf ) ), 
  myOmega( remainder( myShift ) )
{
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
DGtal::ArithmeticalDSS<TC, TI, adj>
::ArithmeticalDSS(const Point& aF, const Point& aL, 
		  const bool& isOnTheUpperLine)
{
  //first and last points
  myF = aF; 
  myL = aL; 

  if (myF == myL)
    {
      //leaning points 
      myUf = myF; 
      myUl = myL; 
      myLf = myF; 
      myLl = myL; 

      //(a, b, mu, omega) parameters
      setSlope(0, 0); 
      setMuOmega(remainder( myUf ), 0); 
    }
  else 
    {
      if (isOnTheUpperLine)
	{
	  //upper leaning points 
	  myUf = myF; 
	  myUl = myL; 
	  //other leaning points and other parameters
	  setPattern(myUf, myUl, myLf, myLl, -1);
	  setMuOmega(remainder( myUf ), remainder( myShift )); 
	}
      else 
	{	
	  //lower leaning points 
	  myLf = myF; 
	  myLl = myL; 
	  //other leaning points and other parameters
	  setPattern(myLf, myLl, myUf, myUl, 1);
	  setMuOmega(remainder( myUf ), remainder( myShift )); 
	}
    }
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
template <typename Iterator>
inline
DGtal::ArithmeticalDSS<TC, TI, adj>
::ArithmeticalDSS(const Iterator& aItb, const Iterator& aIte)  throw( InputException )
{
  if (aItb != aIte)
    {
      Iterator it = aItb; 
      //construction from the begin iterator
      Point p = *it; 
      ArithmeticalDSS(p, p); 
      //extension
      for (++it; it != aIte; ++it)
	  extendForward(*it); 
    }
  else
    {
      throw InputException();
    }
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
DGtal::ArithmeticalDSS<TC, TI, adj>
::ArithmeticalDSS(const ArithmeticalDSS<TC, TI, adj>& aOther)
  : 
  myF(aOther.myF), myL(aOther.myL),
  myUf(aOther.myUf), myUl(aOther.myUl), myLf(aOther.myLf), myLl(aOther.myLl),
  mySteps(aOther.mySteps), myShift(aOther.myShift),
  myA(aOther.myA), myB(aOther.myB), myMu(aOther.myMu), myOmega(aOther.myOmega)
{}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
DGtal::ArithmeticalDSS<TC, TI, adj>&
DGtal::ArithmeticalDSS<TC, TI, adj>
::operator=(const ArithmeticalDSS<TC, TI, adj>& aOther)
{
  if ( this != &aOther )
    {
      myA = aOther.myA;
      myB = aOther.myB;
      myMu = aOther.myMu;
      myOmega = aOther.myOmega;
      myF = aOther.myF;
      myL = aOther.myL;
      myUf = aOther.myUf;
      myLf = aOther.myLf;
      myUl = aOther.myUl;
      myLl = aOther.myLl;
      mySteps = aOther.mySteps; 
      myShift = aOther.myShift; 
    }
  return *this;
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
DGtal::ArithmeticalDSS<TC, TI, adj>
DGtal::ArithmeticalDSS<TC, TI, adj>
::negate() const
{
  if ( (myA == 0)&&(myB == 0) )
    return DGtal::ArithmeticalDSS<TC, TI, adj>(0, 0, 0, 0, myL, myF, myLl, myLf, myUl, myUf);      
  else 
    return DGtal::ArithmeticalDSS<TC, TI, adj>(-myA, -myB, -(myMu+myOmega-1), myOmega, 
					       myL, myF, myLl, myLf, myUl, myUf);  
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
bool
DGtal::ArithmeticalDSS<TC, TI, adj>
::equalsTo(const ArithmeticalDSS<TC, TI, adj>& aOther) const
{
  return ( (myOmega == aOther.myOmega) &&
	   (myUf == aOther.myUf) && 
	   (myUl == aOther.myUl) &&  
	   (myLf == aOther.myLf) &&  
	   (myLl == aOther.myLl) && 
	   (myF == aOther.myF) &&  
	   (myL == aOther.myL) );
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
bool
DGtal::ArithmeticalDSS<TC, TI, adj>
::operator==(const ArithmeticalDSS<TC, TI, adj>& aOther) const
{
  return ( equalsTo(aOther) || equalsTo(aOther.negate()) ); 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
bool
DGtal::ArithmeticalDSS<TC, TI, adj>
::operator!=(const ArithmeticalDSS<TC, TI, adj>& aOther) const
{
  return !( (*this) == aOther ); 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
DGtal::ArithmeticalDSS<TC, TI, adj>::~ArithmeticalDSS()
{
}

///////////////////////////////////////////////////////////////////////////////
// Interface - public :

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
bool
DGtal::ArithmeticalDSS<TC, TI, adj>::checkOnePoint() const
{
  return ( (myA==0)
	   &&(myB==0)
	   &&(myMu==0)
	   &&(myOmega==0)
	   &&(myUf==myF)
	   &&(myLf==myF)
	   &&(myUl==myL)
	   &&(myLl==myL)
	   &&(myShift==Vector(0,0))
	   &&(mySteps.first==Vector(0,0))
	   &&(mySteps.second==Vector(0,0)) ); 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
bool
DGtal::ArithmeticalDSS<TC, TI, adj>::checkLeaningPointsRemainder() const
{
  if (remainder(myUf) != myMu) return false;
  else if (remainder(myUl) != myMu) return false;
  else if (remainder(myLf) != myMu+myOmega-1) return false;
  else if (remainder(myLl) != myMu+myOmega-1) return false;
  else return true; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
bool
DGtal::ArithmeticalDSS<TC, TI, adj>::
checkLeaningPointsAndSlope(const Vector& fromFirstToLast) const
{
  Coordinate gcd = IntegerComputer<Coordinate>::
    staticGcd(fromFirstToLast[0], fromFirstToLast[1]);
 
  return ( ( (myB*gcd) == fromFirstToLast[0]) 
	   && ( (myA*gcd) == fromFirstToLast[1]) ); 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
bool
DGtal::ArithmeticalDSS<TC, TI, adj>::checkShiftAndSteps() const
{
  if (mySteps != DGtal::ArithmeticalDSSKernel<TC,adj>::steps(myA, myB))
    return false; 
  else if (myShift != DGtal::ArithmeticalDSSKernel<TC,adj>::shift(myA, myB))
    return false; 
  else if ( (mySteps.second != Vector(0,0) )
       &&( (mySteps.first - mySteps.second) != myShift ) )
    return false;
  else 
    return true; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
bool
DGtal::ArithmeticalDSS<TC, TI, adj>::isValid() const
{

  //special case with one point
  if (myF == myL)  
    return checkOnePoint(); 
  //otherwise  
  else {

    Integer gcd = IntegerComputer<Integer>::staticGcd(myA, myB); 
    if (gcd != NumberTraits<Integer>::ONE) 
      return false; //a,b should be relatively prime
    else
      {
	//remainders of leaning points
	if (!checkLeaningPointsRemainder())
	  return false; 
	else 
	  {
	    //number of patterns
	    if (!checkLeaningPointsAndSlope(myUl-myUf))
	      return false; 
	    else if (!checkLeaningPointsAndSlope(myLl-myLf))
	      return false;
	    //steps and shift
	    else if (!checkShiftAndSteps())
	      return false; 
	    else 
	      return true;
	  }
      }
  }
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::Coordinate
DGtal::ArithmeticalDSS<TC, TI, adj>::a() const
{
  return myA; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::Coordinate
DGtal::ArithmeticalDSS<TC, TI, adj>::b() const
{
  return myB; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::Integer
DGtal::ArithmeticalDSS<TC, TI, adj>::mu() const
{
  return myMu; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::Integer
DGtal::ArithmeticalDSS<TC, TI, adj>::omega() const
{
  return myOmega; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::Point
DGtal::ArithmeticalDSS<TC, TI, adj>::back() const
{
  return myF; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::Point
DGtal::ArithmeticalDSS<TC, TI, adj>::front() const
{
  return myL; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::Point
DGtal::ArithmeticalDSS<TC, TI, adj>::Uf() const
{
  return myUf; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::Point
DGtal::ArithmeticalDSS<TC, TI, adj>::Ul() const
{
  return myUl; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::Point
DGtal::ArithmeticalDSS<TC, TI, adj>::Lf() const
{
  return myLf; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::Point
DGtal::ArithmeticalDSS<TC, TI, adj>::Ll() const
{
  return myLl; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::Vector
DGtal::ArithmeticalDSS<TC, TI, adj>::shift() const
{
  return myShift; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::Steps
DGtal::ArithmeticalDSS<TC, TI, adj>::steps() const
{
  return mySteps; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::Integer
DGtal::ArithmeticalDSS<TC, TI, adj>::remainder(const Point& aPoint) const
{
  return myA * static_cast<Integer>(aPoint[0])
    - myB * static_cast<Integer>(aPoint[1]);
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::Integer
DGtal::ArithmeticalDSS<TC, TI, adj>::orthogonalPosition(const Point& aPoint) const
{
  return myB * static_cast<Integer>(aPoint[0])
    + myA * static_cast<Integer>(aPoint[1]);
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::Integer
DGtal::ArithmeticalDSS<TC, TI, adj>::directionalPosition(const Point& aPoint) const
{
  return ( -static_cast<Integer>(myShift[1]) * static_cast<Integer>(aPoint[0])
    +static_cast<Integer>(myShift[0]) * static_cast<Integer>(aPoint[1]) );
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
bool
DGtal::ArithmeticalDSS<TC, TI, adj>::isInDSL(const Point& aPoint) const
{
  Integer r = remainder(aPoint);
  return ( (r >= myMu)&&(r < myMu+myOmega) );
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
bool
DGtal::ArithmeticalDSS<TC, TI, adj>::isInDSS(const Point& aPoint) const
{
  if (isInDSL(aPoint))
    {
      Integer s = orthogonalPosition(aPoint);
      Integer s1 = orthogonalPosition(myF);
      Integer s2 = orthogonalPosition(myL);
      if (s1 < s2)
	return ( (s >= s1)&&(s <= s2) );
      else 
	return ( (s >= s2)&&(s <= s1) );
    }
  else 
    return false; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
bool
DGtal::ArithmeticalDSS<TC, TI, adj>::operator()(const Point& aPoint) const
{
  return isInDSS(aPoint); 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator
DGtal::ArithmeticalDSS<TC, TI, adj>::begin() const
{
  return ConstIterator(this, myF);
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator
DGtal::ArithmeticalDSS<TC, TI, adj>::end() const
{
  ConstIterator it(this, myL); 
  it++; 
  return it;
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::ConstReverseIterator
DGtal::ArithmeticalDSS<TC, TI, adj>::rbegin() const
{
  return ConstReverseIterator( end() );
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::ConstReverseIterator
DGtal::ArithmeticalDSS<TC, TI, adj>::rend() const
{
  return ConstReverseIterator( begin() );
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
void
DGtal::ArithmeticalDSS<TC, TI, adj>::selfDisplay ( std::ostream & out ) const
{
  out << "[ArithmeticalDSS] ";
  out << "(" << myA << "," << myB << "," << myMu << "," << myOmega << ")" << std::endl; 
  out << "from " << myF << " to " << myL << std::endl; 
  out << "by steps " << mySteps.first << " " << mySteps.second << std::endl; 
  out << "upper leaning points: " << myUf << " " << myUl << std::endl;  
  out << "lower leaning points: " << myLf << " " << myLl; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
unsigned short int
DGtal::ArithmeticalDSS<TC, TI, adj>::
isExtendableForward( const Point& aNewPoint ) const
{
  Vector step = aNewPoint - myL; 
  Coordinate deviation = DGtal::ArithmeticalDSSKernel<TC,adj>::norm(step[0], step[1]);
 
  //if the two last points are confounded OK
  if (deviation == NumberTraits<Coordinate>::ZERO) 
    return 9; 

  //if the two last points are not connected KO 
  else if (deviation > NumberTraits<Coordinate>::ONE) 
    return 0;

  //if the first step does not exist yet OK
  else if (mySteps.first == Vector(0,0)) 
    return 1; 

  //if the first step exists and
  //if the second step does not exist
  else if (mySteps.second == Vector(0,0))
    {
      //if the first step exists and is repeated OK
      if (step == mySteps.first) 
  	return 2; 
      else 
  	{
	  //if the two steps are compatible OK
	  Vector v = step - mySteps.first; 
	  if ( DGtal::ArithmeticalDSSKernel<TC,DGtal::ArithmeticalDSSKernel<TC,adj>::BackgroundAdjacency>
	       ::norm(v[0], v[1]) ==  NumberTraits<Coordinate>::ONE )
	    {
	      Integer r = remainder(aNewPoint);
	      //if weakly exterior on the left 
	      if (r == myMu-1)
		return 3;
	      //if weakly exterior on the right
	      else 
		{
		  ASSERT(r == myMu+myOmega); 
		  return 4;
		}
	    }
  	  else
	    return 0; 
  	}
    }
  //if the two steps are initialized 
  else 
    {
      //if there are less than two steps
      if (isOneOfTheTwoSteps(step)) 
  	{
      	Integer r = remainder(aNewPoint);

  	//if strongly exterior KO
  	if ( (r < myMu-1)||(r > myMu+myOmega) )
  	  return 0;
  	//otherwise OK
  	else 
  	  { 
  	    if (r == myMu)
  	      return 5; 
  	    else if (r == myMu+myOmega-1)
  	      return 6;
  	    else if (r == myMu-1)
  	      return 7;
  	    else if (r == myMu+myOmega)
  	      return 8;
  	    else 
  	      return 9; 
  	  }
  	} 
      //if there are more than two steps KO
      else  
  	return 0;
  }
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
unsigned short int
DGtal::ArithmeticalDSS<TC, TI, adj>::
isExtendableBackward( const Point& aNewPoint ) const
{
  return negate().isExtendableForward( aNewPoint ); 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
bool
DGtal::ArithmeticalDSS<TC, TI, adj>::
extendForward( const Point& aNewPoint )
{
  //true if the DSS can be extended to aNewPoint
  //false otherwise
  bool flag = true; 
 
  //code that tells how to update the DSS
  unsigned short int res = isExtendableForward(aNewPoint);

  switch (res)
    {
    case 1: //first step init
      //NB: becareful of the initialization sequence: 
      //setMuOmega() requires myShift to be initialized, 
      //which requires myA, myB to be initialized, 
      //which requires mySteps.first to be initialize. 
      mySteps.first = Vector( (aNewPoint[0] - myL[0]), (aNewPoint[1] - myL[1]) ); 
      setSlope( mySteps.first[1], mySteps.first[0] ); 
      myShift = DGtal::ArithmeticalDSSKernel<TC,adj>::shift(myA, myB); 
      setMuOmega( remainder(myUl), remainder(myShift) );
      myL = aNewPoint; 
      myUl = aNewPoint; 
      myLl = aNewPoint;
      break; 
    case 2: //first step repeated
      myL = aNewPoint; 
      myUl = aNewPoint; 
      myLl = aNewPoint;
      break; 
    case 3: //second step init on the left
      //NB: becareful of the initialization sequence: 
      //setMuOmega() => myShift => mySteps
      //             => leaning points => setSlope()
      setSlope( ((myUl[1] - myUf[1]) + (aNewPoint[1] - myL[1])), 
		((myUl[0] - myUf[0]) + (aNewPoint[0] - myL[0])) ); 
      myL = aNewPoint; 
      myUl = aNewPoint; 
      myLf = myLl; 
      mySteps = DGtal::ArithmeticalDSSKernel<TC,adj>::steps(myA, myB);
      myShift = mySteps.first-mySteps.second; 
      setMuOmega( remainder(myUl), remainder(myShift) );
      break; 
    case 4: //second step init on the right
      //NB: becareful of the initialization sequence: 
      //setMuOmega() => myShift => mySteps
      //             => leaning points => setSlope()
      setSlope( ((myLl[1] - myLf[1]) + (aNewPoint[1] - myL[1])), 
		((myLl[0] - myLf[0]) + (aNewPoint[0] - myL[0])) ); 
      myL = aNewPoint; 
      myLl = aNewPoint; 
      myUf = myUl; 
      mySteps = DGtal::ArithmeticalDSSKernel<TC,adj>::steps(myA, myB);
      myShift = mySteps.first-mySteps.second; 
      setMuOmega( remainder(myUl), remainder(myShift) );
      break; 
    case 5: //weakly interior on the left
      myL = aNewPoint; 
      myUl = aNewPoint; 
      break; 
    case 6: //weakly interior on the right
      myL = aNewPoint; 
      myLl = aNewPoint; 
      break; 
    case 7: //weakly exterior on the left
      myL = aNewPoint; 
      myUl = aNewPoint; 
      myLf = myLl; 
      setSlope( (myUl[1] - myUf[1]), (myUl[0] - myUf[0]) ); 
      setMuOmega( remainder(myUl), remainder(myShift) );
      break; 
    case 8: //weakly exterior on the right
      myL = aNewPoint; 
      myLl = aNewPoint; 
      myUf = myUl; 
      setSlope( (myLl[1] - myLf[1]), (myLl[0] - myLf[0]) ); 
      setMuOmega( remainder(myUl), remainder(myShift) );
      break; 
    case 9: //strongly interior
      myL = aNewPoint; 
      break; 
    default: 
      flag = false; 
    }

  return flag; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
bool
DGtal::ArithmeticalDSS<TC, TI, adj>::
extendBackward( const Point& aNewPoint )
{
  //call extendForward to the opposite
  DGtal::ArithmeticalDSS<TC, TI, adj> opposite = negate();
  bool flag = opposite.extendForward(aNewPoint);
 
  if (flag) //update '*this' if required
    *this = opposite.negate(); 

  return flag;  
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
bool
DGtal::ArithmeticalDSS<TC, TI, adj>::
retractForward()
{
  //call retractBackward to the opposite
  DGtal::ArithmeticalDSS<TC, TI, adj> opposite = negate();
  bool hasBeenRetracted = opposite.retractBackward();
 
  if (hasBeenRetracted) //update '*this' if required
    *this = opposite.negate(); 

  return hasBeenRetracted;  
} 

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
bool
DGtal::ArithmeticalDSS<TC, TI, adj>::
retractBackward()
{
  if (myF == myL)
    return false; 
  else 
    {

      //next point computation
      Point next = *++begin(); 
      //if the next point is the last one
      if (next == myL)
	{
	  myF = next; 
	  myUf = next; 
	  myLf = next; 
	  ASSERT( myUl == next ); 
	  ASSERT( myLl == next ); 
	  setSlope(0,0); 
	  setMuOmega(0,0);
	  ASSERT( mySteps.second == Vector(0,0) ); 
	  mySteps.first = Vector(0,0); 
	  myShift = Vector(0,0); 
	  return true; 
	}
      //otherwise
      else
	{
	  //points used to update the DSS
	  Point bezoutPoint, firstLeaningPoint; 
	  
	  //leaning points / parameters update
	  if (myF == myUf)
	    {
	      bezoutPoint = myUf + myShift; 
	      if ( updateLeaningPoints( Vector(myB, myA), 
					next, myL, 
					bezoutPoint, 
					myLf, myLl, 
					myUf, myUl ) )
		updateParameters( myLf - bezoutPoint ); 
	      
	    }
	  if (myF == myLf) 
	    {
	      bezoutPoint = myLf - myShift; 
	      if ( updateLeaningPoints( Vector(myB, myA),
					next, myL, 
					bezoutPoint, 
					myUf, myUl, 
					myLf, myLl ) )
		updateParameters( myUf - bezoutPoint ); 
	    }

	  //first point update
	  myF = next; 

	  return true; 
	}

    }
} 

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
bool
DGtal::ArithmeticalDSS<TC, TI, adj>::
isOneOfTheTwoSteps(const Vector& aStep) const
{
  ASSERT( mySteps.first != Vector(0,0) ); 
  ASSERT( mySteps.second != Vector(0,0) ); 
  return ( (aStep == mySteps.first) || (aStep == mySteps.second ) ); 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::Vector
DGtal::ArithmeticalDSS<TC, TI, adj>::
bezoutVector(const Coordinate& aA, 
	     const Coordinate& aB, 
	     const Coordinate& aR) const
{
  ASSERT( (aR == 1)||(aR == -1) ); 

  //compute the shortest Bezout vector
  IntegerComputer<Coordinate> computer; 
  Vector v = computer.extendedEuclid2(aA, -aB, aR ); 
  ASSERT( (aA*v[0]-aB*v[1]) == aR );
 
  //compute the one whose component
  //have a sign equal to the direction
  //vector components
  if ( (aB >= 0)&&(v[0] < 0) )
    v += Vector(aB,aA); 
  if ( (aB < 0)&&(v[0] >= 0) )
    v -= Vector(aB,aA); 
  if ( ( aA >= 0 )&&(v[1] < 0) )
    v += Vector(aB,aA);
  if ( ( aA < 0 )&&(v[1] >= 0) )
    v -= Vector(aB,aA);
  ASSERT( (aA*v[0]-aB*v[1]) == aR );

  return v; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
void
DGtal::ArithmeticalDSS<TC, TI, adj>::setSlope(const Coordinate& aA, const Coordinate& aB) 
{
  myA = aA; 
  myB = aB; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
void
DGtal::ArithmeticalDSS<TC, TI, adj>::setMuOmega(const Integer& aMu, const Integer& aOmega) 
{
  myMu = aMu; 
  myOmega = aOmega; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
void
DGtal::ArithmeticalDSS<TC, TI, adj>::setPattern(const Point& aFirstLeaningPoint, 
						const Point& aLastLeaningPoint,
						Point& aFirstOppositeLeaningPoint, 
						Point& aLastOppositeLeaningPoint, 
						const short& sign) 
{
  ASSERT( (sign == 1)||(sign == -1) ); 

  //irreductible direction vector
  Vector u2 = aLastLeaningPoint - aFirstLeaningPoint; 
  IntegerComputer<Coordinate> computer; 
  Coordinate gcd = computer.gcd(u2[0], u2[1]); 
  Vector u = Vector(u2[0]/gcd, u2[1]/gcd);

  //shift
  myShift = DGtal::ArithmeticalDSSKernel<TC,adj>::shift(u[1], u[0]); 

  //steps
  mySteps = DGtal::ArithmeticalDSSKernel<TC,adj>::steps(u[1], u[0]); 

  if (mySteps.second == Vector(0,0))
    { //specific case

      //lower leaning points
      aFirstOppositeLeaningPoint = aFirstLeaningPoint; 
      aLastOppositeLeaningPoint = aLastLeaningPoint; 

    }
  else 
    { //general case
      //Bezout
      Vector v = bezoutVector(u[1], u[0], sign); 
      //lower leaning points
      aFirstOppositeLeaningPoint = aFirstLeaningPoint + v - myShift*sign; 
      aLastOppositeLeaningPoint = aFirstLeaningPoint + u*(gcd-1) + v - myShift*sign; 
    }

  //(a, b, mu, omega) parameters
  setSlope(u[1], u[0]); 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
void
DGtal::ArithmeticalDSS<TC, TI, adj>::
updateParameters( const Vector& aNewDirection )
{
  //update of the slope
  setSlope( aNewDirection[1], aNewDirection[0] ); 
  //update of the steps and shift
  if (myUf == myLf) 
    {
      ASSERT( myUl == myLl );
      mySteps = DGtal::ArithmeticalDSSKernel<TC,adj>::steps(myA, myB); 
      myShift = DGtal::ArithmeticalDSSKernel<TC,adj>::shift(myA, myB); 
    }
  //update of mu and omega
  setMuOmega( remainder(myUf), remainder(myShift) ); 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
bool
DGtal::ArithmeticalDSS<TC, TI, adj>::
updateLeaningPoints( const Vector& aDirection, 
		     const Point& aFirst, 
		     const Point& aLast, 
		     const Point& aBezout, 
		     const Point& aFirstAtOppositeSide, 
		     Point& aLastAtOppositeSide, 
		     Point& aFirstAtRemovalSide,
		     const Point& aLastAtRemovalSide)
{
  if (aFirstAtOppositeSide == aLastAtOppositeSide)
    {
      Vector newDirection = aFirstAtOppositeSide - aBezout; 
      Coordinate k; //number of repetition of newDirection
      
      Vector toLastAtRemovalSide = aLastAtRemovalSide - aFirst; 
      k = DGtal::ArithmeticalDSSKernel<TC,adj>::norm(toLastAtRemovalSide[1], toLastAtRemovalSide[0])
	/ DGtal::ArithmeticalDSSKernel<TC,adj>::norm(newDirection[1], newDirection[0]); 
      aFirstAtRemovalSide = aLastAtRemovalSide - newDirection*k; 

      Vector toLast = aLast - aFirstAtOppositeSide; 
      k = DGtal::ArithmeticalDSSKernel<TC,adj>::norm(toLast[1], toLast[0])
	/ DGtal::ArithmeticalDSSKernel<TC,adj>::norm(newDirection[1], newDirection[0]);
      aLastAtOppositeSide = aFirstAtOppositeSide + newDirection*k; 
      return true; 
    }
  else 
    {
      aFirstAtRemovalSide += aDirection; 
      return false; 
    }
}

///////////////////////////////////////////////////////////////////////////////
//                     Drawing services                                      //
///////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::PointD
DGtal::ArithmeticalDSS<TC, TI, adj>::
project( const Point& aM, double aR ) const
{
  //casts
  double aa = (double) NumberTraits<Coordinate>::castToInt64_t(myA);
  double bb = (double) NumberTraits<Coordinate>::castToInt64_t(myB);
  double xm = (double) NumberTraits<Integer>::castToInt64_t(aM[0]);
  double ym = (double) NumberTraits<Integer>::castToInt64_t(aM[1]);

  //computation
  double d2 = ( aa * aa + bb * bb );
  double s = bb * xm + aa * ym;
  double xp = ( bb * s + aa * aR ) / d2;
  double yp = ( aa * s - bb * aR ) / d2;
  
  return PointD( xp, yp );
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::PointD
DGtal::ArithmeticalDSS<TC, TI, adj>::
project( const Point& aM, const Point& aP ) const
{
  double r = (double) NumberTraits<Integer>::castToInt64_t(remainder(aP));
  return project(aM,r);
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
std::string
DGtal::ArithmeticalDSS<TC, TI, adj>::
className() const
{
  return "ArithmeticalDSS";
}
///////////////////////////////////////////////////////////////////////////////
//                   Iterators services                                      //
///////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator::ConstIterator()
  : myDSSPtr(0), myCurrentPoint()
{
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator
::ConstIterator( const ArithmeticalDSS* aDSS, const Point& aPoint )
  : myDSSPtr(aDSS), myCurrentPoint(aPoint)
{
  myQuantityToAdd = myDSSPtr->remainder(myDSSPtr->mySteps.first);
  myQuantityToRemove = myQuantityToAdd - myDSSPtr->remainder(myDSSPtr->mySteps.second); 
  myLowerBound = myDSSPtr->mu();
  myUpperBound = myDSSPtr->mu() + myDSSPtr->omega();
  myCurrentRemainder = myDSSPtr->remainder( myCurrentPoint ); 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator::
ConstIterator( const ConstIterator & aOther )
  : myDSSPtr( aOther.myDSSPtr ), myCurrentPoint( aOther.myCurrentPoint ),
    myQuantityToAdd( aOther.myQuantityToAdd ), 
    myQuantityToRemove( aOther.myQuantityToRemove ), 
    myUpperBound( aOther.myUpperBound ), 
    myLowerBound( aOther.myLowerBound ), 
    myCurrentRemainder( aOther.myCurrentRemainder ) 
{ } 


//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator& 
DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator::
operator= ( const ConstIterator & aOther ) 
{
  if (this != &aOther)
    {
      myDSSPtr = aOther.myDSSPtr; 
      myCurrentPoint = aOther.myCurrentPoint; 
      myQuantityToAdd = aOther.myQuantityToAdd; 
      myQuantityToRemove = aOther.myQuantityToRemove; 
      myUpperBound = aOther.myUpperBound; 
      myLowerBound = aOther.myLowerBound; 
      myCurrentRemainder = aOther.myCurrentRemainder; 
    }
  return *this; 
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator::~ConstIterator()
{
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::Point 
DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator::
operator*() const
{
  return myCurrentPoint;
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
void
DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator::
next()
{
  myCurrentRemainder += myQuantityToAdd; 
  if ( myCurrentRemainder < myUpperBound )
    {
      myCurrentPoint += myDSSPtr->mySteps.first; 
    }
  else
    {
      myCurrentRemainder -= myQuantityToRemove; 
      myCurrentPoint += myDSSPtr->mySteps.second; 
    }
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator&
DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator::
operator++()
{
  this->next(); 
  return *this;
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator
DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator::
operator++(int)
{
  ConstIterator tmp(*this);
  this->next();
  return tmp;
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
void
DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator::
previous()
{
  myCurrentRemainder -= myQuantityToAdd; 
  if ( myCurrentRemainder >= myLowerBound )
    {
      myCurrentPoint -= myDSSPtr->mySteps.first; 
    }
  else
    {
      myCurrentRemainder += myQuantityToRemove; 
      myCurrentPoint -= myDSSPtr->mySteps.second; 
    }
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator&
DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator::
operator--()
{
  this->previous();
  return *this;
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
typename DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator
DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator::
operator--(int)
{
  ConstIterator tmp(*this);
  this->previous();
  return tmp;
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
bool
DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator::
operator==(const ConstIterator& aOther) const
{
  ASSERT( myDSSPtr == aOther.myDSSPtr );
  return myCurrentPoint == aOther.myCurrentPoint;
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI, unsigned short adj>
inline
bool
DGtal::ArithmeticalDSS<TC, TI, adj>::ConstIterator::
operator!=(const ConstIterator& aOther) const
{
  ASSERT( myDSSPtr == aOther.myDSSPtr );
  return myCurrentPoint != aOther.myCurrentPoint;
}

///////////////////////////////////////////////////////////////////////////////
//                        Aliases                                            //
///////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------
template <typename TC, typename TI>
inline
DGtal::StandardDSS4<TC, TI>::
StandardDSS4(const typename Super::Coordinate& aA, const typename Super::Coordinate& aB, 
	     const typename Super::Integer& aMu, const typename Super::Integer& aOmega, 
	     const typename Super::Point& aF, const typename Super::Point& aL,
	     const typename Super::Point& aUf, const typename Super::Point& aUl,
	     const typename Super::Point& aLf, const typename Super::Point& aLl)
  : Super(aA, aB, aMu, aOmega, aF, aL, aUf, aUl, aLf, aLl) 
{}

//-----------------------------------------------------------------------------
template <typename TC, typename TI>
inline
DGtal::StandardDSS4<TC, TI>::
StandardDSS4(const typename Super::Coordinate& aA, const typename Super::Coordinate& aB, 
	     const typename Super::Point& aF, const typename Super::Point& aL,
	     const typename Super::Point& aUf, const typename Super::Point& aUl,
	     const typename Super::Point& aLf, const typename Super::Point& aLl)
  : Super(aA, aB, aF, aL, aUf, aUl, aLf, aLl) 
{}

//-----------------------------------------------------------------------------
template <typename TC, typename TI>
inline
DGtal::StandardDSS4<TC, TI>::
StandardDSS4(const typename Super::Point& aF, const typename Super::Point& aL, 
	     const bool& isOnTheUpperLine)
  : Super(aF, aL, isOnTheUpperLine) 
{}

//-----------------------------------------------------------------------------
template <typename TC, typename TI>
template<typename Iterator>
inline
DGtal::StandardDSS4<TC, TI>::
StandardDSS4(const Iterator& aItb, const Iterator& aIte) throw( InputException )
  : Super(aItb, aIte) 
{}

//-----------------------------------------------------------------------------
template <typename TC, typename TI>
inline
DGtal::StandardDSS4<TC, TI>::
StandardDSS4 ( const StandardDSS4 & aOther )
  : Super( aOther ) 
{} 

//-----------------------------------------------------------------------------
template <typename TC, typename TI>
inline
DGtal::StandardDSS4<TC, TI>& 
DGtal::StandardDSS4<TC, TI>::
operator= ( const StandardDSS4 & aOther )
{
  if (this != & aOther)
    Super::operator=( aOther );
  return *this;      
}

//-----------------------------------------------------------------------------
template <typename TC, typename TI>
inline
DGtal::NaiveDSS8<TC, TI>::
NaiveDSS8(const typename Super::Coordinate& aA, const typename Super::Coordinate& aB, 
	     const typename Super::Integer& aMu, const typename Super::Integer& aOmega, 
	     const typename Super::Point& aF, const typename Super::Point& aL,
	     const typename Super::Point& aUf, const typename Super::Point& aUl,
	     const typename Super::Point& aLf, const typename Super::Point& aLl)
  : Super(aA, aB, aMu, aOmega, aF, aL, aUf, aUl, aLf, aLl) 
{}

//-----------------------------------------------------------------------------
template <typename TC, typename TI>
inline
DGtal::NaiveDSS8<TC, TI>::
NaiveDSS8(const typename Super::Coordinate& aA, const typename Super::Coordinate& aB, 
	     const typename Super::Point& aF, const typename Super::Point& aL,
	     const typename Super::Point& aUf, const typename Super::Point& aUl,
	     const typename Super::Point& aLf, const typename Super::Point& aLl)
  : Super(aA, aB, aF, aL, aUf, aUl, aLf, aLl) 
{}

//-----------------------------------------------------------------------------
template <typename TC, typename TI>
inline
DGtal::NaiveDSS8<TC, TI>::
NaiveDSS8(const typename Super::Point& aF, const typename Super::Point& aL, 
	  const bool& isOnTheUpperLine)
  : Super(aF, aL, isOnTheUpperLine) 
{}

//-----------------------------------------------------------------------------
template <typename TC, typename TI>
template<typename Iterator>
inline
DGtal::NaiveDSS8<TC, TI>::
NaiveDSS8(const Iterator& aItb, const Iterator& aIte) throw( InputException )
  : Super(aItb, aIte) 
{}

//-----------------------------------------------------------------------------
template <typename TC, typename TI>
inline
DGtal::NaiveDSS8<TC, TI>::
NaiveDSS8 ( const NaiveDSS8 & aOther )
  : Super( aOther ) 
{} 

//-----------------------------------------------------------------------------
template <typename TC, typename TI>
inline
DGtal::NaiveDSS8<TC, TI>& 
DGtal::NaiveDSS8<TC, TI>::
operator= ( const NaiveDSS8 & aOther )
{
  if (this != & aOther)
    Super::operator=( aOther );
  return *this;      
}

///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions                                        //

template <typename TC, typename TI, unsigned short adj>
inline
std::ostream&
DGtal::operator<< ( std::ostream & out, 
		    const ArithmeticalDSS<TC, TI, adj> & object )
{
  object.selfDisplay( out );
  return out;
}

//                                                                           //
///////////////////////////////////////////////////////////////////////////////


