/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file ArithmeticalDSSComputerOnSurfels.ih
 * @author Jocelyn Meyron (\c jocelyn.meyron@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Syst√®mes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 *
 * @date 2021/01/22
 *
 * Implementation of inline methods defined in ArithmeticalDSSComputerOnSurfels.h
 *
 * This file is part of the DGtal library.
 */

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
#include <algorithm>
#include <boost/version.hpp>
#if BOOST_VERSION < 105800
#include <boost/math/common_factor_rt.hpp>
#else
#include <boost/integer/common_factor_rt.hpp>
#endif

//////////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
// Implementation of inline methods                                          //

//-----------------------------------------------------------------------------
template <typename TKSpace, typename TIterator, typename TInteger, unsigned short adjacency>
inline
DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::
ArithmeticalDSSComputerOnSurfels()
  : myDSS( Point(0,0) ), myBegin(), myEnd()
{
}

//-----------------------------------------------------------------------------
template <typename TKSpace, typename TIterator, typename TInteger, unsigned short adjacency>
inline
DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::
ArithmeticalDSSComputerOnSurfels(const KSpace& aKSpace, Dimension aDim1, Dimension aDim2)
  : myKSpace(aKSpace), myDSS( Point(0,0) ), myBegin(), myEnd()
{
    // Initialize projection vectors
    myProjection1 = Point3::zero;
    myProjection2 = Point3::zero;

    myProjection1[aDim1] = 1;
    myProjection2[aDim2] = 1;

    myProjectionNormal = myProjection1.crossProduct(myProjection2);
}


//-----------------------------------------------------------------------------
template <typename TKSpace, typename TIterator, typename TInteger, unsigned short adjacency>
inline
DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::
ArithmeticalDSSComputerOnSurfels(const ConstIterator& it)
  : myDSS( *it ), myBegin(it), myEnd(it)
{
  ++myEnd;
}

//-----------------------------------------------------------------------------
template <typename TKSpace, typename TIterator, typename TInteger, unsigned short adjacency>
inline
void DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::
init(const ConstIterator& it)
{
  myBegin = it;
  myEnd = it;
  ++myEnd;

  auto initialPoints = projectSurfel(*it);
  myPreviousSurfel = *it;
  std::cout << initialPoints.first << std::endl;
  std::cout << initialPoints.second << std::endl;

  myDSS = DSS(initialPoints.first);
  ASSERT(myDSS.isExtendableFront(initialPoints.second));
  myDSS.extendFront(initialPoints.second);
}

//-----------------------------------------------------------------------------
template <typename TKSpace, typename TIterator, typename TInteger, unsigned short adjacency>
inline
DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::
ArithmeticalDSSComputerOnSurfels ( const ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency> & other )
  : myDSS(other.myDSS), myBegin(other.myBegin), myEnd(other.myEnd)
{
}

//-----------------------------------------------------------------------------
template <typename TKSpace, typename TIterator, typename TInteger, unsigned short adjacency>
inline
typename DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>&
DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::
operator=( const ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency> & other )
{
  if ( this != &other )
    {
      myDSS = other.myDSS;
      myBegin = other.myBegin;
      myEnd = other.myEnd;
    }
  return *this;
}

//-----------------------------------------------------------------------------
template <typename TKSpace, typename TIterator, typename TInteger, unsigned short adjacency>
inline
typename DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::Reverse
DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>
::getReverse() const
{
  return Reverse();
}

//-----------------------------------------------------------------------------
template <typename TKSpace, typename TIterator, typename TInteger, unsigned short adjacency>
inline
typename DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::Self
DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>
::getSelf() const
{
  return Self();
}

//-----------------------------------------------------------------------------
template <typename TKSpace, typename TIterator, typename TInteger, unsigned short adjacency>
inline
bool
DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::
operator==( const ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>& other ) const
{
  return ( (myBegin == other.myBegin)
           && (myEnd == other.myEnd)
           && (myDSS == other.myDSS) );
}

//-----------------------------------------------------------------------------
template <typename TKSpace, typename TIterator, typename TInteger, unsigned short adjacency>
inline
bool
DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::
operator!=( const ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency> & other ) const
{
  return (!(*this == other));
}

///////////////////////////////////////////////////////////////////////////////
//                       Update methods                                      //
///////////////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------
template <typename TKSpace, typename TIterator, typename TInteger, unsigned short adjacency>
inline
bool
DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::isExtendableFront()
{
  Point p = getOtherPointFromSurfel(*myEnd, false);
  return myDSS.isExtendableFront( p );
}

//--------------------------------------------------------------------
template <typename TKSpace, typename TIterator, typename TInteger, unsigned short adjacency>
inline
bool
DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::isExtendableBack()
{
  ConstIterator it = myBegin;
  --it;
  Point p = getOtherPointFromSurfel(*it, false);
  return myDSS.isExtendableBack( p );
}

//-----------------------------------------------------------------------------
template <typename TKSpace, typename TIterator, typename TInteger, unsigned short adjacency>
inline
bool
DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::extendFront()
{
    Point p = getOtherPointFromSurfel(*myEnd, true);
    std::cout << "extendFront: p=" << p << std::endl;
  if (myDSS.extendFront(p))
    {
        std::cout << "extending" << std::endl;
      ++myEnd;
      return true;
    }
  else
  {
      std::cout << "end" << std::endl;
    return false;
  }
}

//--------------------------------------------------------------------
template <typename TKSpace, typename TIterator, typename TInteger, unsigned short adjacency>
inline
bool
DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::extendBack()
{
  ConstIterator it = myBegin;
  --it;
  Point p = getOtherPointFromSurfel(*it, true);
  if (myDSS.extendBack(p))
    {
      myBegin = it;
      return true;
    }
  else
    return false;
}

//--------------------------------------------------------------------
template <typename TKSpace, typename TIterator, typename TInteger, unsigned short adjacency>
inline
bool
DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::retractFront()
{
  if (myDSS.retractFront())
    {
      --myEnd;
      return true;
    }
  else
    return false;
}

//--------------------------------------------------------------------
template <typename TKSpace, typename TIterator, typename TInteger, unsigned short adjacency>
inline
bool
DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::retractBack()
{
  if (myDSS.retractBack())
    {
      ++myBegin;
      return true;
    }
  else
    return false;
}

///////////////////////////////////////////////////////////////////////////////
//                       Accessors                                           //
///////////////////////////////////////////////////////////////////////////////
//-------------------------------------------------------------------------
template <typename TKSpace, typename TIterator, typename TInteger, unsigned short adjacency>
inline
const typename DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::Primitive&
DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::primitive() const
{
  return myDSS;
}

//-------------------------------------------------------------------------
template <typename TKSpace, typename TIterator, typename TInteger, unsigned short adjacency>
inline
TInteger
DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::remainder(const Point & aPoint) const
{
  return myDSS.remainder( aPoint );
}

//-------------------------------------------------------------------------
template <typename TKSpace, typename TIterator, typename TInteger, unsigned short adjacency>
inline
TInteger
DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::remainder(const ConstIterator & it) const
{
  return remainder(getOtherPointFromSurfel(*it, false));
}

//-------------------------------------------------------------------------
template <typename TKSpace, typename TIterator, typename TInteger, unsigned short adjacency>
inline
TInteger
DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::position(const Point & aPoint) const
{
  return myDSS.position( aPoint );
}

//-------------------------------------------------------------------------
template <typename TKSpace, typename TIterator, typename TInteger, unsigned short adjacency>
inline
TInteger
DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::position(const ConstIterator & it) const
{
  return position(getOtherPointFromSurfel(*it, false));
}

//-------------------------------------------------------------------------
template <typename TKSpace, typename TIterator, typename TInteger, unsigned short adjacency>
inline
bool
DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::isInDSL(const Point & aPoint) const
{
  return myDSS.isInDSL( aPoint );
}

//-------------------------------------------------------------------------
template <typename TKSpace, typename TIterator, typename TInteger, unsigned short adjacency>
inline
bool
DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::isInDSL(const ConstIterator & it) const
{
  return isInDSL(getOtherPointFromSurfel(*it, false));
}

//-------------------------------------------------------------------------
template <typename TKSpace, typename TIterator, typename TInteger, unsigned short adjacency>
inline
bool
DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::isInDSS(const Point & aPoint) const
{
  return myDSS.isInDSS( aPoint );
}

//-------------------------------------------------------------------------
template <typename TKSpace, typename TIterator, typename TInteger, unsigned short adjacency>
inline
bool
DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::isInDSS(const ConstIterator & it) const
{
  return isInDSS(getOtherPointFromSurfel(*it, false));
}

//-------------------------------------------------------------------------
template <typename TKSpace, typename TIterator, typename TInteger, unsigned short adjacency>
inline
TInteger
DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::a() const
{
  return myDSS.a();
}

//-------------------------------------------------------------------------
template <typename TKSpace, typename TIterator, typename TInteger, unsigned short adjacency>
inline
TInteger
DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::b() const
{
  return myDSS.b();
}

//-------------------------------------------------------------------------
template <typename TKSpace, typename TIterator, typename TInteger, unsigned short adjacency>
inline
TInteger
DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::mu() const
{
  return myDSS.mu();
}

//-------------------------------------------------------------------------
template <typename TKSpace, typename TIterator, typename TInteger, unsigned short adjacency>
inline
TInteger
DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::omega() const
{
  return myDSS.omega();
}

//-------------------------------------------------------------------------
template <typename TKSpace, typename TIterator, typename TInteger, unsigned short adjacency>
inline
typename DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::Point
DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::Uf() const
{
  return myDSS.Uf();
}

//-------------------------------------------------------------------------
template <typename TKSpace, typename TIterator, typename TInteger, unsigned short adjacency>
inline
typename DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::Point
DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::Ul() const
{
  return myDSS.Ul();
}

//-------------------------------------------------------------------------
template <typename TKSpace, typename TIterator, typename TInteger, unsigned short adjacency>
inline
typename DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::Point
DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::Lf() const
{
  return myDSS.Lf();
}

//-------------------------------------------------------------------------
template <typename TKSpace, typename TIterator, typename TInteger, unsigned short adjacency>
inline
typename DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::Point
DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::Ll() const
{
  return myDSS.Ll();
}

//-------------------------------------------------------------------------
template <typename TKSpace, typename TIterator, typename TInteger, unsigned short adjacency>
inline
typename DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::Point
DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::back() const
{
  return myDSS.back();
}

//-------------------------------------------------------------------------
template <typename TKSpace, typename TIterator, typename TInteger, unsigned short adjacency>
inline
typename DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::Point
DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::front() const
{
  return myDSS.front();
}

//-------------------------------------------------------------------------
template <typename TKSpace, typename TIterator, typename TInteger, unsigned short adjacency>
inline
TIterator
DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::begin() const
{
  return myBegin;
}

//-------------------------------------------------------------------------
template <typename TKSpace, typename TIterator, typename TInteger, unsigned short adjacency>
inline
TIterator
DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::end() const
{
  return myEnd;
}

//-----------------------------------------------------------------
template <typename TKSpace, typename TIterator, typename TInteger, unsigned short adjacency>
inline
bool
DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::isValid() const
{
  return ( (myDSS.isValid())&&(isNotEmpty(myBegin,myEnd)) );
}

//-----------------------------------------------------------------
template <typename TKSpace, typename TIterator, typename TInteger, unsigned short adjacency>
inline
void
DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::selfDisplay ( std::ostream & out) const
{
  out << "[ArithmeticalDSSComputerOnSurfels] " << myDSS;
}

//-----------------------------------------------------------------
template <typename TKSpace, typename TIterator, typename TInteger, unsigned short adjacency>
inline
typename DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::Cell
DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::commonLinel (Cell const& aSurfel1,
                                                                                            Cell const& aSurfel2) {
    typename KSpace::DirIterator q1_1 = myKSpace.uDirs(aSurfel1), q1_2 = q1_1;
    ++q1_2;
    typename KSpace::DirIterator q2_1 = myKSpace.uDirs(aSurfel2), q2_2 = q2_1;
    ++q2_2;

    std::set<Cell> linels1 = {
        myKSpace.uIncident(aSurfel1, *q1_1, true),
        myKSpace.uIncident(aSurfel1, *q1_1, false),
        myKSpace.uIncident(aSurfel1, *q1_2, true),
        myKSpace.uIncident(aSurfel1, *q1_2, false),
    };

    std::set<Cell> linels2 = {
        myKSpace.uIncident(aSurfel2, *q2_1, true),
        myKSpace.uIncident(aSurfel2, *q2_1, false),
        myKSpace.uIncident(aSurfel2, *q2_2, true),
        myKSpace.uIncident(aSurfel2, *q2_2, false),
    };

    std::vector<Cell> inter;
    std::set_intersection(linels1.begin(), linels1.end(),
                          linels2.begin(), linels2.end(),
                          std::back_inserter(inter));
    ASSERT(inter.size() == 1);

    return inter[0];
}

//-----------------------------------------------------------------
template <typename TKSpace, typename TIterator, typename TInteger, unsigned short adjacency>
inline
typename DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::Point
DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::getOtherPointFromSurfel(SCell const& aSCell,
                                                                                                       bool aUpdatePrevious)
{
    Point p1, p2;
    std::tie(p1, p2) = projectSurfel(aSCell);

    // Find the common unsigned linel between aSCell and myPreviousSurfel
    auto linel = commonLinel(myKSpace.unsigns(aSCell), myKSpace.unsigns(myPreviousSurfel));

    // For the next point, choose the point that is not common to the linel
    Point other;
    typename KSpace::DirIterator q_linel = myKSpace.uDirs(linel);
    Point linel1 = projectInPlane(myKSpace.uCoords(myKSpace.uIncident(linel, *q_linel, true)));
    Point linel2 = projectInPlane(myKSpace.uCoords(myKSpace.uIncident(linel, *q_linel, false)));

    if (p1 == linel1)
    {
        other = p2;
    }
    else if (p1 == linel2)
    {
        other == p2;
    }
    else if (p2 == linel1)
    {
        other = p1;
    }
    else if (p2 == linel2)
    {
        other = p1;
    }
    else
    {
        ASSERT(false);
    }

    if (aUpdatePrevious)
    {
        myPreviousSurfel = aSCell;
    }

    return other;
}

//-----------------------------------------------------------------
template <typename TKSpace, typename TIterator, typename TInteger, unsigned short adjacency>
inline
typename DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::Point
DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::projectInPlane(Point3 const& aPoint) const
{
    static const Point3 aOrigin = Point3::zero;

    // Orthogonal projection on the plane with a given unit normal
    Point3 h = (aPoint - aOrigin) - myProjectionNormal * (aPoint - aOrigin).dot(myProjectionNormal);

    // We simply project the point on the plane defined by
    // the two directions 'u' and 'v' passing through the origin point 'o'
    return Point(h.dot(myProjection1), h.dot(myProjection2));
}

//-----------------------------------------------------------------
template <typename TKSpace, typename TIterator, typename TInteger, unsigned short adjacency>
inline
std::pair<typename DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::Point,
          typename DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::Point>
DGtal::ArithmeticalDSSComputerOnSurfels<TKSpace,TIterator,TInteger,adjacency>::projectSurfel(SCell const& aSCell) const
{
    typename KSpace::DirIterator q1 = myKSpace.sDirs(aSCell), q2 = q1;
    ++q2;

    // We pick 2 linels of the surfel
    SCell linel1 = myKSpace.sIncident(aSCell, *q1, true), linel2 = myKSpace.sIncident(aSCell, *q1, false);
    myKSpace.sDirectIncident(aSCell, *q1);

    // 4 points of the surfel
    Point3 p1_1 = myKSpace.sCoords(myKSpace.sIncident(linel1, *q2, false)),
           p1_2 = myKSpace.sCoords(myKSpace.sIncident(linel1, *q2, true)),
           p2_1 = myKSpace.sCoords(myKSpace.sIncident(linel2, *q2, false)),
           p2_2 = myKSpace.sCoords(myKSpace.sIncident(linel2, *q2, true));

    std::set<Point> points;
    points.insert(projectInPlane(p1_1));
    points.insert(projectInPlane(p1_2));
    points.insert(projectInPlane(p2_1));
    points.insert(projectInPlane(p2_2));

    ASSERT(points.size() == 2);

    Point p1 = *points.begin(), p2 = *(++points.begin());

    return  { p1, p2 };
}
