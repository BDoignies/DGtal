/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file FP.ih
 * @author Tristan Roussillon (\c tristan.roussillon@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Syst√®mes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 *
 * @date 2011/01/26
 *
 * @brief Implementation of inline methods defined in FP.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------

template <typename TIterator, typename TInteger, int connectivity>
inline
DGtal::FP<TIterator,TInteger,connectivity>::
FP(const TIterator& itb, 
   const TIterator& ite ) throw( InputException ) 
{
  FP(itb, ite);
}

template <typename TIterator, typename TInteger, int connectivity>
inline
DGtal::FP<TIterator,TInteger,connectivity>::
algorithm(const TIterator& itb, 
	  const TIterator& ite ) throw( InputException ) 
{
  if (isNotEmpty(itb,ite)) 
    {
      typedef typename IteratorCirculatorTraits<TIterator>::Type Type; 
      algorithm( itb, ite, Type() );
    }
}

template <typename TIterator, typename TInteger, int connectivity>
inline
DGtal::FP<TIterator,TInteger,connectivity>::
algorithm(const TIterator& itb, 
	  const TIterator& ite, IteratorType ) throw( InputException ) 
{
  ASSERT(isNotEmpty(itb,ite)); 

  /////////////////////////////////////// open 
  //list of successive upper (U) and lower (L)
  // leaning points. 
  std::list<Point> vTmpU, vTmpL;
  vTmpU.push_back(*itb);
  vTmpL.push_back(*itb);

  //longest DSS
  DSSComputer longestDSS;
  longestDSS.init(itb); 
	  
  while ( (longestDSS.end() != ite)&&(longestDSS.extendForward()) ) 
    {
      //store the first upper leaning point
      if (longestDSS.getUf() != vTmpU.back()) {
	vTmpU.push_back(longestDSS.getUf());
      }
      //store the first lower leaning point
      if (longestDSS.getLf() != vTmpL.back()) {
	vTmpL.push_back(longestDSS.getLf());
      }
    }
	
  typedef details::Adapter<DSSComputer> DSSAdapter; 
  DSSAdapter* adapter = 0; //adapter for the current DSS
	
  if (longestDSS.end() != ite) 
    {
      //if the curve is not straight
      //it is either locally convex or concave at longestDSS.end() 
      adapter = initConvexityConcavity<DSSAdapter>( longestDSS );
	    
      ASSERT(adapter);
      if ( adapter.isInConvexPart() ) myPolygon = vTmpU;
      else myPolygon = vTmpL;
	    
      bool go = true; 
      while ( go ) 
	{ //main loop
	  if ( !removingStep<DSSAdapter>( longestDSS, adapter ) )
	    { //disconnected digital curve
	      throw InputException();
	    }
	  go = addingStep<DSSAdapter>( longestDSS, adapter, ite );
	  if ( go )
	    { 
	      delete (adapter); 
	      adapter = initConvexityConcavity<DSSAdapter>( longestDSS );
	    }
	}    
	    
    } 
  else 
    {
      //the curve is assumed to be convex
      //if it is straight
      myPolygon = vTmpU;
      adapter = new details::Adapter4ConvexPart<DSSComputer>(longestDSS);
      ASSERT(adapter);
    }

  //store the last leaning point 
  //if the first and last leaning points 
  //of the MS are not confounded
  if (adapter->firstLeaningPoint() != adapter->lastLeaningPoint()) {
    myPolygon.push_back(adapter->lastLeaningPoint());
  }

  //last removing step
  while ( longestDSS.retractForward() ) {
    //store the last leaning point
    if (adapter->lastLeaningPoint() != myPolygon.back()) {
      myPolygon.push_back(adapter->lastLeaningPoint());
    }
  }

  ASSERT(adapter);//had to be allocated
  delete (adapter);	
}

template <typename TIterator, typename TInteger, int connectivity>
inline
DGtal::FP<TIterator,TInteger,connectivity>::
algorithm(const TIterator& itb, 
	  const TIterator& ite, CirculatorType ) throw( InputException ) 
{
  ASSERT(isNotEmpty(itb,ite)); 

  /////////////////////////// closed
  //first maximal DSS
  DSSComputer currentDSS; 
  currentDSS.init( itb ); 
  //forward extension
  while ( currentDSS.extendForward() ) {}
  //backward extension
  while ( currentDSS.extendBackward() ) {}

  //local convexity
  typedef details::Adapter<DSSComputer> DSSAdapter; 
  DSSAdapter* adapter = 0; //adapter for the current DSS
  adapter = initConvexityConcavity<DSSAdapter>( currentDSS );

  //stopping point 
  Point stoppingPoint = adapter->lastLeaningPoint(); 
  if (adapter->firstLeaningPoint() != stoppingPoint) {
    myPolygon.push_back( stoppingPoint );
  }//otherwise, it will be retrieved at the end

  bool go = true; 
  while ( go ) 
    { //main loop
      if ( !removingStep<DSSAdapter>( currentDSS, adapter ) )
	{ //disconnected digital curve
	  throw InputException();
	}
      go = addingStep<DSSAdapter>( currentDSS, adapter, stoppingPoint );
      if ( go )
	{ 
	  delete (adapter); 
	  adapter = initConvexityConcavity<DSSAdapter>( currentDSS );
	}
    }    
	
  delete (adapter); 
}

template <typename TIterator, typename TInteger, int connectivity>
template<typename Adapter>
inline
typename Adapter*
DGtal::FP<TIterator,TInteger,connectivity>
::initConvexityConcavity( const typename Adapter::DSS &aDSS ) 
{

  ASSERT( aDSS.isExtendableForward() == false ); 

  if ( aDSS.getRemainder( aDSS.end() ) < (aDSS.getMu()) ) 
    {      //concave part
      return new details::Adapter4ConcavePart<DSS>(aDSS);
    } 
  else 
    {     //convex part
      return new details::Adapter4ConvexPart<DSS>(aDSS);
    }
}

template <typename TIterator, typename TInteger, int connectivity>
template<typename Adapter>
inline
bool 
DGtal::FP<TIterator,TInteger,connectivity>
::removingStep( typename Adapter::DSS &currentDSS, Adapter* adapter )
{

  ASSERT( aDSS.isExtendableForward() == false ); 

  //store the last leaning point 
  //if the first and last leaning points 
  //of the MS are not confounded
  if (adapter->firstLeaningPoint() != adapter->lastLeaningPoint()) {
    myPolygon.push_back(adapter->lastLeaningPoint());
  }

  //removing step
  while ( !currentDSS.isExtendableForwardForward() ) {
    //remove a point from the back
    if ( currentDSS.retractForward() ) {
      //store the last leaning point
      if (adapter->lastLeaningPoint() != myPolygon.back()) {
	myPolygon.push_back(adapter->lastLeaningPoint());
      }
    } else {
      return false; 
    }
  }
  
  return true; 
}

template <typename TIterator, typename TInteger, int connectivity>
template<typename Adapter>
inline
bool 
DGtal::FP<TIterator,TInteger,connectivity>
::addingStep( typename Adapter::DSS &currentDSS, Adapter* adapter, 
	      const typename Adapter::DSS::ConstIterator& itEnd ) 
{

  ASSERT( aDSS.isExtendableForward() == true ); 

  //remove the last leaning point 
  //if the first and last leaning points 
  //of the current DSS are not confounded
  if (adapter->firstLeaningPoint() != adapter->lastLeaningPoint()) {
    myPolygon.pop_back();
  }    

  //adding step
  while ( (currentDSS.end() != itEnd)&&(currentDSS.extendForward()) ) {
    //store the first leaning point
    if (adapter->firstLeaningPoint() != myPolygon.back()) {
      myPolygon.push_back(adapter->firstLeaningPoint());
    }
  }

  return (currentDSS.end() != itEnd); 
}

template <typename TIterator, typename TInteger, int connectivity>
template<typename Adapter>
inline
bool
DGtal::FP<TIterator,TInteger,connectivity>
::addingStep( typename Adapter::DSS &currentDSS, Adapter* adapter, 
	      const typename Adapter::DSS::Point& aPoint ) 
{

  ASSERT( aDSS.isExtendableForward() == true ); 

  //remove the last leaning point 
  //if the first and last leaning points 
  //of the current DSS are not confounded
  if (adapter->firstLeaningPoint() != adapter->lastLeaningPoint()) {
    myPolygon.pop_back();
  }    

  //adding step
  while ( currentDSS.extendForward() ) {
    //store the first leaning point
    if (adapter->firstLeaningPoint() != myPolygon.back()) {
      myPolygon.push_back(adapter->firstLeaningPoint());
    }
  }

  return ( adapter->lastLeaningPoint() == aPoint );
}

// template <typename TIterator, typename TInteger, int connectivity>
// template<typename DSS, typename Adapter>
// inline
// void 
// DGtal::FP<TIterator,TInteger,connectivity>
// ::mainRoutine( DSS &currentDSS, Adapter* adapter, 
// 		 bool isConvex, 
// 		 const typename DSS::ConstIterator& itEnd )  throw( InputException ) 
// {

//   //store the last leaning point 
//   //if the first and last leaning points 
//   //of the MS are not confounded
//   if (adapter->firstLeaningPoint() != adapter->lastLeaningPoint()) {
//     myPolygon.push_back(adapter->lastLeaningPoint());
//   }

//   //removing step
//   while ( !currentDSS.isExtendableForward() ) {
//     //remove a point from the back
//     if ( currentDSS.retractForward() ) {
//       //store the last leaning point
//       if (adapter->lastLeaningPoint() != myPolygon.back()) {
// 	myPolygon.push_back(adapter->lastLeaningPoint());
//       }
//     } else {
//       //disconnected digital curve
//       throw InputException();
//     }
//   }

//   //remove the last leaning point 
//   //if the first and last leaning points 
//   //of the current DSS are not confounded
//   if (adapter->firstLeaningPoint() != adapter->lastLeaningPoint()) {
//     myPolygon.pop_back();
//   }    

//   //adding step
//   while ( (currentDSS.end() != itEnd)&&(currentDSS.extendForward()) ) {
//     //store the first leaning point
//     if (adapter->firstLeaningPoint() != myPolygon.back()) {
//       myPolygon.push_back(adapter->firstLeaningPoint());
//     }
//   }

//   //transition step
//   if (currentDSS.end() != itEnd) {

//     if ( (isConvex)&&( currentDSS.getRemainder(i) < 
// 		       (currentDSS.getMu()) ) ) {
//       //from convex to concave
//       isConvex = false;
//       delete (adapter);
//       adapter = new details::Adapter4ConcavePart<DSS>(currentDSS);
//     } else if ( (!isConvex)&&( currentDSS.getRemainder(i) >= 
// 			       (currentDSS.getMu()+currentDSS.getOmega()) ) ) {
//       //from concave to convex
//       isConvex = true;
//       delete (adapter);
//       adapter = new details::Adapter4ConvexPart<DSS>(currentDSS);
//     }
//     //else no transition
//   }

// }

// template <typename TIterator, typename TInteger, int connectivity>
// template<typename DSS, typename Adapter>
// inline
// void 
// DGtal::FP<TIterator,TInteger,connectivity>
// ::mainAlgorithm( DSS &currentDSS, Adapter* adapter, 
// 		 bool isConvex, 
// 		 const typename DSS::ConstIterator& itEnd )  throw( InputException ) {

//   ASSERT(adapter != 0);

//   //std::cerr << "first DSS" << std::endl;
//   //std::cerr << currentDSS << std::endl;

//   while (currentDSS.end() != itEnd) {

//     //store the last leaning point 
//     //if the first and last leaning points 
//     //of the MS are not confounded
//     if (adapter->firstLeaningPoint() != adapter->lastLeaningPoint()) {
//       myPolygon.push_back(adapter->lastLeaningPoint());
//     }

//     //removing step
//     while ( !currentDSS.isExtendableForward() ) {
//       //remove a point from the back
//       if ( currentDSS.retractForward() ) {
//         //store the last leaning point
//         if (adapter->lastLeaningPoint() != myPolygon.back()) {
//           myPolygon.push_back(adapter->lastLeaningPoint());
//         }
//       } else {
//         //disconnected digital curve
//         throw InputException();
//       }
//     }

//     //remove the last leaning point 
//     //if the first and last leaning points 
//     //of the current DSS are not confounded
//     if (adapter->firstLeaningPoint() != adapter->lastLeaningPoint()) {
//       myPolygon.pop_back();
//     }    

//     //adding step
//     while ( (currentDSS.end() != itEnd)&&(currentDSS.extendForward()) ) {
//       //store the first leaning point
//       if (adapter->firstLeaningPoint() != myPolygon.back()) {
//         myPolygon.push_back(adapter->firstLeaningPoint());
//       }
//     }

//     //transition step
//     if (currentDSS.end() != itEnd) {

//       if ( (isConvex)&&( currentDSS.getRemainder(i) < 
// 			 (currentDSS.getMu()) ) ) {
//         //from convex to concave
//         isConvex = false;
//         delete (adapter);
//         adapter = new details::Adapter4ConcavePart<DSS>(currentDSS);
//       } else if ( (!isConvex)&&( currentDSS.getRemainder(i) >= 
// 				 (currentDSS.getMu()+currentDSS.getOmega()) ) ) {
//         //from concave to convex
//         isConvex = true;
//         delete (adapter);
//         adapter = new details::Adapter4ConvexPart<DSS>(currentDSS);
//       }
//       //else no transition
//     }

//   }//end while

//   //std::cerr << "last DSS" << std::endl;
//   //std::cerr << currentDSS << std::endl;

//   //last removing step
//   while ( currentDSS.retractForward() ) {
//     //store the last leaning point
//     if (adapter->lastLeaningPoint() != myPolygon.back()) {
//       myPolygon.push_back(adapter->lastLeaningPoint());
//     }
//   }

// }


  
// template <typename TIterator, typename TInteger, int connectivity>
// inline
// DGtal::FP<TIterator,TInteger,connectivity>::FP(
// 					       const TIterator& itb, 
// 					       const TIterator& ite, 
// 					       const bool& isClosed ) throw( InputException ) 
//   : myFlagIsClosed( isClosed ) 
// {

//   TIterator i = itb;
//   if (i != ite) 
//     {
//       if (myFlagIsClosed) 
// 	{ /////////////////////////// closed
// 	  //first maximal DSS
// 	  Circulator<TIterator> citb(i,itb,ite);
// 	  //DSSComputerInLoop firstMS(citb);
// 	  DSSComputerInLoop *firstMS=new DSSComputerInLoop(citb); //init

// 	  ASSERT(firstMS);
	
// 	  //backward extension
// 	  Circulator<TIterator> back( citb );
// 	  do {
// 	    --back; 
// 	  } while (firstMS->extendBackward(back));
// 	  //forward extension
// 	  Circulator<TIterator> front( citb );
// 	  do {
// 	    ++front; 
// 	  } while (firstMS->extendForward(front));

// 	  //local convexity
// 	  bool isConvexAtFront; 
// 	  Adapter<DSSComputerInLoop>* adapterAtFront;   
	
// 	  isConvexAtFront = initConvexityConcavity<DSSComputerInLoop,Adapter<DSSComputerInLoop> >
// 	    (*firstMS,adapterAtFront,front);
	
// 	  bool isConvexAtBack; 
// 	  Adapter<DSSComputerInLoop>* adapterAtBack;  
	
// 	  isConvexAtBack = initConvexityConcavity<DSSComputerInLoop,Adapter<DSSComputerInLoop> >
// 	    (*firstMS,adapterAtBack,back);
	
// 	  ASSERT(adapterAtFront);
// 	  ASSERT(adapterAtBack);
	
	
// 	  //first point 
// 	  if (adapterAtFront->firstLeaningPoint() == adapterAtFront->lastLeaningPoint()) {
// 	    myPolygon.push_back(adapterAtFront->lastLeaningPoint());
// 	  }
	
// 	  //set end iterator
// 	  typename DSSComputerInLoop::Point leaningPoint; 
// 	  if ( ( (isConvexAtFront)&&(isConvexAtBack) ) 
// 	       || ( (!isConvexAtFront)&&(!isConvexAtBack) ) ) {
// 	    leaningPoint = adapterAtFront->lastLeaningPoint();
// 	  } else {
// 	    leaningPoint = adapterAtBack->firstLeaningPoint(); 
// 	  }
// 	  do {
// 	    ++back;
// 	  } while (*back != leaningPoint);
// 	  ++back;
	
// 	  //call main algo
// 	  mainAlgorithm<DSSComputerInLoop,Adapter<DSSComputerInLoop> >
// 	    (*firstMS,adapterAtFront,isConvexAtFront,front,back);
	
// 	  ASSERT(adapterAtFront);
// 	  ASSERT(adapterAtBack);
	
// 	  //delete (adapterAtFront);
// 	  //delete (adapterAtBack);
// 	  delete (firstMS);
// 	  //remove the last point
// 	  myPolygon.pop_back();
	
// 	} 
//       else 
// 	{ /////////////////////////////////////// open 
// 	  //list of successive upper (U) and lower (L)
// 	  // leaning points. 
// 	  std::list<Point> vTmpU, vTmpL;
// 	  vTmpU.push_back(*i);
// 	  vTmpL.push_back(*i);

// 	  //longest DSS
// 	  DSSComputer *longestDSS= new DSSComputer(i); //longest DSS
	  
// 	  ASSERT(longestDSS);

// 	  ++i; //move forward
// 	  while ( (i != ite)&&(longestDSS->extendForward(i)) ) 
// 	    {
// 	      //store the first upper leaning point
// 	      if (longestDSS->getUf() != vTmpU.back()) {
// 		vTmpU.push_back(longestDSS->getUf());
// 	      }
// 	      //store the first lower leaning point
// 	      if (longestDSS->getLf() != vTmpL.back()) {
// 		vTmpL.push_back(longestDSS->getLf());
// 	      }
// 	      ++i; //move forward
// 	    }
	
// 	  bool isConvex; //TRUE if longestDSS begins a convex part, FALSE otherwise
// 	  Adapter<DSSComputer>* adapter; //adapter for the current DSS
	
// 	  if (i != ite) 
// 	    {
// 	      isConvex = initConvexityConcavity<DSSComputer,Adapter<DSSComputer> >
// 		(*longestDSS,adapter,i);
	    
// 	      ASSERT(adapter);
	    
// 	      if (isConvex) myPolygon = vTmpU;
// 	      else myPolygon = vTmpL;
	    
// 	      //call main algo
// 	      mainAlgorithm<DSSComputer,Adapter<DSSComputer> >
// 		(*longestDSS,adapter,isConvex,i,ite);
	    
// 	      ASSERT(adapter);
// 	      //delete (adapter);
// 	      delete (longestDSS);
// 	    } 
// 	  else 
// 	    {
// 	      //the part is assumed to be convex
// 	      //if it is straight
// 	      myPolygon = vTmpU;
// 	      isConvex = true;
// 	      adapter = new Adapter4ConvexPart<DSSComputer>(*longestDSS);
// 	      ASSERT(adapter);
// 	    }
	
// 	}//end closed/open test
    
//     } //end itb == ite test
  
// }

template <typename TIterator, typename TInteger, int connectivity>
inline
DGtal::FP<TIterator,TInteger,connectivity>::~FP()
{
}

///////////////////////////////////////////////////////////////////////////////
// Interface - public :

template <typename TIterator, typename TInteger, int connectivity>
inline
const typename DGtal::FP<TIterator,TInteger,connectivity>::Polygon&
DGtal::FP<TIterator,TInteger,connectivity>::polygon() const
{
  //TODO not kept (begin/end method on vertices)
  return myPolygon;
};
    
template <typename TIterator, typename TInteger, int connectivity>
inline
bool
DGtal::FP<TIterator,TInteger,connectivity>::isClosed() const
{
  //since the input digital curve has to be connected
  return isCirculator<TIterator>::value;
};

template <typename TIterator, typename TInteger, int connectivity>
inline
double
DGtal::FP<TIterator,TInteger,connectivity>
::isValid(const Point& a,const Point& b, const Point& c) const {

  Vector e1 = b - a; //previous edge
  Vector e2 = c - b; //next edge

  if ( (quadrant(e1,1))&&(quadrant(e2,1)) ) {
    return true; 
  } else if ( (quadrant(e1,2))&&(quadrant(e2,2)) ) {
    return true; 
  } else if ( (quadrant(e1,3))&&(quadrant(e2,3)) ) {
    return true; 
  } else if ( (quadrant(e1,4))&&(quadrant(e2,4)) ) {
    return true; 
  } else {
    return false; 
  }

}

template <typename TIterator, typename TInteger, int connectivity>
inline
bool
DGtal::FP<TIterator,TInteger,connectivity>::isValid() const
{
  typedef typename Polygon::const_iterator I; 

  //not two consecutive confounded points
  bool flag1 = true; 
  I it = myPolygon.begin();
  if (it != myPolygon.end())
    {
      I itPrev = it; ++it;  
      if (it != myPolygon.end())
	{
	  while ( (it != myPolygon.end())&&(flag1) ) 
	    {
	      flag1 = (*itPrev != *it); 
	      itPrev = it; 
	      ++it; 
	    }
	}//if only one point ok
    }//if no point ok

  //valid quadrant for all consecutive pairs of edges
  bool flag2 = true; 
  if (myPolygon.size() >= 3) { 

    I  i, j, k;
    i = myPolygon.begin();
    j = i; ++j; 
    k = j; ++k; 

    if ( isClosed() ) { ///////// closed

      //first point
      flag2 = isValid(myPolygon.back(),*i,*j);
      //middle points
      while ( (k != myPolygon.end())&&(flag2) ) {
        flag2 = isValid(*i,*j,*k);
        ++i; ++j; ++k; 
      }
      //last point
      if (flag2) 
	flag2 = isValid(*i,*j,myPolygon.front());

    } else { ////////////////////// open 

      //first point
      flag2 = isValid( myPolygon.front() );
      //middle points
      while ( (k != myPolygon.end())&&(flag2) ) {
        flag2 = isValid(*i,*j,*k);
        ++i; ++j; ++k; 
      }
      //last point
      if (flag2)
	flag2 = isValid( myPolygon.back() );

    }
  }//special case of less than 3 points ok

  return flag1 && flag2;
}

template <typename TIterator, typename TInteger, int connectivity>
inline
typename FP<TIterator,TInteger,connectivity>::Polygon::size_type
DGtal::FP<TIterator,TInteger,connectivity>::size() const
{
  return myPolygon.size();
}


template <typename TIterator, typename TInteger, int connectivity>
template <typename OutputIterator>
inline
OutputIterator
DGtal::FP<TIterator,TInteger,connectivity>::copyFP(OutputIterator result) const {
  typename Polygon::const_iterator i = myPolygon.begin();
  while ( i != myPolygon.end() ) {
    *result++ = *i++;
  }
  return result;
}

template <typename TIterator, typename TInteger, int connectivity>
template <typename OutputIterator>
inline
OutputIterator
DGtal::FP<TIterator,TInteger,connectivity>::copyMLP(OutputIterator result) const {

  ASSERT( isValid() ); 

  unsigned int n = (unsigned int) myPolygon.size();
  if (n < 3) { //special case < 3 points

    typename Polygon::const_iterator i = myPolygon.begin();
    for ( ; i!= myPolygon.end() ; ++i) {
      *result++ = RealPoint( *i );
    }

  } else {    //standard case

    typename Polygon::const_iterator i, j, k;
    i = myPolygon.begin();
    j = i; ++j; 
    k = j; ++k; 

    if (myFlagIsClosed) { ///////// closed

      //first point
      *result++ = getRealPoint(myPolygon.back(),*i,*j);
      //middle points
      while ( k != myPolygon.end() ) {
        *result++ = getRealPoint(*i,*j,*k);
        ++i; ++j; ++k; 
      }
      //last point
      *result++ = getRealPoint(*i,*j,myPolygon.front());

    } else { ////////////////////// open 

      //first point
      *result++ = RealPoint( myPolygon.front() );
      //middle points
      while ( k != myPolygon.end() ) {
        *result++ = getRealPoint(*i,*j,*k);
        ++i; ++j; ++k; 
      }
      //last point
      *result++ = RealPoint( myPolygon.back() );

    }

  }
  return result;
}

template <typename TIterator, typename TInteger, int connectivity>
inline
DGtal::PointVector<2,double>
DGtal::FP<TIterator,TInteger,connectivity>
::getRealPoint (const Point& a,const Point& b, const Point& c) const {

  ASSERT( isValid() ); 

  RealVector shift;

  Vector e1 = b - a; //previous edge
  Vector e2 = c - b; //next edge

  if ( (e1[0]*e2[1]-e1[1]*e2[0]) <= 0 ) {

    //convex turn
    if ( (quadrant(e1,1))&&(quadrant(e2,1)) ) {
      shift = RealVector(0.5,-0.5);
    } else if ( (quadrant(e1,2))&&(quadrant(e2,2)) ) {
      shift = RealVector(-0.5,-0.5);
    } else if ( (quadrant(e1,3))&&(quadrant(e2,3)) ) {
      shift = RealVector(-0.5,0.5);
    } else if ( (quadrant(e1,4))&&(quadrant(e2,4)) ) {
      shift = RealVector(0.5,0.5);
    } else {
      ASSERT(false && "DGtal::FP<TIterator,TInteger,connectivity>::getRealPoint: not valid polygon" );
    }

  } else {

    //concave turn
    if ( (quadrant(e1,1))&&(quadrant(e2,1)) ) {
      shift = RealVector(-0.5,0.5);
    } else if ( (quadrant(e1,2))&&(quadrant(e2,2)) ) {
      shift = RealVector(0.5,0.5);
    } else if ( (quadrant(e1,3))&&(quadrant(e2,3)) ) {
      shift = RealVector(0.5,-0.5);
    } else if ( (quadrant(e1,4))&&(quadrant(e2,4)) ) {
      shift = RealVector(-0.5,-0.5);
    } else {
      ASSERT(false && "DGtal::FP<TIterator,TInteger,connectivity>::getRealPoint: not valid polygon" );
    }

  } 

  return ( RealPoint(b) + shift );
}

template <typename TIterator, typename TInteger, int connectivity>
inline
bool
DGtal::FP<TIterator,TInteger,connectivity>
::quadrant (const Vector& v, const int& q) const {

  if (q == 1) {
    return ( (v[0]>=0)&&(v[1]>=0) );
  } else if (q == 2) {
    return ( (v[0]>=0)&&(v[1]<=0) );
  } else if (q == 3) {
    return ( (v[0]<=0)&&(v[1]<=0) );
  } else if (q == 4) {
    return ( (v[0]<=0)&&(v[1]>=0) );
  } else {
    ASSERT(false && 
	   "DGtal::FP<TIterator,TInteger,connectivity>::quadrant: quadrant number should be 0,1,2 or 3"  );
    return false;
  }
}

///////////////////////////////////////////////////////////////////////////////
// Display :

template <typename TIterator, typename TInteger, int connectivity>
inline
std::string
DGtal::FP<TIterator,TInteger,connectivity>::className() const
{
  return "FP";
} 


template <typename TIterator, typename TInteger, int connectivity>
inline
void
DGtal::FP<TIterator,TInteger,connectivity>::selfDisplay ( std::ostream & out ) const
{
  out << "[FP]" << endl;
  typename Polygon::const_iterator i = myPolygon.begin();
  for ( ;i != myPolygon.end();++i)
    {
      out << "\t " << (*i) << endl;
    }              
  out << "[end FP]" << endl;
}





///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions                                        //

template <typename TIterator, typename TInteger, int connectivity>
inline
std::ostream&
DGtal::operator<< ( std::ostream & out, 
		    const FP<TIterator,TInteger,connectivity> & object )
{
  object.selfDisplay( out );
  return out;
}

//                                                                           //
///////////////////////////////////////////////////////////////////////////////


