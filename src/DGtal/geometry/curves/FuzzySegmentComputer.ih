/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file FuzzySegmentComputer.ih
 * @author Bertrand Kerautret (\c kerautre@loria.fr )
 * LORIA (CNRS, UMR 7503), University of Nancy, France
 * @author Alexandre Faure
 * @author Fabien Feschet 
 * @author Mohammad Said
 * @author Jacques-Olivier Lachaud
 *
 * @date 2015/01/05
 *
 * Implementation of inline methods defined in FuzzySegmentComputer.h
 *
 * This file is part of the DGtal library.
 */

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
#include <limits>
//////////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////
// Implementation of inline methods                                          //
///////////////////////////////////////////////////////////////////////////////



// ----------------------- Standard services ------------------------------


//-----------------------------------------------------------------------------
template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::~FuzzySegmentComputer()
{ 
}



//-----------------------------------------------------------------------------
template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::FuzzySegmentComputer()
{ 
  myIsMelkmanInitialized = false;
  myIsValid = false;
}



//-----------------------------------------------------------------------------
template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::
FuzzySegmentComputer( const FuzzySegmentComputer & other )
{ // Nothing to do.
}

template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar> & 
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::
operator= ( const FuzzySegmentComputer & other )
{// Nothing to do.

}




//-----------------------------------------------------------------------------
template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
typename DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::Size
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::size() const 
{
  return myPointSet.size();
}


//-----------------------------------------------------------------------------
template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
bool
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::empty() const 
{
  return myPointSet.size()!=0;
}



//-----------------------------------------------------------------------------
template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
typename DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::ConstIterator
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::begin() const 
{
  return myPointSet.begin();

}



//-----------------------------------------------------------------------------
template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
typename DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::ConstIterator
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::end() const 
{
  return myPointSet.end();
}




//-----------------------------------------------------------------------------
template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
typename DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::Size
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::max_size() const 
{
  return myPointSet.max_size();
}




//-----------------------------------------------------------------------------
template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
typename DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::Size
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::maxSize() const 
{
  return myPointSet.max_size();
}







//-----------------------------------------------------------------------------
template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
void
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::
init(double aThickness)  
{
  myThickness = aThickness;
  myConvexHullWidth = 0.0;
  myConvexHullHeight = 0.0;
  myIsMelkmanInitialized = false;
  myIsValid = true;
  myBoxLength = -1.0;
}



//-----------------------------------------------------------------------------
template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
bool
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::isExtendableFront(const InputPoint &aPoint ) 
{
  return true;  
}



//-----------------------------------------------------------------------------
template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
bool
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::extendFront(const InputPoint &aPoint) 
{
  // save previous state
  std::deque< unsigned int > prevEnvConv = myMelkmanQueue;
  InputPoint sav_P, sav_Q, sav_S;
   
  sav_P = myEdgePh;
  sav_Q = myEdgeQh;
  sav_S = myVertexSh;
  
  // Try to add point
  melkmanAddPoint(myPointSet.size());
  myPointSet.push_back(aPoint);
  if (melkmanIsConvexValid()){
    if (myPointSet.size()==1){
      myLastBack = aPoint;
    }
    myLastFront = aPoint;
    myP = myEdgePh;
    myQ = myEdgeQh;
    myS = myVertexSh;
    return true;
  }else{
    myPointSet.pop_back();
    myMelkmanQueue = prevEnvConv;
    myEdgePh = sav_P;
    myEdgeQh = sav_Q;
    myVertexSh = sav_S;  
    myP = sav_P;
    myQ = sav_Q;
    myS = sav_S;
    return false;
  }
}



//-----------------------------------------------------------------------------
template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
bool
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::isExtendableBack() 
{
  return true;  
}



//-----------------------------------------------------------------------------
template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
bool
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::extendBack() 
{
  return true;  
}




//-----------------------------------------------------------------------------
template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
typename DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::Primitive
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::primitive()  const
{
  return Primitive(0,0,0);  
}




//-----------------------------------------------------------------------------
template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
void
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::selfDisplay(std::ostream & out)  const
{
  out << "[Fuzzy Segment Computer]" << std::endl; 
  out << "Inside points: "<< std::endl;
  for ( ConstIterator it = myPointSet.begin(); it != myPointSet.end(); ++it){
    out << *it << " ";
  }
  out << std::endl << "is well melkman init ?" << (myIsMelkmanInitialized? " OK ": "NO"); 
  out << std::endl << "Convexhull width: " << myConvexHullWidth << std::endl;
  out << std::endl << "Convexhull height: " << myConvexHullHeight << std::endl;  


}




//-----------------------------------------------------------------------------
template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
bool
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::isValid()  const
{
  return true;
}





//-----------------------------------------------------------------------------
template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
bool
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::melkmanIsWellInitialized()  const
{
  return myIsMelkmanInitialized;
}


//-----------------------------------------------------------------------------
template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
double
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::melkmanMainDiagonal()  
{
  /** Strategie is simple:
   *  Do the same thing than for height but with a correction due to 
   *  the diagonal.
   */
  int size = myMelkmanQueue.size();
  InputPoint P, Q, R, S;
  int q,s; /* [pq] is an edge and s a vertex */
  bool stop = false; /* Default is false */
  double tmpheight, k, dMinus, dPlus;
  double maxDoubleValue =  std::numeric_limits<int>::max();

  /* Take the first edge and find the corresponding point of support */
  P =  myPointSet[myMelkmanQueue[ 0 ]] ;
  q = 1;
  Q = myPointSet[myMelkmanQueue[ q++ ]] ;
  /** To find s, start at q+1 and move until angle between the edge at s 
   *  and the line pq is positive.
   */
  s = q;
  S = myPointSet[myMelkmanQueue[ s++ ]];
  R = myPointSet[myMelkmanQueue[ s++ ]];
  while( !stop )
    {
      /* Use vectorial product to ckeck angle */
      stop = ( ( R[0] - S[0] ) * ( Q[1] - P[1] ) - ( R[1] - S[1] ) * ( Q[0] - P[0] ) ) >= 0;
      /* If not stop, move forward */
      if( !stop )
        {
          S = R;
          R =  myPointSet[myMelkmanQueue[ s++ ]];
        }
    }
  /* Initialize the diagonal distance */
  k = ( Q[1] - P[1] ) * S[0] - ( Q[0] - P[0] ) * S[1] - ( Q[1] * P[0] - Q[0] * P[1] );
  dMinus = fabs( k / (  ( Q[0] - P[0] ) + ( Q[1] - P[1] ) ) );
  dPlus = fabs( k / (  ( Q[0] - P[0] ) - ( Q[1] - P[1] ) ) );
  myConvexHullHeight = ( dPlus <= dMinus ) ? dPlus : dMinus;
  myEdgePh = P; myEdgeQh = Q; myVertexSh = S;
  /* We have found the first (edge,vertex) pair. Go on until cycling. */
  s--;   /* R is untouch */
  P = Q;
  Q = myPointSet[myMelkmanQueue[ q ]] ;
  do
    {
      /** Rotate until one edge touch the border
       *  To do this, replicate the border and compute the sign of the angle
       */
      while( ( Q[0] - P[0] ) * ( R[1] - S[1] )  - ( Q[1] - P[1] ) * ( R[0] - S[0] ) >= 0 )
        {
          S = R;
          s = ( s + 1 ) % size;
          R = myPointSet[myMelkmanQueue[ s ]] ;
        }
      /* Update height if necessary */
      k = ( Q[1] - P[1] ) * S[0] - ( Q[0] - P[0] ) * S[1] - ( Q[1] * P[0] - Q[0] * P[1] );
      if( ( Q[1] - P[1] ) - ( Q[0] - P[0] ) == 0 )
        dMinus = maxDoubleValue;
      else
        dMinus = fabs( k / (  ( Q[1] - P[1] ) - ( Q[0] - P[0] ) ) );
      if( ( Q[1] - P[1] ) + ( Q[0] - P[0] ) == 0 )
        dPlus = maxDoubleValue;
      else
        dPlus = fabs( k / (  ( Q[1] - P[1] ) + ( Q[0] - P[0] ) ) );
      /* Compute new diagonal distance / sqrt(2) */
      tmpheight = ( dPlus <= dMinus ) ? dPlus : dMinus;
      if( tmpheight < myConvexHullHeight )
        {
          myConvexHullHeight = tmpheight;
          myEdgePh = P; myEdgeQh = Q; myVertexSh = S;
        }
      /* Go to next point */
      P = Q;
      q = ( q + 1 ) % size;
      Q = myPointSet[myMelkmanQueue[ q ]] ;
    }while( q != 0 );
  
  /* Fix width to an innaccessible value. */
  myConvexHullWidth = maxDoubleValue; 

  return 0.0;
}


//-----------------------------------------------------------------------------
template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
void
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::melkmanAddPoint(unsigned int aPointIndex)
{
  if (myMelkmanQueue.size() ==  2){
    myMelkmanQueue.push_back(aPointIndex);
    melkmanInitCheck();
    myIsMelkmanInitialized=true;
    return;
  }else if (myMelkmanQueue.size() < 2){
    myMelkmanQueue.push_back(aPointIndex);
    return;
  }
  
  /** incrementally add an exterior vertex to the deque hull
   *  get the rightmore tangent at the deque bottom
   */
  if( myMelkmanQueue.size() == 3 && melkmanIsLeft( myMelkmanQueue[0], myMelkmanQueue[1], aPointIndex ) == 0 
      && melkmanIsLeft( myMelkmanQueue[1], myMelkmanQueue[2], aPointIndex ) == 0 )
    {
      myMelkmanQueue.pop_front();
      myMelkmanQueue.push_front( aPointIndex );
      myMelkmanQueue.pop_back();
      myMelkmanQueue.push_back( aPointIndex );
    }

  /* Test if next vertex is inside the deque Hull */
  else if( melkmanIsLeft( myMelkmanQueue[0], myMelkmanQueue[1], aPointIndex ) > 0
           && melkmanIsLeft( myMelkmanQueue[int(myMelkmanQueue.size())-2], 
                             myMelkmanQueue[int(myMelkmanQueue.size())-1], aPointIndex ) > 0 )
    return;   /* skip an interior vertex */
  else //if( IsLeft( D[0], D[1], P ) < 0 || IsLeft( D[n-2], D[n-1], P ) < 0 )
    {
      while( melkmanIsLeft( myMelkmanQueue[0], myMelkmanQueue[1], aPointIndex ) <= 0 )
        myMelkmanQueue.pop_front();    /* remove bottom of deque */

      myMelkmanQueue.push_front( aPointIndex );  /* insert id at bottom of deque */

      while( melkmanIsLeft( myMelkmanQueue[int(myMelkmanQueue.size())-2], myMelkmanQueue[int(myMelkmanQueue.size())-1], aPointIndex ) <= 0 )
        myMelkmanQueue.pop_back();     /* pop top of deque */

      myMelkmanQueue.push_back( aPointIndex );   /* push id onto top of deque */
    }
}



template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
void
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::
melkmanInitCheck() 
{
  unsigned int aPoint1 = myMelkmanQueue[0];
  unsigned int aPoint2 = myMelkmanQueue[1];
  unsigned int aPoint3 = myMelkmanQueue[2];
  myMelkmanQueue.clear();

  if( melkmanIsLeft( aPoint1, aPoint2, aPoint3 ) == 0.0 )
    {
      myMelkmanQueue.push_back(aPoint3);
      myMelkmanQueue.push_back(aPoint1);
      myMelkmanQueue.push_back(aPoint3);
    }
  else
    {
      myMelkmanQueue.push_front(aPoint3);
      if( melkmanIsLeft( aPoint1, aPoint2, aPoint3 ) > 0 )      /* ccw vertices are: 2,0,1,2 */
        {
          myMelkmanQueue.push_back(aPoint1);
          myMelkmanQueue.push_back(aPoint2); 
        }
      else                                /* ccw vertices are: 2,1,0,2 */
        {
          myMelkmanQueue.push_back(aPoint2);
          myMelkmanQueue.push_back(aPoint1); 
        }  
      myMelkmanQueue.push_back(aPoint3);
    }   
}





//-----------------------------------------------------------------------------
template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
bool
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::melkmanIsConvexValid() 
{
  /** Strategy is as follows:
   *  If connexity is 0, use MainDiagonal < k * sqrt(2), for k = 1,2,...
   */
  if (!myIsMelkmanInitialized){
    return true;
  } 
  melkmanMainDiagonal();
  return ( myConvexHullHeight < myConvexHullWidth ? myConvexHullHeight: myConvexHullWidth ) < myThickness * sqrt( 2.0 );
  
}


//-----------------------------------------------------------------------------
template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
TInternalScalar
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::melkmanIsLeft(unsigned int aPointIndex0,
                                                                                 unsigned int aPointIndex1,
                                                                                 unsigned int aPointIndex2) const
{
  return (myPointSet[aPointIndex1] - myPointSet[aPointIndex0])[0]*(myPointSet[aPointIndex2] - myPointSet[aPointIndex0])[1]-(myPointSet[aPointIndex2] - myPointSet[aPointIndex0])[0]*(myPointSet[aPointIndex1] - myPointSet[aPointIndex0])[1];
}


template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
std::vector<TInputPoint>
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::getConvexHull() const{
  std::vector<InputPoint> aResult;
  for (typename std::deque<unsigned int>::const_iterator it = myMelkmanQueue.begin(); it != myMelkmanQueue.end(); it++){
    aResult.push_back(myPointSet[*it]);
  }
  return aResult;
}



template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
void
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::getSegmentBoundsFromExtremPt(const InputPoint &aFirstPt,
                                                                                                const InputPoint &aLastPt,
                                                                                                InputPoint &pt1LongestSegment1,
                                                                                                InputPoint &pt2LongestSegment1,
                                                                                                InputPoint &pt3LongestSegment2,
                                                                                                InputPoint &pt4LongestSegment2,
                                                                                                double minVisibleWidthBounds) const{
  
  // Special case, blurred segment composed only of aligned points. 
  // In this cas the bounding box is restrained to a eplison width rectangle.
  
  if(myConvexHullHeight==0.0){
    InputPoint vectPQ (myQ[0]- myP[0], myQ[1]- myP[1]); 
    double normPQ = vectPQ.norm();
    InputPoint vectUnitPerpPQ (-vectPQ[1]/normPQ, vectPQ[0]/normPQ);
    pt1LongestSegment1[0]=myP[0]+vectUnitPerpPQ[0]*minVisibleWidthBounds/2.0;
    pt1LongestSegment1[1]=myP[1]+vectUnitPerpPQ[1]*minVisibleWidthBounds/2.0;
    
    pt2LongestSegment1[0]=myQ[0]+vectUnitPerpPQ[0]*minVisibleWidthBounds/2.0;
    pt2LongestSegment1[1]=myQ[1]+vectUnitPerpPQ[1]*minVisibleWidthBounds/2.0;
    
    pt3LongestSegment2[0]= myQ[0]-vectUnitPerpPQ[0]*minVisibleWidthBounds/2.0;
    pt3LongestSegment2[1]= myQ[1]-vectUnitPerpPQ[1]*minVisibleWidthBounds/2.0;
    
    pt4LongestSegment2[0]= myP[0]-vectUnitPerpPQ[0]*minVisibleWidthBounds/2.0;
    pt4LongestSegment2[1]= myP[1]-vectUnitPerpPQ[1]*minVisibleWidthBounds/2.0;
    
  }else{
    InputPoint projF, projL, projS ;
    projetOnStraightLine(myP, myQ, aFirstPt, projF);
    projetOnStraightLine(myP, myQ, aLastPt, projL);
    projetOnStraightLine(myP, myQ, myS, projS);
    
    // Shift of the projection of PQ to define the other part of bounds.
    InputPoint dep (myS[0]-projS[0], myS[1]-projS[1]);
    InputPoint projF2(projF[0]+dep[0], projF[1]+dep[1] );
    InputPoint projL2(projL[0]+dep[0], projL[1]+dep[1] );
    
    pt1LongestSegment1[0]=projF[0];
    pt1LongestSegment1[1]=projF[1];
    
    pt2LongestSegment1[0]=projL[0];
    pt2LongestSegment1[1]=projL[1];
    
    pt3LongestSegment2[0]=projL2[0];
    pt3LongestSegment2[1]=projL2[1];
    
    pt4LongestSegment2[0]=projF2[0];
    pt4LongestSegment2[1]=projF2[1];      
  }
}


template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
void
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::getBasicBounds(InputPoint &pt1LongestSegment1,
                                                                                  InputPoint &pt2LongestSegment1,
                                                                                  InputPoint &pt3LongestSegment2,
                                                                                  InputPoint &pt4LongestSegment2,
                                                                                  double minVisibleWidthBounds) const{ 
  // To be changed with saved point added by push front/push back
  InputPoint fp = myLastBack;
  InputPoint lp = myLastFront;
  getSegmentBoundsFromExtremPt(fp, lp, pt1LongestSegment1, pt2LongestSegment1, pt3LongestSegment2, pt4LongestSegment2);
}




template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
void 
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::getRealBounds(InputPoint &pt1LongestSegment1,
                                                                                 InputPoint &pt2LongestSegment1,
                                                                                 InputPoint &pt3LongestSegment2,
                                                                                 InputPoint &pt4LongestSegment2,
                                                                                 double minVisibleWidthBounds ) const
{
  
  getBasicBounds(pt1LongestSegment1, pt2LongestSegment1, 
                 pt3LongestSegment2, pt4LongestSegment2, minVisibleWidthBounds);
  if(myConvexHullHeight==0.0){
    return;
  }
  // To be changed with saved point added by push front/push back
  InputPoint extremF = myLastFront;
  InputPoint extremL = myLastBack;
  InputPoint projExtremF;
  InputPoint projExtremL;
  
  projetOnStraightLine(myP, myQ, extremF, projExtremF);
  projetOnStraightLine(myP, myQ, extremL, projExtremL);  
  
  std::deque<unsigned int> dSegment = myMelkmanQueue;
  int nb = dSegment.size();
  for( uint p = 0 ; p < nb ; ++p)
    {
      InputPoint pointEnvConv = myPointSet[dSegment[p]];
      InputPoint projPointEnvConv;
      bool isNewExtrema = !projetOnStraightLine(projExtremF, projExtremL, pointEnvConv, projPointEnvConv); 
      if(isNewExtrema){
	double distFirst = (projPointEnvConv-projExtremF).norm(); 
	double distLast = (projPointEnvConv- projExtremL).norm(); 
	if(distFirst> distLast){
	  extremL = pointEnvConv;
	  projExtremL = projPointEnvConv;	  
	}else{
	  extremF = pointEnvConv;
	  projExtremF = projPointEnvConv;	 
	}
      }      
    }
  
  getSegmentBoundsFromExtremPt(extremF, extremL, pt1LongestSegment1, pt2LongestSegment1, 
                               pt3LongestSegment2, pt4LongestSegment2, minVisibleWidthBounds);  
}


template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
double 
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::getBasicLength(){
  InputPoint pt1, pt2, pt3, pt4;
  getBasicBounds(pt1, pt2, pt3, pt4);
  return (pt2-pt1).norm();
}



template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
double 
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::getRealLength(){
  InputPoint pt1, pt2, pt3, pt4;
  getRealBounds(pt1, pt2, pt3, pt4);
  return (pt2-pt1).norm();
}
  




template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
bool
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::projetOnStraightLine(const InputPoint & ptA,
                                                                                        const InputPoint & ptB,
                                                                                        const InputPoint & ptC,
                                                                                        InputPoint & ptProjected) const {
  
  InputPoint vAB (ptB[0]- ptA[0], ptB[1]- ptA[1]);
  InputPoint vAC (ptC[0]-ptA[0], ptC[1]-ptA[1]);
  
  double normeAB = vAB.norm();
  double normevAC = vAC.norm();
  
  double scalABAC = vAB.dot(vAC);
  double distPtA_Proj = scalABAC/normeAB;

  ptProjected[0]= ptA[0]+vAB[0]*(distPtA_Proj/normeAB);
  ptProjected[1] = ptA[1]+vAB[1]*(distPtA_Proj/normeAB);  
  return  (scalABAC>=0 && distPtA_Proj<=normeAB); 
}





///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions and external operators                 //

/**
 * Overloads 'operator<<' for displaying objects of class 'FuzzySegmentComputer'.
 * @param out the output stream where the object is written.
 * @param object the object of class 'FuzzySegmentComputer' to write.
 * @return the output stream after the writing.
 */
template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
std::ostream&
DGtal::operator<< ( std::ostream & out,
                    const FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar> & object )
{
  object.selfDisplay ( out );
  return out;
}

//                                                                           //
///////////////////////////////////////////////////////////////////////////////


