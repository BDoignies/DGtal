/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file FuzzySegmentComputer.ih
 * @author Bertrand Kerautret (\c kerautre@loria.fr )
 * LORIA (CNRS, UMR 7503), University of Nancy, France
 *
 * @date 2015/01/05
 *
 * Implementation of inline methods defined in FuzzySegmentComputer.h
 *
 * This file is part of the DGtal library.
 */

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
#include <limits>
//////////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////
// Implementation of inline methods                                          //
///////////////////////////////////////////////////////////////////////////////



// ----------------------- Standard services ------------------------------


//-----------------------------------------------------------------------------
template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::~FuzzySegmentComputer()
{ 
}



//-----------------------------------------------------------------------------
template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::FuzzySegmentComputer()
{ 
  myIsMelkmanInitialized = false;
  myIsValid = false;
}



//-----------------------------------------------------------------------------
template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::
FuzzySegmentComputer( const FuzzySegmentComputer & other )
{ // Nothing to do.
}

template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar> & 
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::
operator= ( const FuzzySegmentComputer & other )
{// Nothing to do.

}




//-----------------------------------------------------------------------------
template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
typename DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::Size
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::size() const 
{
  return myPointSet.size();
}


//-----------------------------------------------------------------------------
template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
bool
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::empty() const 
{
  return myPointSet.size()!=0;
}



//-----------------------------------------------------------------------------
template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
typename DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::ConstIterator
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::begin() const 
{
  return myPointSet.begin();

}



//-----------------------------------------------------------------------------
template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
typename DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::ConstIterator
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::end() const 
{
  return myPointSet.end();
}




//-----------------------------------------------------------------------------
template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
typename DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::Size
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::max_size() const 
{
  return myPointSet.max_size();
}




//-----------------------------------------------------------------------------
template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
typename DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::Size
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::maxSize() const 
{
  return myPointSet.max_size();
}







//-----------------------------------------------------------------------------
template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
void
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::
init(const typename DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::ConstIterator& it)  
{
  myIsValid = true;
  myBegin = it;
  myEnd = it;
  ++myEnd;
  melkmanAddPoint(*it);  
}


//-----------------------------------------------------------------------------
template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
bool
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::isExtendableFront() 
{
  return true;  
}



//-----------------------------------------------------------------------------
template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
bool
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::extendFront() 
{
  return true;  
}



//-----------------------------------------------------------------------------
template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
bool
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::isExtendableBack() 
{
  return true;  
}



//-----------------------------------------------------------------------------
template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
bool
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::extendBack() 
{
  return true;  
}




//-----------------------------------------------------------------------------
template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
typename DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::Primitive
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::primitive()  const
{
  return Primitive(0,0,0);  
}




//-----------------------------------------------------------------------------
template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
void
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::selfDisplay(std::ostream & out)  const
{
  out << "[Fuzzy Segment Computer]" ; 
}




//-----------------------------------------------------------------------------
template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
bool
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::isValid()  const
{
  return true;
}





//-----------------------------------------------------------------------------
template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
bool
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::melkmanIsWellInitialized()  const
{
  return true;
}


//-----------------------------------------------------------------------------
template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
double
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::melkmanMainDiagonal()  const
{
  /** Strategie is simple:
   *  Do the same thing than for height but with a correction due to 
   *  the diagonal.
   */
  int size = myMelkmanQueue.size();
  Point P, Q, R, S;
  Point q,s; /* [pq] is an edge and s a vertex */
  bool stop = false; /* Default is false */
  double tmpheight, k, dMinus, dPlus;
  double maxDoubleValue =  std::numeric_limits<int>::max();

  /* Take the first edge and find the corresponding point of support */
  P =  myMelkmanQueue[ 0 ] ;
  q = 1;
  Q = myMelkmanQueue[ q++ ] ;
  /** To find s, start at q+1 and move until angle between the edge at s 
   *  and the line pq is positive.
   */
  s = q;
  S = myMelkmanQueue[ s++ ];
  R = myMelkmanQueue[ s++ ];
  while( !stop )
  {
    /* Use vectorial product to ckeck angle */
    stop = ( ( R[0] - S[0] ) * ( Q[1] - P[1] ) - ( R[1] - S[1] ) * ( Q[0] - P[0] ) ) >= 0;
    /* If not stop, move forward */
    if( !stop )
    {
      S = R;
      R =  myMelkmanQueue[ s++ ];
    }
  }
  /* Initialize the diagonal distance */
  k = ( Q[1] - P[1] ) * S[0] - ( Q[0] - P[0] ) * S[1] - ( Q[1] * P[0] - Q[0] * P[1] );
  dMinus = fabs( k / (  ( Q[0] - P[0] ) + ( Q[1] - P[1] ) ) );
  dPlus = fabs( k / (  ( Q[0] - P[0] ) - ( Q[1] - P[1] ) ) );
  myConvexHullHeight = ( dPlus <= dMinus ) ? dPlus : dMinus;
  myEdgePh = P; myEdgeQh = Q; myVertexSh = S;
  /* We have found the first (edge,vertex) pair. Go on until cycling. */
  s--;   /* R is untouch */
  P = Q;
  Q = myMelkmanQueue[ q ] ;
  do
  {
    /** Rotate until one edge touch the border
     *  To do this, replicate the border and compute the sign of the angle
     */
    while( ( Q[0] - P[0] ) * ( R[1] - S[1] )  - ( Q[1] - P[1] ) * ( R[0] - S[0] ) >= 0 )
    {
      S = R;
      s = ( s + 1 ) % size;
      R = myMelkmanQueue[ s ] ;
    }
    /* Update height if necessary */
    k = ( Q[1] - P[1] ) * S[0] - ( Q[0] - P[0] ) * S[1] - ( Q[1] * P[0] - Q[0] * P[1] );
    if( ( Q[1] - P[1] ) - ( Q[0] - P[0] ) == 0 )
      dMinus = maxDoubleValue;
    else
      dMinus = fabs( k / (  ( Q[1] - P[1] ) - ( Q[0] - P[0] ) ) );
    if( ( Q[1] - P[1] ) + ( Q[0] - P[0] ) == 0 )
      dPlus = maxDoubleValue;
    else
      dPlus = fabs( k / (  ( Q[1] - P[1] ) + ( Q[0] - P[0] ) ) );
    /* Compute new diagonal distance / sqrt(2) */
    tmpheight = ( dPlus <= dMinus ) ? dPlus : dMinus;
    if( tmpheight < myConvexHullHeight )
    {
      myConvexHullHeight = tmpheight;
      myEdgePh = P; myEdgeQh = Q; myVertexSh = S;
    }
    /* Go to next point */
    P = Q;
    q = ( q + 1 ) % size;
    Q = myMelkmanQueue[ q ] ;
  }while( q != 0 );
  
  /* Fix width to an innaccessible value. */
  myConvexHullWidth = maxDoubleValue; 

  return 0.0;
}


//-----------------------------------------------------------------------------
template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
void
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::melkmanAddPoint(const Point &aPoint)
{
  myMelkmanQueue.push_back(aPoint);
  if (myMelkmanQueue.size() ==  3){
    melkmanInitCheck();
    return;
  }else if (myMelkmanQueue.size() < 3){
    return;
  }
  
  /** incrementally add an exterior vertex to the deque hull
   *  get the rightmore tangent at the deque bottom
   */
  if( myMelkmanQueue.size() == 3 && melkmanIsLeft( myMelkmanQueue[0], myMelkmanQueue[1], aPoint ) == 0 
      && melkmanIsLeft( myMelkmanQueue[1], myMelkmanQueue[2], aPoint ) == 0 )
    {
      myMelkmanQueue.pop_front();
      myMelkmanQueue.push_front( aPoint );
      myMelkmanQueue.pop_back();
      myMelkmanQueue.push_back( aPoint );
    }

  /* Test if next vertex is inside the deque Hull */
  else if( melkmanIsLeft( myMelkmanQueue[0], myMelkmanQueue[1], aPoint ) > 0
           && melkmanIsLeft( myMelkmanQueue[int(myMelkmanQueue.size())-2], myMelkmanQueue[int(myMelkmanQueue.size())-1], aPoint ) > 0 )
    return;   /* skip an interior vertex */
  else //if( IsLeft( D[0], D[1], P ) < 0 || IsLeft( D[n-2], D[n-1], P ) < 0 )
  {
     while( melkmanIsLeft( myMelkmanQueue[0], myMelkmanQueue[1], aPoint ) <= 0 )
       myMelkmanQueue.pop_front();    /* remove bottom of deque */

     myMelkmanQueue.push_front( aPoint );  /* insert id at bottom of deque */

     while( melkmanIsLeft( myMelkmanQueue[int(myMelkmanQueue.size())-2], myMelkmanQueue[int(myMelkmanQueue.size())-1], aPoint ) <= 0 )
       myMelkmanQueue.pop_back();     /* pop top of deque */

     myMelkmanQueue.push_back( aPoint );   /* push id onto top of deque */
  }
}



template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
void
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::
melkmanInitCheck() 
{
  Point aPoint1 = myMelkmanQueue[0];
  Point aPoint2 = myMelkmanQueue[1];
  Point aPoint3 = myMelkmanQueue[2];
  myMelkmanQueue.clear();

  if( melkmanIsLeft( aPoint1, aPoint2, aPoint3 ) == 0.0 )
    {
      myMelkmanQueue.push_back(aPoint3);
      myMelkmanQueue.push_back(aPoint1);
      myMelkmanQueue.push_back(aPoint3);
    }
  else
  {
    myMelkmanQueue.push_front(aPoint3);
    if( melkmanIsLeft( aPoint1, aPoint2, aPoint3 ) > 0 )      /* ccw vertices are: 2,0,1,2 */
    {
      myMelkmanQueue.push_back(aPoint1);
      myMelkmanQueue.push_back(aPoint2); 
    }
    else                                /* ccw vertices are: 2,1,0,2 */
    {
      myMelkmanQueue.push_back(aPoint2);
      myMelkmanQueue.push_back(aPoint1); 
    }  
    myMelkmanQueue.push_back(aPoint3);
  }   
}





//-----------------------------------------------------------------------------
template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
bool
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::melkmanIsConvexValid(const std::deque<int> & D , float thick) const
{
  return true;
}


//-----------------------------------------------------------------------------
template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
TInternalScalar
DGtal::FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar>::melkmanIsLeft(const Point &aP0, const Point &aP1, const Point &aP2) const
{
  return (aP1 - aP0).dot(aP2 - aP0);
}















///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions and external operators                 //

/**
 * Overloads 'operator<<' for displaying objects of class 'FuzzySegmentComputer'.
 * @param out the output stream where the object is written.
 * @param object the object of class 'FuzzySegmentComputer' to write.
 * @return the output stream after the writing.
 */
template <typename TSpace, typename TInputPoint, typename TInternalScalar>
inline
std::ostream&
DGtal::operator<< ( std::ostream & out,
                    const FuzzySegmentComputer<TSpace, TInputPoint, TInternalScalar> & object )
{
    object.selfDisplay ( out );
    return out;
}

//                                                                           //
///////////////////////////////////////////////////////////////////////////////


