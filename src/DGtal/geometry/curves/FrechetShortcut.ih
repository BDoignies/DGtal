/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file FrechetShortcut.ih
 * @author Isabelle Sivignon (\c isabelle.sivignon@gipsa-lab.grenoble-inp.fr )
 * gipsa-lab Grenoble Images Parole Signal Automatique (CNRS, UMR 5216), CNRS, France
 *
 * @date 2012/02/24
 *
 * Implementation of inline methods defined in FrechetShortcut.h
 *
 * This file is part of the DGtal library.
 */

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////
// Subclass backpath
////////////////////////////////////////////////////////////////




//creation of a backPath
// Default constructor
template <typename TIterator, typename TInteger>
inline
DGtal::FrechetShortcut<TIterator, TInteger>::backpath::backpath()
{
  myQuad = 0;
  myFlag = false;
}


//creation of a backPath
template <typename TIterator, typename TInteger>
inline
DGtal::FrechetShortcut<TIterator, TInteger>::backpath::backpath(const FrechetShortcut<TIterator,TInteger> *s,int q): myS(s),myQuad(q),myFlag(false)  
{
}

template <typename TIterator, typename TInteger>
inline
void DGtal::FrechetShortcut<TIterator, TInteger>::backpath::reset()
{
  myFlag = false;
  myOcculters.clear();
  myForbiddenIntervals.clear();
}


//destruction of a backPath
template <typename TIterator, typename TInteger>
inline
DGtal::FrechetShortcut<TIterator, TInteger>::backpath::~backpath()              
{ }      

template <typename TIterator, typename TInteger>
inline
void DGtal::FrechetShortcut<TIterator, TInteger>::backpath::updateBackPathFirstQuad(int d, const ConstIterator& it)
{  
  
  myIt = it;
  //myIt = (myS->myEnd) + 1;

  //std::cerr << Point(*((myS->myEnd) + 1));
  
  //trace.info() << "local frame direction " << d  << std::endl;
  switch(d)
    {    
    case 0:
    case 1:
    case 2:
    case 7:
      {
	//this->addPositivePoint();
	addPositivePoint();
	break;
      }
    case 3:
    case 4:
    case 5:
    case 6:
      {
	//this->addNegativePoint();
	addNegativePoint();
	break; 
      }
    }
}

// update the list of active occulters 
template <typename TIterator, typename TInteger>
inline
void DGtal::FrechetShortcut<TIterator,  TInteger>::backpath::updateOcculters()
{
  //   if(quad==0)
  //     {
  //std::cerr << "Quad " << myQuad << Point(*myIt) << std::endl;
  
  //     }
  
  // The potential new occulter is the last-but-one point
  Point p = Point(*(myIt-1));
  //Point p = Point(*(myS->myEnd));
  
  //std::cerr << p << std::endl;

  Point pi,v;
  Vector dir = Tools::chainCode2Vect(myQuad);
  Vector dir_ortho = Tools::chainCode2Vect((myQuad+6)%8);
  
  //std::cerr << dir << std::endl;

  Point u1,u2;
  u1 = dir;
  u2 = Tools::chainCode2Vect((myQuad+1)%8);;
  
  double angle_min=0;
  double angle_max=M_PI_4;
  bool ok = true;
  bool occ = false;
  //   if(quad==0)
  //     {
  //std::cerr << p << " " << u1 << " " << u2 << std::endl;
  //       //std::cerr << *this << std::endl;
  //     }
  if(myOcculters.size()==0)
    {
      occ =true;
      angle_min=0;
      angle_max=M_PI_4;
    }
  else
    {
      typename occulter_list::iterator iter;
      
      for(iter = myOcculters.begin();ok && iter!=myOcculters.end() ;++iter)	
	{
	  pi = Point(*(iter->first));
	  //pi = dataPoints[iter->first];
	  v = p-pi;
	  //  if(quad==0)
	  // 	std::cerr << pi << std::endl;
	  
	  // pi is after p for all directions -> p is not an occulter
	  if(Tools::scalar_product(v,u1) < 0 && Tools::scalar_product(v,u2) < 0)
	    {
	      //  if(quad==0)
	      // 	    std::cerr << "p occulted by pi" << std::endl;
	      
	      ok = false; 
	      occ = false;
	    }
	  else
	    // p is after pi for all directions -> pi is not an occulter
	    // anymore, p is a new occulter.
	    if(Tools::scalar_product(v,u1) > 0 && Tools::scalar_product(v,u2) > 0)
	      {
		//   if(quad==0)
		// 	      std::cerr << "pi occulted by p" << std::endl;
		myOcculters.erase(iter);
		occ = true;
		angle_min = 0;
		angle_max = M_PI_4;
	      }
	    else
	      // p is after pi on [0,alpha], before pi on [alpha,pi/4]
	      if(Tools::scalar_product(v,u1) > 0 && Tools::scalar_product(v,u2) <= 0)
		{
		  double alpha = Tools::angleVectVect(v,dir_ortho);
		  //    if(quad==0)
		  // 		std::cerr << "p after pi on [0," << alpha << "]" << std::endl;
		  if(alpha >= iter->second.angle_min && alpha <=
		     iter->second.angle_max)
		    {
		      // p is a new occulter
		      occ = true;
		      angle_min = 0;
		      angle_max = alpha;
		      // pi's angle_min is updated
		      iter->second.angle_min = alpha;
		    }
		  else
		    if(alpha > iter->second.angle_max)
		      {
			//pi is not an occulter anymore 
			myOcculters.erase(iter);
			occ=true;
			angle_min = 0;
			angle_max = M_PI_4;
		      }
		  // if alpha < iter->second.angle_min, pi does not
		  // change, p may be an occulter -> do nothing
		} 
	      else // scalar_product(v,u1) < 0 && scalar_product(v,u2) > 0
		// p is after pi on [alpha,pi/4], before pi on [0,alpha]
		{
		  double alpha = Tools::angleVectVect(v,dir_ortho);
		  alpha = M_PI - alpha;
		  //    if(quad==0)
		  // 		std::cerr << "p after pi on [" << alpha << ",pi/4]" << std::endl;
		  
		  if(alpha >= iter->second.angle_min && alpha <=
		     iter->second.angle_max)
		    {
		      occ = true;
		      angle_min = alpha;
		      angle_max = M_PI_4;
		      // pi's angle_max is updated
		      iter->second.angle_max = alpha;
		    }
		  else
		    if(alpha < iter->second.angle_min)
		      {
			//pi is not an occulter anymore 
			myOcculters.erase(iter);
			occ=true;
			angle_min = 0;
			angle_max = M_PI_4;
		      }
		  // if(alpha > iter->second.angle_max), pi does not
		  // change, p may be an occulter -> do nothing
		  
		}
	}
    }
  
  if(occ)
    {
      occulter_attributes new_occ;
      new_occ.angle_min = angle_min;
      new_occ.angle_max = angle_max;
      myOcculters.insert(myOcculters.end(),pair<const ConstIterator,occulter_attributes>(myIt-1,new_occ));
      //myOcculters.insert(myOcculters.end(),pair<const ConstIterator,occulter_attributes>(myS->myEnd,new_occ));
      //myOcculters.insert(myOcculters.end(),pair<int,occulter_attributes>(ind,new_occ));
      //    if(quad==0)
      // 	{
      // 	  std::cerr << "one occulter added " << std::endl;
      // 	}
    }
  
  //trace.info() << "end add occulters" << std::endl;

}



// update the set of intervals
template <typename TIterator, typename TInteger>
inline
void DGtal::FrechetShortcut<TIterator,  TInteger>::backpath::updateIntervals()
{
  Point p = Point(*myIt);
  //Point p = Point(*(myS->myEnd+1));
  //vector <int> p = dataPoints[ind];
  Point pi,v;
  Vector dir,dir1;
  
  for(typename occulter_list::iterator iter =
	myOcculters.begin(); iter!=myOcculters.end() ;++iter)	
    {
      pi = Point(*(iter->first));
      //pi = dataPoints[iter->first];
      v = p-pi;
      
      dir = Tools::chainCode2Vect(myQuad);
      dir1 = Tools::chainCode2Vect((myQuad+1)%8);
      if(Tools::scalar_product(v,dir)<0 || Tools::scalar_product(v,dir1)<0)
	{
	  // if(quad==0)
	  //   {
	  // std::cerr << "p = " << p << std::endl;
	  // std::cerr << "pi = " << pi << std::endl;
	  // std::cerr << "v = " << v << std::endl;
	  // std::cerr << "norm(v) = " << norm(v) << std::endl;
	  //   }
	  
	  if(v.norm()>=myS->myError/sqrt(2.0F))
	    { 
	      if(Tools::determinant(dir,v)<=0)
		{
		  v[0] = -v[0];
		  v[1] = -v[1];
		}
	      double angle_v = Tools::angleVectVect(v,dir);
	      // if(quad==0)  std::cerr << "angle_v " << angle_v <<
	      //	     std::endl;

	      double tmp = acos((double) myS->myError/(sqrt(2.0F)*v.norm()));
	      double angle1 = -tmp+angle_v;
	      double angle2 = tmp+angle_v;
	      //if(quad==0) std::cerr << angle1 << " " << angle2 << std::endl;
	      if(angle1 < 0)
		angle1 = 0;
	      if(angle2 > M_PI_4)
		angle2 = M_PI_4;
	      
	      // Define a new interval of forbidden angles and insert it in the list.
	      boost::icl::interval<double>::type s = boost::icl::interval<double>::closed(angle1,angle2);
	      myForbiddenIntervals.insert(s);
	      	      
	      
	      //if(quad==0) cout << "intervals =" << forbiddenIntervals.as_string() << endl;
	    }
	}
    }

  // std::cerr << "nb intervals " << forbiddenIntervals.interval_count() << std::endl;
  
}


// update the length of the longest backpath on a curve part
template <typename TIterator, typename TInteger>
inline
void DGtal::FrechetShortcut<TIterator, TInteger>::backpath::addPositivePoint()
{
  // if we were on a monotone backpath, the point is an end of backpath
  // otherwise, do nothing
  //trace.info() << "add positive point" << std::endl;
  if(myFlag)
    {
      //if(quad==0)
      //std::cerr << "end of a backpath" << std::endl;
      myFlag=false;
    }
}



/************************************************************/

 
template <typename TIterator, typename TInteger>
inline
void DGtal::FrechetShortcut<TIterator,  TInteger>::backpath::addNegativePoint()
{
  
  // if we were on a monotone backpath, do nothing, the backpath
  // continues
  // otherwise it is the beggining of a new monotone backpath,
  // possibly a locally maximal occulting point
  
  //trace.info() << "add negative point" << std::endl;
  
  if(!myFlag)
    {
      myFlag=true;
      updateOcculters();
      updateIntervals(); 
    }
  else
    {
      updateIntervals();
    }
  

}



///////////////////////////////////////////////////////////////////////////////
// Implementation of inline methods                                          //

template <typename TIterator, typename TInteger>
inline
DGtal::FrechetShortcut<TIterator,TInteger>::FrechetShortcut()
{
  myError = 0;
  myCone = cone();
  
  for(int i=0;i<8;i++)
    {
      //backpath b(i,0);
      backpath b(this,i);
      myBackpath.push_back(b);
    }

}


template <typename TIterator, typename TInteger>
inline
DGtal::FrechetShortcut<TIterator,TInteger>::FrechetShortcut(double error)
{
  myError = error;
  myCone = cone();
  
  for(int i=0;i<8;i++)
    {
      //backpath  b(i,error);
       backpath b(this,i);
       myBackpath.push_back(b);
    }
}




template <typename TIterator, typename TInteger>
inline
void DGtal::FrechetShortcut<TIterator,TInteger>::init(const ConstIterator& it)
{
  myBegin = it;
  myEnd = it;
  resetCone();
  resetBackpath();
}


template <typename TIterator, typename TInteger>
inline
DGtal::FrechetShortcut<TIterator,TInteger>  DGtal::FrechetShortcut<TIterator,TInteger>::getSelf()
{
  FrechetShortcut<TIterator,TInteger> other = FrechetShortcut(myError);
  return other;
}


template <typename TIterator, typename TInteger>
inline
DGtal::FrechetShortcut<TIterator,TInteger>::FrechetShortcut (const FrechetShortcut<TIterator,TInteger> & other ) : myBackpath(other.myBackpath), myCone(other.myCone),  myError(other.myError), myBegin(other.myBegin), myEnd(other.myEnd){    
  resetBackpath();
  resetCone();
  
}

template <typename TIterator, typename TInteger>
inline
DGtal::FrechetShortcut<TIterator,TInteger> & DGtal::FrechetShortcut<TIterator,TInteger>::operator=(const FrechetShortcut<TIterator,TInteger> & other)
{
  
  if(this != &other)
    {
      myError = other.myError;
      myBackpath = other.myBackpath;
      myCone = other.myCone;
      myBegin = other.myBegin;
      myEnd = other.myEnd;
    }
  return *this;
}

template <typename TIterator, typename TInteger>
inline
DGtal::FrechetShortcut<std::reverse_iterator<TIterator>,TInteger>
DGtal::FrechetShortcut<TIterator,TInteger>
::getReverse() const
{
  return Reverse(myError);
}

template <typename TIterator, typename TInteger>
inline
bool
DGtal::FrechetShortcut<TIterator,TInteger>::operator==(
 const DGtal::FrechetShortcut<TIterator,TInteger>& other) const {
   return ((myBegin == other.myBegin) && (myEnd == other.myEnd) && (myError == other.myError));
}



template <typename TIterator, typename TInteger>
inline
bool
DGtal::FrechetShortcut<TIterator,TInteger>::operator!=(
						       const DGtal::FrechetShortcut<TIterator,TInteger>& other) const {
  return (!(*this == other));
}


template <typename TIterator, typename TInteger>
inline
bool
DGtal::FrechetShortcut<TIterator,TInteger>::extendForward()
{
  bool flag = (updateWidth() && updateBackpath());
  
  if(flag)
    ++myEnd;
  
  return flag;
}


template <typename TIterator, typename TInteger>
inline
bool
DGtal::FrechetShortcut<TIterator,TInteger>::isExtendableForward()
{
  
  return (testUpdateWidth() && testUpdateBackpath());
  
}

template <typename TIterator, typename TInteger>
inline
cone FrechetShortcut<TIterator,TInteger>::computeNewCone()
{
  double x0, y0,x1,y1;

  Point firstP = Point(*myBegin);
  Point newP = Point(*(myEnd+1));

  
  cone newCone=myCone;
  
  // compute the tangent points defined by the first point and the
  // circle C(newP,error)
  bool intersect = cone::Tools::circleTangentPoints(firstP[0],firstP[1], newP[0], newP[1], myError/(sqrt(2.0F)), &x0, &y0,
				       &x1, &y1);
  
  if(intersect)
    {
      // define a cone according to the new tangent points
      cone c;
      // case where there is one single tangent point
      if(fabs(x0-x1) < 0.00001 && fabs(y0-y1) < 0.00001)
	{
	  double angle = cone::Tools::computeAngle(firstP[0],firstP[1],newP[0],newP[1]);
	  double angle0 = angle - M_PI_2;
	  if(angle0<0)
	    angle0 = angle0+2*M_PI;
	  double angle1 = angle + M_PI_2;
	  if(angle1>2*M_PI)
	    angle1 = angle1-2*M_PI;
	  c = cone(angle0,angle1);
	}
      else
	c = cone(firstP[0],firstP[1],x0,y0,x1,y1);
      
      newCone.intersectCones(c); 
    }
  
  return newCone;

}

// Test if the new direction belongs to the new cone, but does not
// modify myCone
template <typename TIterator, typename TInteger>
inline
bool FrechetShortcut<TIterator,TInteger>::testUpdateWidth()
{
  cone c = computeNewCone();
  
  Point firstP = Point(*myBegin);
  Point newP = Point(*(myEnd+1));

  if(!(c.isEmpty()))
    if(c.myInf)
      return true;
    else
      {
	double angle = cone::Tools::computeAngle(firstP[0], firstP[1], newP[0],
				    newP[1]);
	return cone::Tools::isBetween(angle,c.myMin,c.myMax,2*M_PI);
      }
  else
    return false;
  
}

// Same as testUpdateWidth() but myCone is modified.
template <typename TIterator, typename TInteger>
inline
bool FrechetShortcut<TIterator,TInteger>::updateWidth()
{
  cone c = computeNewCone();
  
  myCone = c;
  
  Point firstP = Point(*myBegin);
  Point newP = Point(*(myEnd+1));

  bool flag = true;
  
  if(!(c.isEmpty()))
    if(c.myInf)
      flag = true;
    else
      {
	double angle = cone::Tools::computeAngle(firstP[0], firstP[1], newP[0],
						 newP[1]);
	flag = cone::Tools::isBetween(angle,c.myMin,c.myMax,2*M_PI);
      }
  else
    flag = false;
  
  //trace.info() << "width " << flag << std::endl;
  return flag;
}

template <typename TIterator, typename TInteger>
inline
bool FrechetShortcut<TIterator,TInteger>::updateBackpath()
{
  Point prevP = Point(*myEnd);
  Point P = Point(*(myEnd+1));
  
  int d = Tools::computeChainCode(prevP,P);
  
  for(unsigned int j=0;j<8;j++)
    {
      //std::cerr << "#############" << std::endl;
      //std::cerr << "Quadrant " << j <<  std::endl;
      
      //myBackpath[j].updateBackPathFirstQuad(Tools::rot(d,j),myEnd+1);
      myBackpath[j].updateBackPathFirstQuad(Tools::rot(d,j),myEnd+1);
      //std::cerr << "************** Quad " << j << "************" << std::endl;
      
      
    }
  
  //trace.info() << "backpath " << isBackpathOk() << std::endl;
  return isBackpathOk();
  
}

template <typename TIterator, typename TInteger>
inline
bool FrechetShortcut<TIterator,TInteger>::isBackpathOk()
{
  // compute the quadrant of the direction of P(i,j)
  
  Point firstP = Point(*myBegin);
  Point P = Point(*(myEnd+1));
  
  int q = Tools::computeQuadrant(firstP,P);
  
  //std::cerr << "*** IndexBegin " << indexBegin << " ***Index " << i << " ***Quadrant " << q << std::endl;
  //std::cerr << dataPoints[indexBegin] << " " << dataPoints[i] << std::endl;
  
  // to handle non simple curves (a point is visited twice)
  if(firstP==P)
    return true;
  
  // compute the direction vector pipj
  Point v;
  v[0] = P[0]-firstP[0];
  v[1] = P[1]-firstP[1];
  
  // compute the angle between the direction vector and the elementary
  // direction (defined by the quadrant)
  Point dir_elem = Tools::chainCode2Vect(q);
  
  double angle = Tools::angleVectVect(v,dir_elem);
  //std::cerr << "direction=" << v << " angle=" << angle << std::endl;

  bool ok = true;
  bool end = false;
  
  boost::icl::interval_set<double> intervals = myBackpath[q].myForbiddenIntervals;

  //trace.info() << intervals << " angle " << angle << endl;
  
  if(contains(intervals,angle))
    return false;
  
  return true;
  
}


template <typename TIterator, typename TInteger>
inline
void FrechetShortcut<TIterator,TInteger>::resetBackpath()
{
  for(unsigned int i=0;i<8;i++)
    {
      myBackpath[i].reset();
    }
}

template <typename TIterator, typename TInteger>
inline
void FrechetShortcut<TIterator,TInteger>::resetCone()
{
  myCone.myMin = 0;
  myCone.myMax = 0;
  myCone.myInf = true;  
}


template <typename TIterator, typename TInteger>
inline
TIterator
DGtal::FrechetShortcut<TIterator,TInteger>::begin() const {
  return myBegin;
}

template <typename TIterator, typename TInteger>
inline
TIterator
DGtal::FrechetShortcut<TIterator,TInteger>::end() const {
  ConstIterator i(myEnd); ++i;
  return i;
}



template <typename TIterator, typename TInteger>
inline
std::string
DGtal::FrechetShortcut<TIterator,TInteger>::className() const
{
  return "FrechetShortcut";
}



/**
 * Writes/Displays the object on an output stream.
 * @param out the output stream where the object is written.
 */

template <typename TIterator, typename TInteger>
inline
void
FrechetShortcut<TIterator,TInteger>::selfDisplay ( std::ostream & out) const
{
  
  out << "[FrechetShortcut]" <<  endl;
  out << "(Begin, End)=";
  out << "("<< Point(*myBegin) << ", " << Point(*myEnd) << ")\n";
  out << "[End FrechetShortcut]" <<  endl;
  
}

// Implementation of inline functions                                        //

template <typename TIterator, typename TInteger>
inline
std::ostream&
DGtal::operator<< ( std::ostream & out, 
		    const FrechetShortcut<TIterator,TInteger> & object )
{
  object.selfDisplay( out );
  return out;
}




//                                                                           //
///////////////////////////////////////////////////////////////////////////////


