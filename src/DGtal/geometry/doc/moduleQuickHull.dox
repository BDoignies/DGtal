
/* 
 * Useful to avoid writing DGtal:: in front of every class.
 */
namespace DGtal {

/**
   
@page moduleQuickHull QuickHull algorithm in arbitrary dimension for convex hull and Delaunay cell complex computation

@writers Jacques-Olivier Lachaud

@since 1.2

Part of the \ref packageGeometry.
  
This part of the manual describes the DGtal implementation of the
famous "QuickHull" algorithm by Barber et al. \cite barber1996 , and
how to use it to compute convex hulls and Delaunay convex cell
decompositions.

[TOC]


The following programs are related to this documentation:
testQuickHull.cpp

@section dgtal_quickhull_sec1 The QuickHull convex hull algorithm

The objective of the QuickHull algorithm is to compute the convex hull
of a set of points \a V lying in a space of arbitrary dimension \a d (here
\a d is greater than one). This algorithm has the limitation to
process only full dimensional convex hulls, because of the way it is
initialized. It maintains and updates a list of facets (which defines
the faces of the current polytope) by following these steps:

1. Initialization: an initial \a d-dimensional simplex is built with
\f$ d+1 \f$ facets. Furthermore, each remaining point of \a V is
associated to one of these facets if it is \b above it. Hence, each
point of \a V is either associated to no facet and is thus already
inside the current hull, or it is associated to only one facet.
Points \b on each facet and \b neighbors of facets are computed (easy
for a simplex) and all the facets are then queued.

2. While the queue of facet is not empty, the front facet \a f is popped.
   - ignore it if contains no "above" point(s)
   - otherwise pick the furthest above point \a p
   - find by neighbor adjacencies from \a f all the facets visible from \a p (i.e. \a p is above them)
   - define the horizon H as the set of ridges R, where a ridge is a pair of two neighbor facets, where the first is visible from \a ^, whilst the second is not.
   - define the new facets as the ones formed by the umbrella from \a p to its ridges.
   - merge possible parallel facets and update "on" points
   - reassign "above" points of \a f to these new facets and put them into the queue

3. The algorithm stops when all current facets have no "above" points.

4. Optionnaly extract vertices of the convex hull polytopes by
determining the "on" points that belong to at least \a d facets.

@note In opposition with the usual QuickHull implementation, this
class uses a kernel that can be chosen in order to provide exact
computations. This is the case for lattice points, but also rational
points. Computation times are very similar.

@note In opposition with CGAL `3D convex hull` package, or with the
arbitrary dimensional `dD Triangulation` package, this algorithm does
not build a simplicial convex hull. Facets may not be triangles or
simplices in higher dimensions. This happens frequently for lattice
points, where coplanar and cospherical situations are common.

@note This version is generally more than twice faster than CGAL
convex_hull_3 for the usual CGAL kernels Cartesian and
Exact_predicates_inexact_constructions_kernel.

@note However this implementation is not tailored for incremental
dynamic convex hull computations.

@note Last, the method for computing the Delaunay triangulation by
using the convex hull in a higher dimensional space is generally much
slower than CGAL method for computing the Delaunay triangulation by
point location.

@section dgtal_quickhull_sec2 Computing convex hulls and Delaunay cell complex using QuickHull

In order to get a fine control over convex hull computations, you can
use class QuickHull directly. It is required to choose a \b kernel
specific to your objective. For now, the available kernels are:

- \ref ConvexHullIntegralKernel : it allows the computation of the
  convex hull of a range of lattice points in arbitrary dimension.

- \ref ConvexHullRationalKernel : it allows the computation of the
  convex hull of a range of rational points in arbitrary
  dimension. The user fixes the precision at kernel instantiation.

- \ref DelaunayIntegralKernel : it allows the computation of the
  Delaunay cell complex of a range of lattice points in arbitrary
  dimension.

- \ref DelaunayRationalKernel : it allows the computation of the
  Delaunay cell complex of a range of rational points in arbitrary
  dimension. The user fixes the precision at kernel instantiation.


@subsection dgtal_quickhull_sec21 Convex hull of lattice points

To compute the convex hull of lattice points, you need to include `QuickHull.h`.

\snippet geometry/tools/exampleLatticeBallQuickHull3D.cpp QuickHull3D-Includes

You should then define some typedefs:

\snippet geometry/tools/exampleLatticeBallQuickHull3D.cpp QuickHull3D-Typedefs

Then we assume that \a V contains a range of lattice 3D points (with
either 32 bits or 64 bits precision). You may compute their convex
hull (facets and vertices) with (QuickHull::setInput and QuickHull::computeConvexHull):

\snippet geometry/tools/exampleLatticeBallQuickHull3D.cpp QuickHull3D-Computation

You may check computation times with (QuickHull::timings)

\snippet geometry/tools/exampleLatticeBallQuickHull3D.cpp QuickHull3D-Timings

You can easily retrieves the vertex positions with
QuickHull::getVertexPositions (you can put them in a vector of real or
lattice points), and retrieves the consistently oriented vertices for
each face with QuickHull::getFacetVertices. Below we show how to build
a SurfaceMesh that represents the convex hull boundary and save it as
OBJ file.

\snippet geometry/tools/exampleLatticeBallQuickHull3D.cpp QuickHull3D-BuildMesh

\snippet geometry/tools/exampleLatticeBallQuickHull3D.cpp QuickHull3D-OutputMesh

<table>
<tr>
<td> 
\image html qhull-lattice-ball-12_5.png "Convex hull of lattice ball with radius 12.5"
</td><td> 
\image html qhull-lattice-ball-25.png "Convex hull of lattice ball with radius 25"
</td><td> 
\image html qhull-lattice-ball-50.png "Convex hull of lattice ball with radius 50"
</td>
</tr>
</table>

@note To give an idea of computation times, for 1e7 lattice points randomly chosen in a ball of radius 1000, computations times are as follows on a Macbook pro (processor 2,7 GHz Quad-Core Intel Core i7, memory 16 GB 2133 MHz LPDDR3):

\verbatim
/tools/exampleLatticeBallQuickHull3D 10000000 1000

#points=9990515 #vertices=14183 #facets=28036
purge duplicates= 4221 ms.
init simplex    = 223 ms.
quickhull core  = 3214 ms.
compute vertices= 255 ms.
total time      = 7913 ms.
\endverbatim
 
@note Half of the time is spent on removing duplicated input
points. If you know that your range of points does not contain
duplicates, you can specify it to QuickHull::setInput.

*/

} //  namespace DGtal
