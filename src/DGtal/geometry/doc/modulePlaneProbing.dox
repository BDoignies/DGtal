/**
 * @file
 * @author Jocelyn Meyron (\c jocelyn.meyron@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Systemes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 *
 * @date 2020/12/18
 *
 * Documentation file for feature PlaneProbing
 *
 * This file is part of the DGtal library.
 */

/*
 * Useful to avoid writing DGtal:: in front of every class.
 */
namespace DGtal {
//----------------------------------------
/*!
@page modulePlaneProbing Plane-probing based normal estimators
@writers Jacques-Olivier Lachaud, Jocelyn Meyron, Tristan Roussillon

@since 1.2

Part of the \ref packageGeometry.

This part of the manual describes what are plane-probing estimators and how to define and use them
to estimate normals on digital surfaces.

[TOC]

The following programs are related to this documentation:
geometry/surfaces/examplePlaneProbingParallelepipedEstimator.cpp,
geometry/surfaces/examplePlaneProbingTetrahedronEstimator.cpp,
geometry/surfaces/examplePlaneProbingSurfaceLocalEstimator.cpp,
testDigitalPlanePredicate.cpp,
testPlaneProbingTetrahedronEstimator.cpp,
testPlaneProbingParallelepipedEstimator.cpp.

\section sectPlaneProbing1 Introduction to plane-probing algorithms

A plane-probing algorithm @cite LPRJMIV2017 @cite RLDGCI2019 @cite LMRJMIV2020
computes the normal vector of a set of digital points
from a starting point and a predicate "Is a point x in the set of digital points?" that
we will denote \b InPlane.
This predicate is used to probe the set as locally as possible
and decide on-the-fly the next points to consider,
in order to deform a specific set, which is tangent by
construction. The growth direction is given by both arithmetic and
geometric properties. The main characteristics of these
algorithms is that \e no \e parameter is required for the analysis
of the local geometry of digital surfaces. Furthermore, they present
theoretical guarantees, most notably they extract the exact normal
vector of any digital plane.

@image html plane-probing-illustration.png "Left: a digital plane segment. Right: Estimated normal vectors in blue using plane probing"
@image latex plane-probing-illustration.png "Left: a digital plane segment. Right: Estimated normal vectors in blue using plane probing" width=7cm

\subsection subsectPlaneProbing11 Tetrahedron-based probing methods (H, R, R1)

The first kind of plane-probing algorithms is based on a deformation of a tetrahedron, tangent to the digital set.

The main drawback of this kind is the fact that they return the correct on a digital plane only when starting from a reentrant corner. In all other cases, the estimated normal is only an approximation.
In the next section, we will present another kind of estimator that can be initialized on \e any \e surfel of a digital surface and which returns the correct normal on every surfel of a digital plane.

\subsection subsectPlaneProbing12 Parallelpiped-based probing methods (PH, PR, PR1)

The second kind of plane-probing algorithms is based on the deformation of a pair of tetrahedra i.e. a parallelepiped introduced in @cite LMRJMIV2020. The parallelepiped is ensured to always be separating (the base point and the 'fixed' point \f$ q \f$ are inside/outside or
outside/inside the digital set). This approach allows to start the algorithm on any surfel (at least 4 points inside the digital set).

This approach is internally based on a generalization of the predicate \b InPlane that we call \b NotAbove.
See @cite LMRJMIV2020 for more details.

\subsection subsectPlaneProbing13 Summary

| Algorithm |           Principle           |    Initialization    |     Candidate Set     |
|:---------:|:-----------------------------:|:--------------------:|:---------------------:|
|     H     | Downward oriented tetrahedron | Any reentrant corner | 6 points in a hexagon |
|   R, R1   | Downward oriented tetrahedron | Any reentrant corner | 6 points + 6 rays     |
|     PH    | Separating parallelpiped      | Any surfel           | 6 points in a hexagon |
|  PR, PR1  | Separating parallelpiped      | Any surfel           | 6 points + 6 rays     |

\section sectPlaneProbing2 Constructing and using a plane-probing estimator

\subsection subsectPlaneProbing21 General form

In DGtal, both categories of plane-probing estimators are implemented, see \ref PlaneProbingTetrahedronEstimator and \ref PlaneProbingParallelepipedEstimator.
In the following, PlaneProbingEstimator will be one of these two types.

The general way of instantiating and using a plane-probing estimator is the folllowing
\code
using namespace DGtal;

// To define the type of the estimator, we need the following types:
// - Predicate: it is a model of concepts::PointPredicate, see DigitalPlanePredicate or DigitalSurfacePredicate,
// - ProbingMode: it is one of { ProbingMode::H, ProbingMode::R, ProbingMode::R1 }.
using ProbingEstimator = PlaneProbingEstimator<Predicate, ProbingMode>;

// To instantiate it:
// - (startingPoint, initialFrame) is a point and a triplet of vectors representing the initial tetrahedron,
// - predicate describes the digital set you want to probe.
ProbingEstimator estimator(startingPoint, initialFrame, predicate);
\endcode

The common services are as follows:
- PlaneProbingEstimator::m returns the three vectors defining the tetrahedron.
- PlaneProbingEstimator::q returns the fixed point.
- PlaneProbingEstimator::getOrigin returns the base point of the frame.
- PlaneProbingEstimator::vertices returns the three vertices \f$ (q - m_k)_{0 \leq k \leq 2} \f$.

Probing services:
- PlaneProbingEstimator::advance does one step of the estimation.
- PlaneProbingEstimator::compute repeatedly calls advance until a final configuration is found.
- PlaneProbingEstimator::getBasis returns the two shortest edges of the base triangte.
- PlaneProbingEstimator::isReduced tells whether the vectors returned by getBasis form a reduced basis or not.
- PlaneProbingEstimator::getNormal returns the current normal vector.

Specific to PlaneProbingParallelepipedEstimator:
- PlaneProbingParallelepipedEstimator::getState returns the number of points that are inside the digital set according to \b InPlane.
- PlaneProbingParallelepipedEstimator::isSeparating returns a boolean testing whether the current parallelpiped is separating or not.
- PlaneProbingParallelepipedEstimator::isInReverseState returns a boolean saying whether the current parallelpiped is in a reverse state or not.

\subsection subsectPlaneProbing22 On a digital surface

The PlaneProbingDigitalSurfaceLocalEstimator adapter can use any plane-probing estimator class to estimate normals on a digital surface. It is a model of concepts::CSurfelLocalEstimator and concepts::CDigitalSurfaceLocalEstimator.

The definition and instantiation is done as follows:
\code
// Definition
using ProbingAlgorithm = PlaneProbingEstimator<Predicate, ProbingMode>;
using Estimator        = PlaneProbingDigitalSurfaceLocalEstimator<Surface, ProbingAlgorithm>;

// Instantiation
Integer bound = 60; // The bound appearing in the NotAbove predicate

// We define a factory function that returns a pointer to a plane-probing estimator for a given frame
// It is called for every surfel
Estimator::ProbingFactory probingFactory = [&bound](const Estimator::ProbingFrame& frame, const Predicate& predicate) {
    return new ProbingAlgorithm(frame.p, { frame.b1, frame.b2, frame.normal }, predicate); // for PlaneProbingTetrahedronEstimator
    return new ProbingAlgorithm(frame.p, { frame.b1, frame.b2, frame.normal }, predicate, bound); // for PlaneProbingParallelepipedEstimator
};

Estimator estimator(  surface        // the digital surface
                    , probingFactory // the factory function
                    , preEstimations // a std::unordered_map of pre-estimations (empty by default), see the details below
                    , verbose);

// Usage: 's' is a surfel
Estimator::Quantity quantity = estimator.eval(s);
\endcode

@note Due to its nature, PlaneProbingTetrahedronEstimator only returns an \e approximation of the normal vector on every surfel that is not a reentrant corner. If you want to have a correct estimation on every surfel, use a PlaneProbingParallelepipedEstimator as the base.

Model of CSurfelLocalEstimator:
- PlaneProbingDigitalSurfaceLocalEstimator::init(h)
- PlaneProbingDigitalSurfaceLocalEstimator::h()
- PlaneProbingDigitalSurfaceLocalEstimator::eval(it)
- PlaneProbingDigitalSurfaceLocalEstimator::eval(itb, ite, out)

Model of CDigitalSurfaceLocalEstimator:
- PlaneProbingDigitalSurfaceLocalEstimator::attach(s)
- PlaneProbingDigitalSurfaceLocalEstimator::setParams(probingFactory, preEstimations, verbose)

\section sectPlaneProbing3 Further notes

\subsection subsectPlaneProbing31 Implementing your own candidate set

To implement your own candidate set, you need to do the following steps:
- Make a new class, that is a subclass of PlaneProbingNeighborhood,
- Overload the PlaneProbingNeighborhood::hexagonState and if necessary PlaneProbingNeighborhood::getOperation,
- Add a corresponding ProbingMode in PlaneProbingTetrahedronEstimator.h,
- Add a selector function in PlaneProbingTetrahedronEstimator.ih.

*/

}
