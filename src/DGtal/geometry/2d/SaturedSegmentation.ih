/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file SaturedSegmentation.ih
 * @author Tristan Roussillon (\c tristan.roussillon@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Syst√®mes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 *
 * @date 2011/07/21
 *
 * Implementation of inline methods defined in SaturedSegmentation.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// class SaturedSegmentation::SegmentComputerIterator
///////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
// ------------------------- Main processings -----------------------
//////////////////////////////////////////////////////////////////////////////

/**
 * Computes the middle iterator of a given range
 * @param itb, ite, begin and end iterators of a range
 * @return the middle iterator of the range [itb,ite)
 */
  template <typename TSegmentComputer>
inline
typename TSegmentComputer::ConstIterator
DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator::getMiddle(
   const ConstIterator& itb, const ConstIterator& ite) 
{
    ConstIterator b( itb ); 
    ConstIterator f( ite ); 

    bool flag = true; 
    while (b != f) {
      if (flag) {
        --f;
        flag = false; 
      } else {
        ++b; 
        flag = true; 
      } 
    }
    return b;   
} 

/**
 * Checks if the current segment intersects the next one (if exists).
 */
  template <typename TSegmentComputer>
inline
bool
DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator::doesIntersectNext(const ConstIterator& it)
{
		SegmentComputer tmpSegmentComputer;
		ConstIterator previousIt(it); --previousIt;
		tmpSegmentComputer.init(previousIt);
		return tmpSegmentComputer.extend();
}

/**
 * Extend
 */
  template <typename TSegmentComputer>
  template <typename SC>
inline
void
DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator
::extend(SC& s, 
 const typename SC::ConstIterator& end )
{
  typedef typename IteratorCirculatorTraits<typename SC::ConstIterator>::Type Type; 
  this->extend( s, end, Type() ); 
}

  template <typename TSegmentComputer>
  template <typename SC>
inline
void
DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator
::extend(SC& s, 
 const typename SC::ConstIterator& end, 
 IteratorType )
{
  //stop if s.end() == end
  while ( (s.end() != end)
	     && (s.extend()) ) {}
}

  template <typename TSegmentComputer>
  template <typename SC>
inline
void
DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator
::extend(SC& s, 
 const typename SC::ConstIterator& end,
 CirculatorType )
{
  const typename SC::ConstIterator newEnd( s.begin() ); 
  //stop if the segment is the whole range
  while ( (s.extend())
       && (s.end() != newEnd) ) {}
}

/**
 * Extend opposite end
 */
  template <typename TSegmentComputer>
  template <typename SC>
inline
void
DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator
::extendOppositeEnd(SC& s, 
 const typename SC::ConstIterator& begin )
{
  typedef typename IteratorCirculatorTraits<typename SC::ConstIterator>::Type Type; 
  this->extendOppositeEnd( s, begin, Type() ); 
}

  template <typename TSegmentComputer>
  template <typename SC>
inline
void
DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator
::extendOppositeEnd(SC& s, 
 const typename SC::ConstIterator& begin, 
 IteratorType )
{
  //extend one more time if s.begin() == begin
  while ( (s.begin() != begin)
	     && (s.extendOppositeEnd()) ) {}
  if (s.begin() == begin) s.extendOppositeEnd();
}

  template <typename TSegmentComputer>
  template <typename SC>
inline
void
DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator
::extendOppositeEnd(SC& s, 
 const typename SC::ConstIterator& begin,
 CirculatorType )
{
  const typename SC::ConstIterator newBegin( s.end() ); 
  //stop if the segment is the whole range
  while ( (s.extendOppositeEnd())
       && (s.begin() != newBegin) ) {}
}

 
/**
 * Computes the longest possible segment from an iterator
 */
  template <typename TSegmentComputer>
  template <typename SC>
inline
void
DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator
::longestSegment(SC& s, 
 const typename SC::ConstIterator& i,
 const typename SC::ConstIterator& end )
{
  typedef typename IteratorCirculatorTraits<typename SC::ConstIterator>::Type Type; 
  this->longestSegment( s, i, end, Type() ); 
}


  template <typename TSegmentComputer>
  template <typename SC>
inline
void
DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator
::longestSegment(SC& s, 
 const typename SC::ConstIterator& i,
 const typename SC::ConstIterator& end, 
 IteratorType )
{
  //stop if i == end
  if (i != end) {
    s.init(i);
    this->extend(s, end, IteratorType() );
  }

}

  template <typename TSegmentComputer>
  template <typename SC>
inline
void
DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator
::longestSegment(SC& s, 
 const typename SC::ConstIterator& i,
 const typename SC::ConstIterator& end,
 CirculatorType )
{
    //stop if the segment is the whole range
    s.init(i);
    this->extend(s, end, CirculatorType() );
}

/**
 * Computes the first maximal segment passing through a given element
 */
  template <typename TSegmentComputer>
inline
void
DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator
::firstMaximalSegment(const ConstIterator& i)
{
  	this->firstMaximalSegment(i, 
                      typename SegmentComputer::Category() );
}

  template <typename TSegmentComputer>
inline
void
DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator
::firstMaximalSegment(
 const ConstIterator& i,
 ForwardSegmentComputer)
{

  if ( isNotEmpty<ConstIterator>(i,myS->myEnd) ) {

    //backward extension
	  ConstIterator it( i ); ++it; 
    ConstReverseIterator rit( it );
    ConstReverseIterator rend( myS->myBegin );
	  ReverseSegmentComputer r( mySegmentComputer.getReverse() ); 
    this->longestSegment(r, rit, rend);

	  //forward extension
	  ConstIterator it2( r.end().base() );
    this->longestSegment(mySegmentComputer, it2, myS->myEnd);

  }
}

  template <typename TSegmentComputer>
inline
void
DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator
::firstMaximalSegment(
 const ConstIterator& i,
 BidirectionalSegmentComputer)
{

    mySegmentComputer.init(i);

    this->extendOppositeEnd(mySegmentComputer, myS->myBegin);
    this->extend(mySegmentComputer, myS->myEnd);
/*
  if ( isNotEmpty(i,myS->myBegin) ) {

    mySegmentComputer.init(i);

    while ( (mySegmentComputer.extendOppositeEnd())
          &&(mySegmentComputer.begin() != myS->myBegin) ) {} 

    if ( isNotEmpty(i,myS->myEnd) ) {

      while ( (mySegmentComputer.end() != myS->myEnd)
	          &&(mySegmentComputer.extend()) ) {} 

    }
  }
*/
}

  template <typename TSegmentComputer>
inline
void
DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator
::firstMaximalSegment(
 const ConstIterator& i,
 DynamicSegmentComputer)
{
  this->firstMaximalSegment(i,ForwardSegmentComputer() );
}

  template <typename TSegmentComputer>
inline
void
DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator
::firstMaximalSegment(
 const ConstIterator& i,
 DynamicBidirectionalSegmentComputer)
{
  this->firstMaximalSegment(i,BidirectionalSegmentComputer() );
}

/**
 * Computes the last maximal segment passing through a given element
 */
  template <typename TSegmentComputer>
inline
void
DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator
::mostCenteredMaximalSegment(const ConstIterator& i)
{
  	this->mostCenteredMaximalSegment(i, 
                      typename SegmentComputer::Category() );
}

  template <typename TSegmentComputer>
inline
void
DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator
::mostCenteredMaximalSegment(
 const ConstIterator& i,
 ForwardSegmentComputer)
{

 //get the first maximal segment passing through i

  this->firstMaximalSegment( i, ForwardSegmentComputer() );

 //get the next maximal segment while i is not the middle of 
 //the current maximal segment. 

  ConstIterator k( mySegmentComputer.begin() ); 
  while ( k != i ) {

    if ( isNotEmpty<ConstIterator>(i,myS->myEnd) ) {

      //backward extension
	    ConstIterator it( mySegmentComputer.end() ); ++it; 
      ConstReverseIterator rit( it );
      ConstReverseIterator rend( mySegmentComputer.begin() );
	    ReverseSegmentComputer r( mySegmentComputer.getReverse() ); 
      this->longestSegment(r, rit, rend);
      ConstIterator begin = r.end().base(); 
      ConstIterator end = r.begin().base(); 

      while ( ( k != getMiddle(begin, end) )&&( k != i ) )
        ++k; 
      if ( k != i ) this->nextMaximalSegment();

    } else {
      k = i; 
    }
  }

}

  template <typename TSegmentComputer>
inline
void
DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator
::mostCenteredMaximalSegment(
 const ConstIterator& i,
 BidirectionalSegmentComputer)
{

  if ( (isNotEmpty(i,myS->myEnd)) || (isNotEmpty(i,myS->myBegin)) ) { 

    mySegmentComputer.init(i);

    //symmetric extension
    if ( (isNotEmpty(i,myS->myEnd)) && (isNotEmpty(i,myS->myBegin)) ) { 
      while ( (mySegmentComputer.extend() )
	          &&(mySegmentComputer.end() != myS->myEnd ) 
            &&(mySegmentComputer.extendOppositeEnd() )
	          &&(mySegmentComputer.begin() != myS->myBegin ) ) {} 

    }
/*
    //forward extension
    this->extend(mySegmentComputer, myS->myEnd);
      
    //backward extension
    this->extendOppositeEnd(mySegmentComputer, myS->myBegin);
*/
  }
}

  template <typename TSegmentComputer>
inline
void
DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator
::mostCenteredMaximalSegment(
 const ConstIterator& i,
 DynamicSegmentComputer)
{
  this->mostCenteredMaximalSegment(i,ForwardSegmentComputer() );
}

  template <typename TSegmentComputer>
inline
void
DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator
::mostCenteredMaximalSegment(
 const ConstIterator& i,
 DynamicBidirectionalSegmentComputer)
{
  this->mostCenteredMaximalSegment(i,BidirectionalSegmentComputer() );
}

/**
 * Computes the last maximal segment passing through a given element
 */
  template <typename TSegmentComputer>
inline
void
DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator
::lastMaximalSegment(const ConstIterator& i)
{
  	this->lastMaximalSegment(i, 
                      typename SegmentComputer::Category() );
}

  template <typename TSegmentComputer>
inline
void
DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator
::lastMaximalSegment(
 const ConstIterator& i,
 ForwardSegmentComputer)
{

	//forward extension
	ConstIterator j( i );
  this->longestSegment(mySegmentComputer, j, myS->myEnd);

  //backward extension
  ConstIterator it( mySegmentComputer.end() );
  ConstReverseIterator rit( it );
  ConstReverseIterator rend( myS->myBegin );
  ReverseSegmentComputer r( mySegmentComputer.getReverse() ); 
  this->longestSegment(r, rit, rend);

  //forward extension
  ConstIterator it2( r.end().base() );
  this->longestSegment(mySegmentComputer, it2, myS->myEnd);
}

  template <typename TSegmentComputer>
inline
void
DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator
::lastMaximalSegment(
 const ConstIterator& i,
 BidirectionalSegmentComputer)
{

    mySegmentComputer.init(i);

    this->extend(mySegmentComputer, myS->myEnd);
    this->extendOppositeEnd(mySegmentComputer, myS->myBegin);

/*
  if ( isNotEmpty(i,myS->myEnd) ) {

    mySegmentComputer.init(i);

    while ( (mySegmentComputer.extend())
	        &&(mySegmentComputer.end() != myS->myEnd) ) {} 

    if ( isNotEmpty(i,myS->myBegin) ) {
      while ( (mySegmentComputer.extendOppositeEnd())
	          &&(mySegmentComputer.begin() != myS->myBegin) ) {} 
    }
  }
*/
}

  template <typename TSegmentComputer>
inline
void
DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator
::lastMaximalSegment(
 const ConstIterator& i,
 DynamicSegmentComputer)
{
  this->lastMaximalSegment(i,ForwardSegmentComputer() );
}

  template <typename TSegmentComputer>
inline
void
DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator
::lastMaximalSegment(
 const ConstIterator& i,
 DynamicBidirectionalSegmentComputer)
{
  this->lastMaximalSegment(i,BidirectionalSegmentComputer() );
}


/**
 * Goes to the next segment.
 */
  template <typename TSegmentComputer>
inline
void
DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator::nextMaximalSegment()
{

	if ( myFlagIsLast ) { //if end

    myFlagIsValid = false; 

	} else { //otherwise

	  myFlagIntersectPrevious = myFlagIntersectNext;

  	this->nextMaximalSegment(mySegmentComputer.end(), 
                      typename SegmentComputer::Category() );

std::cerr << *mySegmentComputer.begin() << " == " << *myLastMaximalSegmentBegin << ", " ;
ConstIterator a(mySegmentComputer.end()); ConstIterator b(myLastMaximalSegmentEnd); 
std::cerr << *--a << " == " << *--b << std::endl;


	  if ( (mySegmentComputer.begin() == myLastMaximalSegmentBegin) 
       &&(mySegmentComputer.end() == myLastMaximalSegmentEnd) ) { //if end

      //TODO to check in the circulator case
	    myFlagIntersectNext = false;
  
      myFlagIsLast = true; 
      
	  } else {
    //otherwise
		  myFlagIntersectNext = doesIntersectNext( mySegmentComputer.end() );
    }

	}

}

  template <typename TSegmentComputer>
inline
void
DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator
::nextMaximalSegment(
 const ConstIterator& i,
 ForwardSegmentComputer)
{
  this->firstMaximalSegment( i, ForwardSegmentComputer() );
}

  template <typename TSegmentComputer>
inline
void
DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator
::nextMaximalSegment(
 const ConstIterator& i,
 BidirectionalSegmentComputer)
{
  this->firstMaximalSegment( i, BidirectionalSegmentComputer() );
}

  template <typename TSegmentComputer>
inline
void
DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator
::nextMaximalSegment(
 const ConstIterator& i,
 DynamicSegmentComputer)
{

  while ( ( (mySegmentComputer.end() == myS->myEnd )
          ||(! mySegmentComputer.isExtendable() ) )
        &&(mySegmentComputer.retract() ) ) {} 

  this->extend(mySegmentComputer, myS->myEnd);

}

  template <typename TSegmentComputer>
inline
void
DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator
::nextMaximalSegment(
 const ConstIterator& i,
 DynamicBidirectionalSegmentComputer)
{
  this->nextMaximalSegment(i,DynamicSegmentComputer() );
}


//////////////////////////////////////////////////////////////////////////////
// ------------------------- Standard services -----------------------
//////////////////////////////////////////////////////////////////////////////

/**
 * Constructor.
 * Nb: complexity in O(n).
 *
 */
 template <typename TSegmentComputer>
inline
DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator::SegmentComputerIterator ( 
	const SaturedSegmentation<TSegmentComputer> *s,
	const TSegmentComputer& aSegmentComputer,
  const bool& isValid )
  : myS( s ), 
		mySegmentComputer( aSegmentComputer ), 
    myFlagIntersectNext( false ),
		myFlagIntersectPrevious( false ),
    myFlagIsLast( false ),
    myFlagIsValid( isValid )
{

  if (myFlagIsValid) {
	  if ( isNotEmpty<ConstIterator>(myS->myStart, myS->myStop) ) {   //if at least one element

      //TODO to check in the circulator case          
	    myFlagIntersectPrevious = false;

      if (myS->myMode == "First") {
        //end
        ConstIterator i(myS->myStop); --i; 
        this->firstMaximalSegment(i);
        myLastMaximalSegmentBegin = mySegmentComputer.begin(); 
        myLastMaximalSegmentEnd = mySegmentComputer.end(); 
        //beginning
        this->firstMaximalSegment(myS->myStart);
      } 
      else
      if (myS->myMode == "Last") {
        //end
        ConstIterator i(myS->myStop); --i; 
        this->lastMaximalSegment(i);
        myLastMaximalSegmentBegin = mySegmentComputer.begin(); 
        myLastMaximalSegmentEnd = mySegmentComputer.end(); 
        //beginning
        this->lastMaximalSegment(myS->myStart);
      } 
      else { // (myS->myMode == "MostCentered") 
        //end
        ConstIterator i(myS->myStop); --i; 
        this->mostCenteredMaximalSegment(i);
        myLastMaximalSegmentBegin = mySegmentComputer.begin(); 
        myLastMaximalSegmentEnd = mySegmentComputer.end(); 
        //beginning
        this->mostCenteredMaximalSegment(myS->myStart);
      }
      
    } else {
      myFlagIsValid = false;
    }
  }
}



/**
 * Copy constructor.
 * @param other the iterator to clone.
 */
  template <typename TSegmentComputer>
inline
DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator::SegmentComputerIterator
( const SegmentComputerIterator & other )
  : myS( other.myS ), 
		mySegmentComputer( other.mySegmentComputer ),
		myFlagIntersectNext( other.myFlagIntersectNext ), 
		myFlagIntersectPrevious( other.myFlagIntersectPrevious ) ,
    myFlagIsLast( other.myFlagIsLast ),
    myFlagIsValid( other.myFlagIsValid ),
    myLastMaximalSegmentBegin( other.myLastMaximalSegmentBegin ),
    myLastMaximalSegmentEnd( other.myLastMaximalSegmentEnd )
{
}
    
/**
 * Assignment.
 * @param other the iterator to copy.
 * @return a reference on 'this'.
 */
  template <typename TSegmentComputer>
inline
typename DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator::SegmentComputerIterator& 
DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator::operator=
( const SegmentComputerIterator & other )
{
  if ( this != &other )
    {
      myS = other.myS;
      mySegmentComputer = other.mySegmentComputer;
			myFlagIntersectNext = other.myFlagIntersectNext;
			myFlagIntersectPrevious = other.myFlagIntersectPrevious;
			myFlagIsValid = other.myFlagIsValid;
			myFlagIsLast = other.myFlagIsLast;
      myLastMaximalSegmentBegin( other.myLastMaximalSegmentBegin ); 
      myLastMaximalSegmentEnd( other.myLastMaximalSegmentEnd );
    }
  return *this;
}
    
/**
 * Destructor.
 * Does nothing
 */
  template <typename TSegmentComputer>
inline
DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator::~SegmentComputerIterator()
{
}

///////////////////////////////////////////////////////////////////////////////
// ------------------------- iteration services -------------------------
//////////////////////////////////////////////////////////////////////////////
    
      
/**
 * @return the current segment.
 */
  template <typename TSegmentComputer>
inline
const TSegmentComputer&
DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator::operator*() const
{
  return mySegmentComputer;
}

/**
 * @return the pointer to the current segment.
 */
  template <typename TSegmentComputer>
inline
const TSegmentComputer*
DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator::operator->() const
{
  return &mySegmentComputer;
}

/**
 * @return the current segment.
 */
  template <typename TSegmentComputer>
inline
TSegmentComputer
DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator::get() const
{
  return mySegmentComputer;
}

/**
 * Pre-increment.
 * Goes to the next segment.
 */

  template <typename TSegmentComputer>
inline
typename DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator & 
DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator::operator++()
{
  this->nextMaximalSegment();
  return *this;
}
    

/**
 * Equality operator.
 *
 * @param aOther the iterator to compare with 
 *
 * @return 'true' if their current positions coincide.
 */
  template <typename TSegmentComputer>
inline
bool
DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator::operator==
( const SegmentComputerIterator & other ) const
{
 if ( isValid() ) 
  return ( (other.isValid() ) && 
( mySegmentComputer.begin() == other.mySegmentComputer.begin() ) &&
( mySegmentComputer.end() == other.mySegmentComputer.end() ) );  
 else 
  return ( ! other.isValid() );

}

/**
 * Inequality operator.
 *
 * @param aOther the iterator to compare with 
 *
 * @return 'true' if their current positions differs.
 */
  template <typename TSegmentComputer>
inline
bool
DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator::operator!=
( const SegmentComputerIterator & other ) const
{
  return !(*this == other);
}

//////////////////////////////////////////////////////////////////////////////
// ------------------------- accessors -------------------------
//////////////////////////////////////////////////////////////////////////////

  template <typename TSegmentComputer>
inline
const bool
DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator::intersectNext() const
{
  return myFlagIntersectNext;
}

  template <typename TSegmentComputer>
inline
const bool
DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator::intersectPrevious() const
{
  return myFlagIntersectPrevious;
}



  template <typename TSegmentComputer>
inline
const typename TSegmentComputer::ConstIterator
DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator::begin() const
{
  return mySegmentComputer.begin();
}

  template <typename TSegmentComputer>
inline
const typename TSegmentComputer::ConstIterator
DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator::end() const
{
  return mySegmentComputer.end();
}



///////////////////////////////////////////////////////////////////////////////
// class SaturedSegmentation
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Interface - public :


/**
 * Constructor.
 */
  template <typename TSegmentComputer>
DGtal::SaturedSegmentation<TSegmentComputer>::SaturedSegmentation
(const ConstIterator& itb, const ConstIterator& ite, const SegmentComputer& aSegmentComputer)
 : myBegin(itb),
	 myEnd(ite),
   myStart(itb),
	 myStop(ite),
	 mySegmentComputer(aSegmentComputer),
   myMode("MostCentered")
{
}


  template <typename TSegmentComputer>
inline
void
DGtal::SaturedSegmentation<TSegmentComputer>::setSubRange
(const ConstIterator& itb, const ConstIterator& ite)
{
  myStart = itb;
	myStop = ite;
  myMode = "MostCentered";
}

  template <typename TSegmentComputer>
inline
void
DGtal::SaturedSegmentation<TSegmentComputer>::setMode
(const std::string& aMode)
{
  myMode = aMode; 
}


/**
 * Destructor.
 */
  template <typename TSegmentComputer>
inline
DGtal::SaturedSegmentation<TSegmentComputer>::~SaturedSegmentation()
{
}

/**
 * ConstIterator service.
 * @return an iterator pointing on the first segment
 * of the digital curve.
 */
  template <typename TSegmentComputer>
inline
typename DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator 
DGtal::SaturedSegmentation<TSegmentComputer>::begin() const
{
  return SegmentComputerIterator(this, mySegmentComputer, true);
}

/**
 * ConstIterator service.
 * @return an iterator pointing after the last segment
 * of the digital curve.
 */
  template <typename TSegmentComputer>
inline
typename DGtal::SaturedSegmentation<TSegmentComputer>::SegmentComputerIterator 
DGtal::SaturedSegmentation<TSegmentComputer>::end() const
{
  return SegmentComputerIterator(this, mySegmentComputer, false);
}


/**
 * Writes/Displays the object on an output stream.
 * @param out the output stream where the object is written.
 */
  template <typename TSegmentComputer>
inline
void
DGtal::SaturedSegmentation<TSegmentComputer>::selfDisplay ( std::ostream & out ) const
{
  out << "[SaturedSegmentation]";
}

/**
 * Checks the validity/consistency of the object.
 * @return 'true' if the object is valid, 'false' otherwise.
 */
  template <typename TSegmentComputer>
inline
bool
DGtal::SaturedSegmentation<TSegmentComputer>::isValid() const
{
    return true;
}



///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions                                        //

  template <typename TSegmentComputer>
inline
std::ostream&
DGtal::operator<< ( std::ostream & out, 
		  const SaturedSegmentation<TSegmentComputer> & object )
{
  object.selfDisplay( out );
  return out;
}

//                                                                           //
///////////////////////////////////////////////////////////////////////////////


