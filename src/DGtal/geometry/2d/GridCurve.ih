/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file GridCurve.ih
 * @author Tristan Roussillon (\c
 * tristan.roussillon@liris.cnrs.fr ) Laboratoire d'InfoRmatique en
 * Image et Syst√®mes d'information - LIRIS (CNRS, UMR 5205), CNRS,
 * France
 *
 *
 * @date 2011/06/27
 *
 * Implementation of inline methods defined in GridCurve.h
 *
 * This file is part of the DGtal library.
 */

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
#include <iostream>
#include <sstream>

//////////////////////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////
// Implementation of inline methods                                          //


template <typename KSpace>
inline
typename DGtal::GridCurve<KSpace>::Cell
DGtal::GridCurve<KSpace>::PointTo0Cell(const Point& aPoint) {
    return myK.sPointel(aPoint,myK.POS);
}

template <typename KSpace>
inline
typename DGtal::GridCurve<KSpace>::Cell
DGtal::GridCurve<KSpace>::PointVectorTo1Cell(const Point& aPoint, const Vector& aVector) {

    ASSERT( (aVector.norm(Vector::L_1) == 1) );
    Point p(aPoint);
    Point kp(p*2 + aVector); 
    return Cell(kp,myK.POS);
}

/**
* Init.
* @param aVectorOfPoints the vector containing the sequence of grid points. 
*/
template <typename KSpace>
inline
void
DGtal::GridCurve<KSpace>::initFromVector( const std::vector<Point> aVectorOfPoints )  throw(ConnectivityException) {

  typename std::vector<Point>::const_iterator i, j; 

  i = aVectorOfPoints.begin();
  j = i; ++j;

  for ( ; j != aVectorOfPoints.end(); ++i, ++j) {

    Point p = *i; 
    Vector v = *j - p;

    if (v.norm(Vector::L_1) != 1) { //disconnected !
	    throw ConnectivityException(); 
    }

    my0Cells.push_back( PointTo0Cell(p) );
    my1Cells.push_back( PointVectorTo1Cell(p,v) );
  }


  Point first = *aVectorOfPoints.begin();
  Point last = *i;
  Vector v(last - first); 
  if (v.norm(Vector::L_1) == 1) {               
    my1Cells.push_back( PointVectorTo1Cell(last,v) );
  }
  my0Cells.push_back( PointTo0Cell(last) );
}

/**
 * Init.
 * @param in any input stream,
 */
template <typename KSpace>
inline
void
DGtal::GridCurve<KSpace>::initFromVectorStream(std::istream & in ) {

  std::vector<Point> v = PointListReader<Point>
                        ::getPointsFromInputStream(in);

  if (v.size() == 0) throw IOException(); 

  try {
    DGtal::GridCurve<KSpace>::initFromVector(v);
  } catch (DGtal::ConnectivityException& e) {
    throw ConnectivityException(); 
  }
}

/**
* Init.
* @param in any input stream,
*/
template <typename KSpace>
inline
void
DGtal::GridCurve<KSpace>::initFromFreemanChainStream(std::istream & in ) throw(InputException) {
    ASSERT( (Point::dimension == 2) );
}

/**
 * Outputs the grid curve to the stream [out].
 * @param out any output stream,
 */
template <typename KSpace>
inline
void
DGtal::GridCurve<KSpace>::writeVectorToStream( std::ostream & out ) {
  typename Storage::const_iterator i = my0Cells.begin();
  while (i != my0Cells.end()) {
    Point p = myK.sCoords(*i); 
    for (unsigned int k = 0; k < Point::dimension; ++k) {
      out << p[k] << " ";
    }
    out << std::endl;
    ++i;
  }  
}

/**
 * Copy constructor.
 * @param other the object to clone.
 */
template <typename KSpace>
DGtal::GridCurve<KSpace>::GridCurve( const GridCurve<KSpace> & aOther )
  : myK( aOther.myK ), my0Cells( aOther.my0Cells ), my1Cells( aOther.my1Cells )
{
}

/**
 * Assignment.
 * @param aOther the object to copy.
 * @return a reference on 'this'.
 */
template <typename KSpace>
typename DGtal::GridCurve<KSpace> & 
DGtal::GridCurve<KSpace>::operator=( const GridCurve<KSpace> & aOther )
{
  if ( this != &aOther )
    {
      myK = aOther.myK;
      my0Cells = aOther.my0Cells;
      my1Cells = aOther.my1Cells;
    }
  return *this;
}

template <typename KSpace>
inline
bool
DGtal::GridCurve<KSpace>::isValid() const
{
  return ( my0Cells.size() > 0 ) 
&& ( my1Cells.size() > 0 )
&& ( (my0Cells.size() - my1Cells.size()) >= 1 )
&& ( (my0Cells.size() - my1Cells.size()) <= 0 );
}

template <typename KSpace>
inline
bool
DGtal::GridCurve<KSpace>::isClosed() const
{
  //closed grid curves have as many 0-cells as 1-cells
  return ( my0Cells.size() == my1Cells.size() );
}

template <typename KSpace>
inline
bool
DGtal::GridCurve<KSpace>::isOpen() const
{
  //open grid curves have one 0-cell more
  //than their 1-cells
  return ( my0Cells.size() != my1Cells.size() );
}


//------------------------------------------------------------------------------
// ---------------- DISPLAY ----------------------------------------------------
//------------------------------------------------------------------------------

template <typename KSpace>
inline
void
DGtal::GridCurve<KSpace>::selfDisplay ( std::ostream & out ) const
{
  out << "[GridCurve]" << std::endl;
  out << "#0-cell 1-cell" << std::endl;
  typename Storage::const_iterator i0 = my0Cells.begin();
  typename Storage::const_iterator i1 = my1Cells.begin();
  while (i1 != my1Cells.end()) {
    Point p = myK.sKCoords(*i0); 
    Point l = myK.sKCoords(*i1); 
    out << p << " " << l << std::endl;
    ++i1;
    ++i0;
  }
}
//------------------------------------------------------------------------------

template <typename KSpace>
inline
DGtal::DrawableWithDGtalBoard*
DGtal::GridCurve<KSpace>::defaultStyle( std::string mode ) const
{
  if ( ( mode == "" ) || ( mode == "Points" ) ) 
    return new DefaultDrawStylePoints;
  else 
    return new DefaultDrawStyleEdges;  
}
//------------------------------------------------------------------------------
template <typename KSpace>
inline
std::string
DGtal::GridCurve<KSpace>::styleName() const
{
  return "GridCurve";
}
//------------------------------------------------------------------------------
template <typename KSpace>
inline
void 
DGtal::GridCurve<KSpace>::selfDraw(DGtalBoard & aBoard) const
{
  std::string mode = aBoard.getMode( this->styleName() );
  ASSERT( (mode=="Points" || mode=="" || mode=="Edges") ||
	  ("DGtal::GridCurve<KSpace>::selfDraw: Unknown mode "+mode)==""  );
  
  if ( mode == "Points"  || ( mode == "" )  )
    selfDrawPoints( aBoard );
  else if ( mode == "Edges" )
    selfDrawEdges( aBoard );
  
}
//------------------------------------------------------------------------------
template <typename KSpace>
inline
void 
DGtal::GridCurve<KSpace>::selfDrawPoints(DGtalBoard & aBoard) const
{
  for(unsigned int i=0; i< my0Cells.size(); i++){
    aBoard << my0Cells.at(i);
  }
}
//------------------------------------------------------------------------------
template <typename KSpace>
inline
void 
DGtal::GridCurve<KSpace>::selfDrawEdges(DGtalBoard & aBoard) const
{
  for(unsigned int i=0; i< my1Cells.size(); i++){
    aBoard << my1Cells.at(i);
  }
}








///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions and external operators                 //

/**
 * Overloads 'operator<<' for displaying objects of class 'GridCurve'.
 * @param out the output stream where the object is written.
 * @param object the object of class 'GridCurve' to write.
 * @return the output stream after the writing.
 */
template <typename KSpace>
inline
std::ostream&
DGtal::operator<< ( std::ostream & out,
                  const GridCurve<KSpace> & aObject )
{
    aObject.selfDisplay ( out );
    return out;
}

//                                                                           //
///////////////////////////////////////////////////////////////////////////////


