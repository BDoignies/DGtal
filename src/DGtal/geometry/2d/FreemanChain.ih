/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/
//LICENSE-END
/**
 * @file FreemanChain.ih
 * @author Jacques-Olivier Lachaud (\c jacques-olivier.lachaud@univ-savoie.fr )
 * Laboratory of Mathematics (CNRS, UMR 5807), University of Savoie, France
 * Bertrand Kerautret (\c kerautre@loria.fr )
 * LORIA (CNRS, UMR 7503), University of Nancy, France
 *
 * @date 2010/07/01
 *
 * Implementation of inline methods defined in FreemanChain.h
 *
 * This file is part of the DGtal library.
 */

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
#include <iostream>
//////////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////
// Implementation of inline methods                                          //





///////////////////////////////////////////////////////////////////////////////
// class FreemanChain::ConstIterator
///////////////////////////////////////////////////////////////////////////////

// ------------------------- Standard services -----------------------

/**
 * Default Constructor.
 * The object is not valid.
 */
DGtal::FreemanChain::ConstIterator::ConstIterator()
  : myFc( 0 ), myPos( 0 )
{
}

/**
 * Constructor.
 * Nb: complexity in O(n).
 *
 * @param chain a Freeman chain,
 * @param n the position in [chain] (within 0 and chain.size()-1).
 */
DGtal::FreemanChain::ConstIterator::ConstIterator
( const FreemanChain & aChain, unsigned int n )
  : myFc( &aChain ), myPos( 0 )
{
  myXY.at(0)=aChain.x0;
  myXY.at(1)=aChain.y0;
  
  if ( n < myFc->chain.size() )
    while ( myPos < n )
      {
	this->next();
	// JOL !!!
	// ERROR: myPos is already incremented in next().
	// ++myPos;
      }
  else // iterator end() 
    myPos = myFc->chain.size();
}

/**
 * Copy constructor.
 * @param other the iterator to clone.
 */
DGtal::FreemanChain::ConstIterator::ConstIterator
( const ConstIterator & aOther )
  : myFc( aOther.myFc ), myPos( aOther.myPos ), myXY( aOther.myXY )
{
}
    
/**
 * Assignment.
 * @param other the iterator to copy.
 * @return a reference on 'this'.
 */
DGtal::FreemanChain::ConstIterator& 
DGtal::FreemanChain::ConstIterator::operator=
( const ConstIterator & other )
{
  if ( this != &other )
    {
      myFc = other.myFc;
      myPos = other.myPos;
      myXY = other.myXY;
    }
  return *this;
}
    
/**
 * Destructor. Does nothing.
 */
DGtal::FreemanChain::ConstIterator::~ConstIterator()
{
}
    
// ------------------------- iteration services -------------------------
      
/**
 * @return the current coordinates.
 */
PointVector<2, int> 
DGtal::FreemanChain::ConstIterator::operator*() const
{
  return myXY;
}

/**
 * @return the current coordinates.
 */
DGtal::PointVector<2, int>
DGtal::FreemanChain::ConstIterator::get() const
{
  return myXY;
}

/**
 * Pre-increment.
 * Goes to the next point on the chain.
 */
DGtal::FreemanChain::ConstIterator& 
DGtal::FreemanChain::ConstIterator::operator++()
{
  this->next();
  return *this;
}
      
/**
 * Goes to the next point on the chain.
 */
void 
DGtal::FreemanChain::ConstIterator::next()
{
  if ( myPos < myFc->chain.size() )
    {
      switch ( myFc->code( myPos ) )
	{
	case 0: myXY.at(0)++; break;
	case 1: myXY.at(1)++; break;
	case 2: myXY.at(0)--; break;
	case 3: myXY.at(1)--; break;
	}
      ++myPos;
    }
}

/**
 * Goes to the previous point on the chain as if on a loop.
 */
void
DGtal::FreemanChain::ConstIterator::nextInLoop()
{
  if ( myPos < myFc->chain.size() )
    {
      switch ( myFc->code( myPos ) )
	{
	case 0: myXY.at(0)++; break;
	case 1: myXY.at(1)++; break;
	case 2: myXY.at(0)--; break;
	case 3: myXY.at(1)--; break;
	}
      myPos = ( myPos + 1 ) % myFc->chain.size();
    }
}


/**
 * @return the current position (as an index in the Freeman chain).
 */
unsigned int
DGtal::FreemanChain::ConstIterator::getPosition() const
{
  return myPos;
}

/**
 * @return the associated Freeman chain.
 */
const DGtal::FreemanChain* 
DGtal::FreemanChain::ConstIterator::getChain() const
{
  return myFc;
}

/**
 * @return the current Freeman code (specifies the movement to
 * the next point).
 */
unsigned int 
DGtal::FreemanChain::ConstIterator::getCode() const
{
  ASSERT( myFc != 0 );
  return myFc->code( myPos );
}

/**
 * Pre-decrement.
 * Goes to the previous point on the chain.
 */
DGtal::FreemanChain::ConstIterator& 
DGtal::FreemanChain::ConstIterator::operator--()
{
  this->previous();
  return *this;
}

/**
 * Goes to the previous point on the chain if possible.
 */
void
DGtal::FreemanChain::ConstIterator::previous()
{
  if ( myPos > 0 )
    {
      --myPos;
      switch ( myFc->code( myPos ) )
	{
	case 0: myXY.at(0)--; break;
	case 1: myXY.at(1)--; break;
	case 2: myXY.at(0)++; break;
	case 3: myXY.at(1)++; break;
	}
    }
}

/**
 * Goes to the previous point on the chain as if on a loop.
 */
void
DGtal::FreemanChain::ConstIterator::previousInLoop()
{
  if ( myPos == 0 ) myPos = myFc->chain.size() - 1;
  else --myPos;
  switch ( myFc->code( myPos ) )
    {
    case 0: myXY.at(0)--; break;
    case 1: myXY.at(1)--; break;
    case 2: myXY.at(0)++; break;
    case 3: myXY.at(1)++; break;
    }
}


/**
 * Equality operator.
 *
 * @param aOther the iterator to compare with (must be defined on
 * the same chain).
 *
 * @return 'true' if their current positions coincide.
 */
bool 
DGtal::FreemanChain::ConstIterator::operator==
( const ConstIterator & aOther ) const
{
  ASSERT( myFc == aOther.myFc );
  return myPos == aOther.myPos;
}

/**
 * Inequality operator.
 *
 * @param aOther the iterator to compare with (must be defined on
 * the same chain).
 *
 * @return 'true' if their current positions differs.
 */
bool 
DGtal::FreemanChain::ConstIterator::operator!=
( const ConstIterator & aOther ) const
{
  ASSERT( myFc == aOther.myFc );
  return myPos != aOther.myPos;
}


/**
 * Inferior operator.
 *
 * @param aOther the iterator to compare with (must be defined on
 * the same chain).
 *
 * @return 'true' if the current position of 'this' is before
 * the current position of [aOther].
 */
bool 
DGtal::FreemanChain::ConstIterator::operator<
( const ConstIterator & aOther ) const
{

  ASSERT( myFc == aOther.myFc );
  return myPos < aOther.myPos;
}

      

///////////////////////////////////////////////////////////////////////////////
// Implementation of inline methods                                          //

/**
 * Constructor.
 * @param s the chain code.
 * @param x the x-coordinate of the first point.
 * @param y the y-coordinate of the first point.
 */
DGtal::FreemanChain::FreemanChain( const std::string & s, int x, int y )
  : chain( s ), x0( x ), y0( y )
{
}


/**
 * Constructor.
 * @param in any input stream,
 */
DGtal::FreemanChain::FreemanChain(std::istream & in ){
  DGtal::FreemanChain::read(in, *this);
}

/**
 * Copy constructor.
 * @param other the object to clone.
 */
DGtal::FreemanChain::FreemanChain( const FreemanChain & aOther )
  : chain( aOther.chain ), x0( aOther.x0 ), y0( aOther.y0 )
{
}

/**
 * Assignment.
 * @param aOther the object to copy.
 * @return a reference on 'this'.
 */
DGtal::FreemanChain & 
DGtal::FreemanChain::operator=( const FreemanChain & aOther )
{
  if ( this != &aOther )
    {
      chain = aOther.chain;
      x0 = aOther.x0;
      y0 = aOther.y0;
    }
  return *this;
}


template<typename Functor>
inline
void 
DGtal::FreemanChain::selfDraw(LibBoard::Board & aBoard) const
{
  Functor applystyle(aBoard);
  vector<FreemanChain::PointI2> aVContour;
  FreemanChain::getContourPoints(*this, aVContour);
  vector<LibBoard::Point> contour;
  for(int i=0; i< aVContour.size(); i++){
    contour.push_back(LibBoard::Point(aVContour[i][0],aVContour[i][1]));
  }
  aBoard.drawPolyline(contour); 
  
}



/**
 * Iterator service.
 * @return an iterator pointing on the first point of the chain.
 */
DGtal::FreemanChain::ConstIterator 
DGtal::FreemanChain::begin() const
{
  return FreemanChain::ConstIterator( *this, 0 );
}

/**
 * Iterator service.
 * @return an iterator pointing after the last point of the chain.
 */
DGtal::FreemanChain::ConstIterator 
DGtal::FreemanChain::end() const
{
  return FreemanChain::ConstIterator( *this, chain.size() );
}


/**
 * @return the length of the Freeman chain code.
 */
unsigned int
DGtal::FreemanChain::size() const
{
  return chain.size();
}



/**
 * @param aPos a position in the chain code.
 * @return the code at position [aPos].
 */ 
unsigned int
DGtal::FreemanChain::code( unsigned int aPos ) const
{
  ASSERT( aPos < chain.size() );
  return chain[ aPos ] - '0';
}

/**
 * @param pos a position in the chain code.
 * @return the next position.
 */ 
unsigned int
DGtal::FreemanChain::next( unsigned int aPos ) const
{
  ++aPos;
  if ( aPos >= chain.size() )
    aPos = 0;
  return aPos;
}

/**
 * @param pos a position in the chain code.
 * @return the previous position.
 */ 
unsigned int
DGtal::FreemanChain::previous( unsigned int aPos ) const
{
  if ( aPos == 0 ) aPos = chain.size() - 1;
  else --aPos;
  return aPos;
}


///////////////////////////////////////////////////////////////////////////////
// Staic services

/**
 * Returns the displacement vector of a Freeman code.
 *
 * @param dx (returns) the x-displacement.
 * @param dy (returns) the x-displacement.
 * @param aCode the code.
 */
INLINE
void
DGtal::FreemanChain::displacement( int & dx, int & dy, unsigned int aCode )
{
  switch ( aCode ) 
    {
    case 0: dx = 1; dy = 0; break;
    case 1: dx = 0; dy = 1; break;
    case 2: dx = -1; dy = 0; break;
    case 3: dx = 0; dy = -1; break;
    }
}

/**
 * @param aCode a Freeman code (between 0-3).
 * Returns the displacement vector of the Freeman code.
 */
INLINE
DGtal::PointVector<2, int>
DGtal::FreemanChain::displacement( unsigned int aCode )
{
  
#ifdef CPP0X_INITIALIZER_LIST  
  switch ( aCode ) 
    {
    case 0:  return PointI2({1,0}); 
    case 1:  return PointI2({0,1}); 
    case 2:  return PointI2({-1,0});
    case 3:  return PointI2({0,-1});
    }
  return  PointI2({0,0}); 
#else
   int t[2] = {0,0};
  
  switch ( aCode ) 
    {
    case 0:  t[0]++; return PointI2( t ); 
    case 1:  t[1]++; return PointI2( t ); 
    case 2:  t[0]--; return PointI2( t );
    case 3:  t[1]--; return PointI2( t );
    }
  return  PointI2( t ); 
#endif //CPP0X_INITIALIZER_LIST
}





/**
 * @param aCode any Freeman code
 * @param ccw when 'true' turns counterclockwise, otherwise turns clockwise.
 *
 * @return the turned code.
 */
INLINE
unsigned int
DGtal::FreemanChain::turnedCode( unsigned int aCode, bool ccw )
{
  if ( ccw ) return ( aCode + 1 ) & 0x3;
  else       return ( aCode - 1 ) & 0x3;
}




void 
DGtal::FreemanChain::movePointFromFC(PointI2 & aPoint, unsigned int aCode ){
  switch ( aCode )
    {
    case 0: aPoint.at(0)++; break;
    case 1: aPoint.at(1)++; break;
    case 2: aPoint.at(0)--; break;
    case 3: aPoint.at(1)--; break;
    }
}




///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions and external operators                 //

/**
 * Overloads 'operator<<' for displaying objects of class 'FreemanChain'.
 * @param out the output stream where the object is written.
 * @param object the object of class 'FreemanChain' to write.
 * @return the output stream after the writing.
 */
INLINE
std::ostream&
DGtal::operator<< ( std::ostream & out,
                  const FreemanChain & aObject )
{
    aObject.selfDisplay ( out );
    return out;
}

//                                                                           //
///////////////////////////////////////////////////////////////////////////////


