/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file FP.ih
 * @author Tristan Roussillon (\c tristan.roussillon@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Syst√®mes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 *
 * @date 2011/01/26
 *
 * Implementation of inline methods defined in FP.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------

/**
 * Constructor.
 */
template <typename TIterator, typename TInteger, int connectivity>
inline
DGtal::FP<TIterator,TInteger,connectivity>::FP(
  const TIterator& itb, 
	const TIterator& ite, 
  const bool& isClosed ) throw( InputException ) 
 : myFlagIsClosed( isClosed ) 
{

	TIterator i = itb;

	if (i != ite) {

		//----------------------------------------
		//first DSS
		//----------------------------------------

		DSS currentDSS(i); //current DSS
		AdapterDSS* adapter; //adapter for the current DSS

		//list of successive upper (U) and lower (L)
    // leaning points. 
		std::list<Point> vTmpU, vTmpL;

		vTmpU.push_back(*i);
		vTmpL.push_back(*i);

    TIterator end; //end iterator
    if (myFlagIsClosed) {
      //first maximal DSS
 /*   Titerator k = i; 
		  ++i; //move forward
		  while ( (i != ite)&&(currentDSS.extend(i)) ) {
			  ++i; //move forward
		  }
      --k; 
		  while ( (currentDSS.extendOppositeEnd(k)) ) {
			  --k; //move backward
		  }*/
      //iterator at first upper leaning point

    } else {

		  //longest DSS
		  ++i; //move forward
		  while ( (i != ite)&&(currentDSS.extend(i)) ) {
			  //store the first upper leaning point
			  if (currentDSS.getUf() != vTmpU.back()) {
				  vTmpU.push_back(currentDSS.getUf());
			  }
			  //store the first lower leaning point
			  if (currentDSS.getLf() != vTmpL.back()) {
				  vTmpL.push_back(currentDSS.getLf());
			  }
			  ++i; //move forward
		  }
    	end = ite;

    }
		
		//----------------------------------------
		//initialisation 
		//----------------------------------------

		bool isConvex; //TRUE in convex parts, FALSE otherwise

		if (i != end) {

			if ( currentDSS.getRemainder(i) < (currentDSS.getMu()) ) { //concave part
				if (!myFlagIsClosed) myPolygon = vTmpL;
				isConvex = false;
				adapter = new AdapterDSS4ConcavePart(currentDSS);
			} else {                                                      //convex part
				if (!myFlagIsClosed) myPolygon = vTmpU;
				isConvex = true;
				adapter = new AdapterDSS4ConvexPart(currentDSS);
			}

		} else {
			//the part is assumed to be convex
			//if it is straight
			myPolygon = vTmpU;
			isConvex = true;
			adapter = new AdapterDSS4ConvexPart(currentDSS);
		}

//		std::cout << "First longest DSS: " << std::endl;
//		std::cout << currentDSS << std::endl;

		//----------------------------------------
		//body 
		//----------------------------------------

//		std::cout << "body" << std::endl;

		while (i != end) {

			//store the last leaning point 
			//if the first and last leaning points 
			//of the MS are not confounded
			if (adapter->firstLeaningPoint() != adapter->lastLeaningPoint()) {
				myPolygon.push_back(adapter->lastLeaningPoint());
			}

			//removing step
			while (!currentDSS.isExtendable(i)) {
				//remove a point from the back
				if ( currentDSS.retract() ) {
					//store the last leaning point
					if (adapter->lastLeaningPoint() != myPolygon.back()) {
						myPolygon.push_back(adapter->lastLeaningPoint());
					}
				} else {
					//disconnected digital curve
					throw InputException();
				}
			}

			//remove the last leaning point 
			//if the first and last leaning points 
			//of the current DSS are not confounded
			if (adapter->firstLeaningPoint() != adapter->lastLeaningPoint()) {
				myPolygon.pop_back();
			}		

			//adding step
			while ( (i != end)&&(currentDSS.extend(i)) ) {
				//store the first leaning point
				if (adapter->firstLeaningPoint() != myPolygon.back()) {
					myPolygon.push_back(adapter->firstLeaningPoint());
				}
				++i; //move forward
			}

			//transition step
			if (i != end) {
				if ( (isConvex)&&( currentDSS.getRemainder(i) < 
												  (currentDSS.getMu()) ) ) {
					//from convex to concave
					isConvex = false;
					delete (adapter);
					adapter = new AdapterDSS4ConcavePart(currentDSS);
				} else if ( (!isConvex)&&( currentDSS.getRemainder(i) >= 
												          (currentDSS.getMu()+currentDSS.getOmega()) ) ) {
					//from concave to convex
					isConvex = true;
					delete (adapter);
					adapter = new AdapterDSS4ConvexPart(currentDSS);
				}
			}

		}


		//----------------------------------------
		//end 
		//----------------------------------------

//		std::cout << "end" << std::endl;

    if (!myFlagIsClosed) {

		  //last removing step
		  while (currentDSS.retract()) {
			  //store the last leaning point
			  if (adapter->lastLeaningPoint() != myPolygon.back()) {
				  myPolygon.push_back(adapter->lastLeaningPoint());
			  }
		  }

    }
		delete (adapter);

	}	

}

/**
 * Destructor.
 */
template <typename TIterator, typename TInteger, int connectivity>
inline
DGtal::FP<TIterator,TInteger,connectivity>::~FP()
{
}

///////////////////////////////////////////////////////////////////////////////
// Interface - public :

/**
 * Checks the validity/consistency of the object.
 * @return 'true' if the object is valid, 'false' otherwise.
 */
template <typename TIterator, typename TInteger, int connectivity>
inline
bool
DGtal::FP<TIterator,TInteger,connectivity>::isValid() const
{
    return true;
}

/**
 * @return number of FP vertices
 */
template <typename TIterator, typename TInteger, int connectivity>
inline
typename FP<TIterator,TInteger,connectivity>::Polygon::size_type
DGtal::FP<TIterator,TInteger,connectivity>::size() const
{
    return myPolygon.size();
}


/**
 * @return the vertices of the FP
 * NB: O(n)
 */

template <typename TIterator, typename TInteger, int connectivity>
template <typename OutputIterator>
inline
OutputIterator
DGtal::FP<TIterator,TInteger,connectivity>::copyFP(OutputIterator result) const {
  typename Polygon::const_iterator i = myPolygon.begin();
  while ( i != myPolygon.end() ) {
    *result++ = *i++;
  }
  return result;
}

/**
 * @return the vertices of the MLP
 * NB: O(n)
 */

template <typename TIterator, typename TInteger, int connectivity>
template <typename OutputIterator>
inline
OutputIterator
DGtal::FP<TIterator,TInteger,connectivity>::copyMLP(OutputIterator result) const {

  typename Polygon::const_iterator i, j, k;
  i = myPolygon.begin();
  j = i; ++j; 
  k = j; ++k; 

  if (myFlagIsClosed) { ///////// closed

    //first point
    *result++ = getRealPoint(myPolygon.back(),*i,*j);
    //middle points
    while ( k != myPolygon.end() ) {
      *result++ = getRealPoint(*i,*j,*k);
      ++i; ++j; ++k; 
    }
    //last point
    *result++ = getRealPoint(*i,*j,myPolygon.front());

  } else { ////////////////////// open 

    //first point
    *result++ = RealPoint( myPolygon.front() );
    //middle points
    while ( k != myPolygon.end() ) {
      *result++ = getRealPoint(*i,*j,*k);
      ++i; ++j; ++k; 
    }
    //last point
    *result++ = RealPoint( myPolygon.back() );

  }
  return result;
}



/**
 * gets a MLP vertex from three consecutive vertices of the FP.
 * @param a previous vertex of the FP
 * @param b current vertex of the FP
 * @param c next vertex of the FP
 * @return vertex of the MLP, which is 
 * the tranlated of b by (+- 0.5, +- 0.5)
 */
template <typename TIterator, typename TInteger, int connectivity>
inline
DGtal::RealPointVector<2>
DGtal::FP<TIterator,TInteger,connectivity>
   ::getRealPoint (const Point& a,const Point& b, const Point& c) const {

	RealVector shift;

	Vector e1 = b - a; //previous edge
	Vector e2 = c - b; //next edge

	if ( (e1[0]*e2[1]-e1[1]*e2[0]) <= 0 ) {

		//convex turn
		if ( (quadrant(e1,1))&&(quadrant(e2,1)) ) {
			shift = RealVector(0.5,-0.5);
		} else if ( (quadrant(e1,2))&&(quadrant(e2,2)) ) {
			shift = RealVector(-0.5,-0.5);
		} else if ( (quadrant(e1,3))&&(quadrant(e2,3)) ) {
			shift = RealVector(-0.5,0.5);
		} else if ( (quadrant(e1,4))&&(quadrant(e2,4)) ) {
			shift = RealVector(0.5,0.5);
		} else {
      ASSERT(false && ("DGtal::FP<TIterator,TInteger,connectivity>::getRealPoint: not valid polygon")==""  );
		}

	} else {

		//concave turn
		if ( (quadrant(e1,1))&&(quadrant(e2,1)) ) {
			shift = RealVector(-0.5,0.5);
		} else if ( (quadrant(e1,2))&&(quadrant(e2,2)) ) {
			shift = RealVector(0.5,0.5);
		} else if ( (quadrant(e1,3))&&(quadrant(e2,3)) ) {
			shift = RealVector(0.5,-0.5);
		} else if ( (quadrant(e1,4))&&(quadrant(e2,4)) ) {
			shift = RealVector(-0.5,-0.5);
		} else {
      ASSERT(false && ("DGtal::FP<TIterator,TInteger,connectivity>::getRealPoint: not valid polygon")==""  );
		}

	} 

	return ( RealPoint(b) + shift );
}

template <typename TIterator, typename TInteger, int connectivity>
inline
bool
DGtal::FP<TIterator,TInteger,connectivity>
   ::quadrant (const Vector& v, const int& q) const {

	if (q == 1) {
		return ( (v[0]>=0)&&(v[1]>=0) );
	} else if (q == 2) {
		return ( (v[0]>=0)&&(v[1]<=0) );
	} else if (q == 3) {
		return ( (v[0]<=0)&&(v[1]<=0) );
	} else if (q == 4) {
		return ( (v[0]<=0)&&(v[1]>=0) );
	} else {
    ASSERT(false && 
("DGtal::FP<TIterator,TInteger,connectivity>::quadrant: quadrant number should be 0,1,2 or 3")==""  );
		return false;
	}
}

///////////////////////////////////////////////////////////////////////////////
// Display :

/**
 * Draw the bounding box of the DSS on a LiBoard board
 * @param board the output board where the object is drawn.
 */
template <typename TIterator, typename TInteger, int connectivity>
inline
void 
DGtal::FP<TIterator,TInteger,connectivity>::selfDrawAsPolygon( DGtalBoard & aBoard) const
{
  //polyline to draw
	vector<LibBoard::Point> polyline;

	typename Polygon::const_iterator i = myPolygon.begin();
	for ( ;i != myPolygon.end();++i) {
			Point p = (*i);
			double xp = IntegerTraits<TInteger>::castToInt64_t(p[0]);
			double yp = IntegerTraits<TInteger>::castToInt64_t(p[1]);
			polyline.push_back(LibBoard::Point(xp,yp));
	}

  aBoard.drawPolyline(polyline);

}

/**
 * Default drawing style object.
 * @return the dyn. alloc. default style for this object.
 */
template <typename TIterator, typename TInteger, int connectivity>
inline
DGtal::DrawableWithDGtalBoard*
DGtal::FP<TIterator,TInteger,connectivity>::defaultStyle( std::string mode ) const
{
	return new DefaultDrawStyle;
}

/**
 * @return the style name used for drawing this object.
 */
template <typename TIterator, typename TInteger, int connectivity>
inline
std::string
DGtal::FP<TIterator,TInteger,connectivity>::styleName() const
{
  return "FP";
}

/**
 * Draw the object on a LibBoard board.
 * @param board the output board where the object is drawn.
 */
template <typename TIterator, typename TInteger, int connectivity>
inline
void
DGtal::FP<TIterator,TInteger,connectivity>::selfDraw( DGtalBoard & board ) const
{
  std::string mode = board.getMode( styleName() );
  if ( mode == "Polygon" )
    selfDrawAsPolygon( board );
  else if ( ( mode == "Both" ) || ( mode == "" ) )
    {
      selfDrawAsPolygon( board );
    }
  else
    ASSERT(false && ("DGtal::FP<TIterator,TInteger,connectivity>::selfDraw: Unknown mode "+mode)==""  );

}


/**
 * Writes/Displays the object on an output stream.
 * @param out the output stream where the object is written.
 */
template <typename TIterator, typename TInteger, int connectivity>
inline
void
DGtal::FP<TIterator,TInteger,connectivity>::selfDisplay ( std::ostream & out ) const
{
  out << "[FP]" << endl;
	typename Polygon::const_iterator i = myPolygon.begin();
	for ( ;i != myPolygon.end();++i)
	{
		out << "\t " << (*i) << endl;
	}							
  out << "[end FP]" << endl;
}





///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions                                        //

template <typename TIterator, typename TInteger, int connectivity>
inline
std::ostream&
DGtal::operator<< ( std::ostream & out, 
		  const FP<TIterator,TInteger,connectivity> & object )
{
  object.selfDisplay( out );
  return out;
}

//                                                                           //
///////////////////////////////////////////////////////////////////////////////


