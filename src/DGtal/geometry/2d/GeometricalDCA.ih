/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file GeometricalDCA.ih
 * @author Tristan Roussillon (\c tristan.roussillon@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Syst√®mes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 *
 * @date 2011/09/26
 *
 * Implementation of inline methods defined in GeometricalDCA.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------

template <typename TConstIterator>
inline
DGtal::GeometricalDCA<TConstIterator>::GeometricalDCA()
:myBegin(), myEnd(), mySegPtr(new GeometricalDSS<ConstIterator>()), 
myCircle(), myFlagIsInit(false)
{
}

template <typename TConstIterator>
inline
DGtal::GeometricalDCA<TConstIterator>::GeometricalDCA( const Self& other )
:myBegin(other.myBegin), myEnd(other.myEnd), mySegPtr(other.mySegPtr), 
myCircle(other.myCircle), myFlagIsInit(other.myFlagIsInit)
{
}

template <typename TConstIterator>
inline
typename DGtal::GeometricalDCA<TConstIterator>::Self&
DGtal::GeometricalDCA<TConstIterator>::operator= ( const Self& other )
{
  if ( this != &other )
  {
    myBegin = other.myBegin;
    myEnd = other.myEnd;
    mySegPtr = other.mySegPtr;
    myCircle = other.myCircle;
    myFlagIsInit = other.myFlagIsInit; 
  }
  return *this;
}

template <typename TConstIterator>
inline
DGtal::GeometricalDCA<TConstIterator>::~GeometricalDCA()
{
}

template <typename TConstIterator>
inline
bool
DGtal::GeometricalDCA<TConstIterator>::operator==( const Self& other ) const
{
  if (isValid()&&other.isValid())
  {
    Pair firstPair( *myBegin );
    Pair oFirstPair( *(other.myBegin) ); 
    if ( (firstPair.first == oFirstPair.first)
       &&(firstPair.second == oFirstPair.second) )
    {
      ConstIterator it (myEnd); 
      --it;
      Pair lastPair( *it );  
      ConstIterator oIt (other.myEnd); 
      --oIt;
      Pair oLastPair( *oIt ); 
     
      if ( (lastPair.first == oLastPair.first)
         &&(lastPair.second == oLastPair.second) )
      {
        if (myFlagIsInit)
        {
          double a, b, r; 
          myCircle.getParameters(a,b,r); 
          double ap, bp, rp; 
          other.myCircle.getParameters(ap,bp,rp); 
          return ((a==ap)&&(b==bp)&&(r==rp)); 
        }
        else return (*mySegPtr == *other.mySegPtr); 
      }
      else return false; 
    } 
    else return false; 
  }
  else 
  {
    return ( (!isValid()) && (!other.isValid()) );
  }
}

template <typename TConstIterator>
inline
bool
DGtal::GeometricalDCA<TConstIterator>::operator!=( const Self& other ) const
{
  return !(*this == other); 
}

template <typename TConstIterator>
inline
typename DGtal::GeometricalDCA<TConstIterator>::Reverse
DGtal::GeometricalDCA<TConstIterator>::getReverse() const
{
  return Reverse(); 
}

///////////////////////////////////////////////////////////////////////////////
// Interface - public :

template <typename TConstIterator>
inline
bool
DGtal::GeometricalDCA<TConstIterator>::isValid() const
{
  if ( mySegPtr.get() != 0 )
  {
    return mySegPtr->isValid(); 
  }
  else 
  {
    return false;
  }
}

template <typename TConstIterator>
inline
typename DGtal::GeometricalDCA<TConstIterator>::ConstIterator
DGtal::GeometricalDCA<TConstIterator>::begin() const
{
  return myBegin;
}

template <typename TConstIterator>
inline
typename DGtal::GeometricalDCA<TConstIterator>::ConstIterator
DGtal::GeometricalDCA<TConstIterator>::end() const
{
  return myEnd;
}


///////////////////////////////////////////////////////////////////////////////
// Growth operations                                                        //

template <typename TConstIterator>
template <typename TIterator>
inline
bool 
DGtal::GeometricalDCA<TConstIterator>::isCircularlySeparable(
  const TIterator& itb, const TIterator& ite, 
  const Point& aPole, 
  Point& Pf, Point& Pl, Point& Qf, Point& Ql)
{
std::cout << "\t to update with " << aPole << std::endl; 
  ASSERT( itb != ite ); 
  TIterator it( itb ); 
  Pair currentPair( *it ); 
  
  //preimage of circles passing through aPole
  CircleFrom2Points<Point> aCircle( aPole ); 
  Preimage2D<CircleFrom2Points<Point> >
    thePreimage( currentPair.first, currentPair.second, aCircle );
  
  bool isOK = true; 
  ++it;
  if (it != ite) 
  { //if more than one pair
    currentPair = *it; 
    if ( thePreimage.addFront(currentPair.first, currentPair.second) )
    { //if CW oriented
      isOK = true; 
      while ( (it != ite)&&(isOK) ) 
      {
        currentPair = *it; 
        isOK = thePreimage.addFront(currentPair.first, currentPair.second); 
        ++it;
      }
    }
    else if ( thePreimage.addBack(currentPair.first, currentPair.second) )
    { // if CCW oriented
      isOK = true; 
      while ( (it != ite)&&(isOK) ) 
      {
        currentPair = *it; 
        isOK = thePreimage.addBack(currentPair.first, currentPair.second); 
        ++it;
      }
    } else isOK = false; 
    
  } //if only one pair => circularly separable
    
  if (isOK)
  {//points of support
    Pf = thePreimage.getUf(); 
    Pl = thePreimage.getUl(); 
    Qf = thePreimage.getLf(); 
    Ql = thePreimage.getLl();
    return true; 
  } else return false; 
}

template <typename TConstIterator>
inline
void
DGtal::GeometricalDCA<TConstIterator>::init(const ConstIterator& anIt)
{
  //initialize the iterators
  myBegin = anIt; 
  myEnd = anIt; 
  ++myEnd; 

  //...the geometrical DSS
  mySegPtr->init( anIt ); 

  //...the circle as degenerated
  Pair aPair( *anIt); 
  myCircle = Circle(aPair.first, aPair.first, aPair.first);
}

template <typename TConstIterator>
inline
bool
DGtal::GeometricalDCA<TConstIterator>::isExtendable()
{
  ASSERT( mySegPtr.get() != 0 ); 
  bool isOK = false; 
  
//TODO

  return isOK; 
}

template <typename TConstIterator>
inline
bool
DGtal::GeometricalDCA<TConstIterator>::extend()
{
  ASSERT( mySegPtr.get() != 0 ); 
  Pair aPair( *myEnd ); 
  Point aP( aPair.first ); 
  Point aQ( aPair.second ); 
  bool isOK = false; 

  if (myFlagIsInit)
  { //initialized
std::cout << "Circle test " << aP << aQ << std::endl; 
    //predicates
    PInCirclePred p1( myCircle ); 
    QInCirclePred p2( myCircle ); 
    
    if ( p1(aP)&&p2(aQ) )
      isOK = true; 
    else
    { //update separating circle
      if (!p1(aP))
      {
        Point Pf, Pl, Qf, Ql;
        if (isCircularlySeparable(myBegin,myEnd,aP,Pf,Pl,Qf,Ql))
        {
          myCircle.init(Pf,Ql,aP); 
std::cout << "\t new circle" << myCircle << std::endl; 
          isOK = true; 
        }
      }
      else if (!p2(aQ))
      {
        Point Pf, Pl, Qf, Ql;
        if (isCircularlySeparable(myBegin,myEnd,aQ,Pf,Pl,Qf,Ql))
        {
          myCircle.init(Qf,Pl,aQ); 
std::cout << "\t new circle" << myCircle << std::endl; 
          isOK = true; 
        }
      }
      else ASSERT( false && ("DGtal::GeometricalDCA<TConstIterator>::extend(): impossible case") );  
    }
    
  } else
  { //not initialized yet
std::cout << "GeometricalDSS Extension" << std::endl; 
    if ( mySegPtr->extend() ) isOK = true; 
    else
    {
      Point Pf, Pl, Qf, Ql; 
      if (mySegPtr->isConvex())
      { //convex part
        if (isCircularlySeparable(myBegin,myEnd,aQ,Pf,Pl,Qf,Ql))
        {
          myCircle.init(Qf,Pl,aQ); 
          myFlagIsInit = true;
          isOK = true; 
        }
      }
      else if (mySegPtr->isConcave())
      { //concave part
        if (isCircularlySeparable(myBegin,myEnd,aP,Pf,Pl,Qf,Ql))
        {
          myCircle.init(Pf,Ql,aP); 
          myFlagIsInit = true;
          isOK = true; 
        }
      }
      else ASSERT( false && ("DGtal::GeometricalDCA<TConstIterator>::extend(): impossible case") ); 
    }
  }
  
  if (isOK) 
  {
    ++myEnd; 
    return true; 
  } else return false; 
}

template <typename TConstIterator>
inline
bool
DGtal::GeometricalDCA<TConstIterator>::isOppositeEndExtendable()
{
  ASSERT( mySegPtr.get() != 0 ); 
  ConstIterator it( myBegin ); 
  --it; 
  Pair aPair( *it ); 
  bool isOK = false; 
  
//TODO
  
  return isOK; 
}

template <typename TConstIterator>
inline
bool
DGtal::GeometricalDCA<TConstIterator>::extendOppositeEnd()
{
  ASSERT( mySegPtr.get() != 0 ); 
  ConstIterator it( myBegin ); 
  --it; 
  Pair aPair( *it ); 
  bool isOK = false; 
  
//TODO

  if (isOK) 
  {
    myBegin = it; 
    return true; 
  } else return false; 
}

///////////////////////////////////////////////////////////////////////////////
// Display :

template <typename TConstIterator>
inline
void
DGtal::GeometricalDCA<TConstIterator>::selfDisplay ( std::ostream & out ) const
{
  out << std::endl;
  out << "[GeometricalDCA]" << std::endl;
  if (isValid())
  {
    Pair firstPair( *myBegin ); 
    out << "\t From " << firstPair.first << firstPair.second << std::endl; 
    ConstIterator it (myEnd); 
    --it;
    Pair lastPair( *it );  
    out << "\t To " << lastPair.first << lastPair.second << std::endl; 
    if (myFlagIsInit) 
      out << myCircle << std::endl; 
    else 
      out << "infinite radius" << std::endl; 
  }
  else
  {
    out << "\t not valid" << std::endl; 
  }
  out << "[end of GeometricalDCA]" << std::endl;
}


template <typename TConstIterator>
inline
DGtal::DrawableWithBoard2D*
DGtal::GeometricalDCA<TConstIterator>::defaultStyle( std::string /*mode*/ ) const
{
  return new DefaultDrawStyle(); 
}

template <typename TConstIterator>
inline
std::string
DGtal::GeometricalDCA<TConstIterator>::styleName() const
{
  return "GeometricalDCA";
}

template <typename TConstIterator>
inline
void 
DGtal::GeometricalDCA<TConstIterator>::selfDraw(Board2D & aBoard) const
{

  if (isValid())
  {
    if (myFlagIsInit) 
    {
      //points
      Pair firstPair( *myBegin ); 
      ConstIterator it (myEnd); 
      --it;
      Pair lastPair( *it );  

      //mode
      std::string mode = aBoard.getMode( styleName() );
      if ( mode == "Sector" ) 
        myCircle.drawSector( aBoard, firstPair.first, lastPair.first );
      else if ( mode == "Annulus" )
        myCircle.drawAnnulus( aBoard, firstPair.first, lastPair.first );
      else 
        myCircle.drawArc( aBoard, firstPair.first, lastPair.first );
    }
    else 
    {
      ASSERT( mySegPtr.get() != 0 ); 
      aBoard << (*mySegPtr);
    } 
  }
}


///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions                                        //

template <typename TConstIterator>
inline
std::ostream&
DGtal::operator<< ( std::ostream & out, 
		  const GeometricalDCA<TConstIterator> & object )
{
  object.selfDisplay( out );
  return out;
}

//                                                                           //
///////////////////////////////////////////////////////////////////////////////


