/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/
//LICENSE-END
/**
 * @file ArithDSS4.ih
 * @author Tristan Roussillon (\c tristan.roussillon@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Syst√®mes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 *
 * @date 2010/07/02
 *
 * Implementation of inline methods defined in ArithDSS4.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------

/**
 * Destructor.
 */
template <typename Domain2D>
inline
DGtal::ArithDSS4<Domain2D>::~ArithDSS4()
{
}

/**
 * Constructor.
 */
template <typename Domain2D>
DGtal::ArithDSS4<Domain2D>::ArithDSS4(
	 const Point& aFirstPoint, 
	 const Point& aSecondPoint)
{

	ASSERT(DGtal::ArithDSS4<Domain2D>::Point::Dimension == 2 && "only valid for 2D");

	Vector step = aSecondPoint - aFirstPoint;
	Integer deviation = norm(step[0],step[1]);
	if ( deviation != 1) throw InputException();

	this->myF = aFirstPoint;
	this->myL = aSecondPoint;

	this->myUf = aFirstPoint;
	this->myLf = aFirstPoint;
	this->myUl = aSecondPoint;
	this->myLl = aSecondPoint;

	this->myA = this->myUl.at(1) - this->myUf.at(1); 
	this->myB = this->myUl.at(0) - this->myUf.at(0); 
	this->myMu = this->myA*this->myUl.at(0) - this->myB*this->myUl.at(1);
	this->myOmega = norm(this->myA,this->myB);

}


///////////////////////////////////////////////////////////////////////////////
// Interface - public :

template <typename Domain2D>
inline
typename DGtal::ArithDSS4<Domain2D>::Integer 
DGtal::ArithDSS4<Domain2D>::norm(
			const Integer & x, 
			const Integer & y) const 
{
	return std::abs(x)+std::abs(y);
}

template <typename Domain2D>
inline
bool
DGtal::ArithDSS4<Domain2D>::sameQuadrant(const Vector& aVec) const 
{
	bool flag = true;
	if ( this->myA > 0 ) { 
		if (aVec == Vector(0,-1)) flag = false;
	} 
	if ( this->myA < 0 ) { 
		if (aVec == Vector(0,1)) flag = false;
	} 
	if ( this->myB > 0 ) { 
		if (aVec == Vector(-1,0)) flag = false;
	} 
	if ( this->myB < 0 ) { 
		if (aVec == Vector(1,0)) flag = false;
	} 
	
	return flag;

}

template <typename Domain2D>
inline
typename DGtal::ArithDSS4<Domain2D>::Vector 
DGtal::ArithDSS4<Domain2D>::vectorFrom0ToOmega() const 
{
	if (this->myA >= 0) {
		if (this->myB >= 0) return Vector(1,-1);
		else return Vector(1,1);
	} else {
		if (this->myB >= 0) return Vector(-1,-1);
		else return Vector(-1,1);
	}
}

template <typename Domain2D>
inline
typename DGtal::ArithDSS4<Domain2D>::Point
DGtal::ArithDSS4<Domain2D>::next(
			const Point & aPoint) const 
{



	Integer r = this->myA*aPoint[0] - this->myB*aPoint[1];
	ASSERT( (r >= this->myMu)&&(r < this->myMu+this->myOmega) );


	Vector step; 
	if ( this->myA >= 0 ) { //quadrant 1
		if ( this->myB >= 0 ) { 
			if ( (r-this->myB >= this->myMu)&&
						(r-this->myB < this->myMu+this->myOmega) ) {
					step = Vector(0,1);
			} else {
					step = Vector(1,0);
			}
		} else {              //quadrant 2
			if ( (r-this->myB >= this->myMu)&&
						(r-this->myB < this->myMu+this->myOmega) ) {
					step = Vector(0,1);
			} else {
					step = Vector(-1,0);
			}
		}
	} else {
		if ( this->myB >= 0 ) {//quadrant 4 
			if ( (r+this->myB >= this->myMu)&&
						(r+this->myB < this->myMu+this->myOmega) ) {
					step = Vector(0,-1);
			} else {
					step = Vector(1,0);
			}
		} else {               //quadrant 3
			if ( (r+this->myB >= this->myMu)&&
						(r+this->myB < this->myMu+this->myOmega) ) {
					step = Vector(0,-1);
			} else {
					step = Vector(-1,0);
			}
		}
	}

	return aPoint + step;
}
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


