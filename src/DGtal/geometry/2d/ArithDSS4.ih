/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/
//LICENSE-END
/**
 * @file ArithDSS4.ih
 * @author Tristan Roussillon (\c tristan.roussillon@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Syst√®mes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 *
 * @date 2010/07/02
 *
 * Implementation of inline methods defined in ArithDSS4.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------

/**
 * Destructor.
 */
template <typename Domain2D>
inline
DGtal::ArithDSS4<Domain2D>::~ArithDSS4()
{
}

/**
 * Constructor.
 */
template <typename Domain2D>
DGtal::ArithDSS4<Domain2D>::ArithDSS4(
	 const typename DGtal::ArithDSS4<Domain2D>::Point& aFirstPoint, 
	 const typename DGtal::ArithDSS4<Domain2D>::Point& aSecondPoint)
{

	//todo: 
	//ASSERT(DGtal::ArithDSS4<Domain2D>::Point::staticDimension == 2);

	//todo: checks connexity

	this->myF = aFirstPoint;
	this->myL = aSecondPoint;

	this->myUf = aFirstPoint;
	this->myLf = aFirstPoint;
	this->myUl = aSecondPoint;
	this->myLl = aSecondPoint;

	this->myA = this->myUl.at(1) - this->myUf.at(1); 
	this->myB = this->myUl.at(0) - this->myUf.at(0); 
	this->myMu = this->myA*this->myUl.at(0) - this->myB*this->myUl.at(1);
	this->myOmega = norm(this->myA,this->myB);

}


///////////////////////////////////////////////////////////////////////////////
// Interface - public :

template <typename Domain2D>
inline
typename DGtal::ArithDSS4<Domain2D>::Integer 
DGtal::ArithDSS4<Domain2D>::norm(
			const typename DGtal::ArithDSS4<Domain2D>::Integer & x, 
			const typename DGtal::ArithDSS4<Domain2D>::Integer & y) const 
{
	return std::abs(x)+std::abs(y);
}

template <typename Domain2D>
inline
typename DGtal::ArithDSS4<Domain2D>::Vector 
DGtal::ArithDSS4<Domain2D>::vectorFrom0ToOmega() const 
{
	return Vector(1,-1);
}

template <typename Domain2D>
inline
typename DGtal::ArithDSS4<Domain2D>::Point
DGtal::ArithDSS4<Domain2D>::next(
			const typename DGtal::ArithDSS4<Domain2D>::Point & aPoint) const 
{

  Integer r = this->myA*aPoint[0] - this->myB*aPoint[1]; //remainder of aPoint
	//verifier que aPoint soit dans le DSS!

	Vector step; 
	if ( (r-this->myB >= this->myMu)&&(r-this->myB < this->myMu+this->myOmega) ) {
			step = Vector(0,this->myB/std::abs(this->myB));
	} else if ( (r+this->myA >= this->myMu)&&(r+this->myA < this->myMu+this->myOmega) ) {
			step = Vector(this->myA/std::abs(this->myA),0);
	}

	return aPoint + step;
}
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


