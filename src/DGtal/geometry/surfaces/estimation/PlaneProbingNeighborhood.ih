/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file
 * @author Jocelyn Meyron (\c jocelyn.meyron@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Systemes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 *
 * @date 2020/12/04
 *
 * Implementation of inline methods defined in PlaneProbingNeighborhood.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
#include "DGtal/geometry/surfaces/estimation/PlaneProbingEstimatorCommon.h"
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// INITIALIZATION of static data.
///////////////////////////////////////////////////////////////////////////////

template < typename TPredicate >
const DGtal::detail::ProbingRay DGtal::PlaneProbingNeighborhood<TPredicate>::myNeighborhood[6] =
{
    DGtal::detail::ProbingRay({0, 1, 2}), DGtal::detail::ProbingRay({0, 2, 1}),
    DGtal::detail::ProbingRay({1, 2, 0}), DGtal::detail::ProbingRay({1, 0, 2}),
    DGtal::detail::ProbingRay({2, 0, 1}), DGtal::detail::ProbingRay({2, 1, 0}),
};

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------

// ------------------------------------------------------------------------
template < typename TPredicate >
DGtal::PlaneProbingNeighborhood<TPredicate>::
PlaneProbingNeighborhood(Predicate const& aPredicate, Point const& aQ, Triangle const& aM)
    : myPredicate(aPredicate), myQ(aQ), myM(aM)
{}

// ------------------------------------------------------------------------
template < typename TPredicate >
DGtal::PlaneProbingNeighborhood<TPredicate>::~PlaneProbingNeighborhood()
{}

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Plane Probing services ------------------------------

// ------------------------------------------------------------------------
template < typename TPredicate >
DGtal::detail::ProbingRay
DGtal::PlaneProbingNeighborhood<TPredicate>::closestPointInList (std::vector<ProbingRay> const& aPoints) const
{
    int N = aPoints.size();
    if (N == 1) {
        return aPoints[0];
    }

    ProbingRay minPoint = aPoints[N-1];
    for (int k = 0; k < N-1; ++k) {
        if (isSmallest(-minPoint.getRelPt(myM), -aPoints[k].getRelPt(myM))) {
            minPoint = aPoints[k];
        }
    }

    return minPoint;
}

// ------------------------------------------------------------------------
template < typename TPredicate >
bool DGtal::PlaneProbingNeighborhood<TPredicate>::
closestCandidate (std::vector<DGtal::detail::ProbingRay> const& neighbors, DGtal::detail::ProbingRay& closest)
{
    myNeighbors = neighbors;

    myPoints.clear();
    compute();

    std::vector<DGtal::detail::ProbingRay> innerPoints(myPoints.begin(), myPoints.end());

    if (innerPoints.size() == 0) {
        return false;
    }

    closest = closestPointInList(innerPoints);

    return true;
}

// ------------------------------------------------------------------------
template < typename TPredicate >
std::vector<typename DGtal::PlaneProbingNeighborhood<TPredicate>::ProbingRay>
DGtal::PlaneProbingNeighborhood<TPredicate>::getNeighbors () const
{
    if (myNeighbors.size() > 0)
    {
        return myNeighbors;
    }

    return std::vector<ProbingRay>(myNeighborhood, myNeighborhood + 6);
}

// ------------------------------------------------------------------------
template < typename TPredicate >
bool
DGtal::PlaneProbingNeighborhood<TPredicate>::
isSmallest (Point const& aX,
            Point const& aY) const
{
    Integer zero = DGtal::NumberTraits<Integer>::ZERO;

    std::array<Point, 5> ps;
    for (int i = 0; i < 3; ++i)
    {
        ps[i] = -myM[i];
    }
    ps[3] = aX;
    ps[4] = aY;

    Integer res = DGtal::detail::distToSphere(ps);
    if (res == zero) {
        return aY < aX;
    } else if (res < zero) {
        return true;
    } else {
        return false;
    }
}


///////////////////////////////////////////////////////////////////////////////
// Interface - public :

/**
 * Writes/Displays the object on an output stream.
 * @param out the output stream where the object is written.
 */
template <typename T>
inline
void
DGtal::PlaneProbingNeighborhood<T>::selfDisplay ( std::ostream & out ) const
{
  out << "[PlaneProbingNeighborhood]";
}

/**
 * Checks the validity/consistency of the object.
 * @return 'true' if the object is valid, 'false' otherwise.
 */
template <typename T>
inline
bool
DGtal::PlaneProbingNeighborhood<T>::isValid() const
{
    return true;
}



///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions                                        //

template <typename T>
inline
std::ostream&
DGtal::operator<< ( std::ostream & out,
                  const PlaneProbingNeighborhood<T> & object )
{
  object.selfDisplay( out );
  return out;
}

//                                                                           //
///////////////////////////////////////////////////////////////////////////////


