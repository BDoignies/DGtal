/* 
 * Useful to avoid writing DGtal:: in front of every class.
 */
namespace DGtal {

/**
   
@page tutoPolyhedralisation  Tutorial: making a polyhedron from a digital object

@writers Jacques-Olivier Lachaud

This tutorial shows you how to construct a polyhedron (polyhedral
surface) from a digital object. It uses several ingredients of DGtal:

- readers: to read an ".obj" file into memory (class VolReader)
- images: to store the ".obj" file into memory (class ImageContainerBySTLVector, class SimpleThresholdForegroundPredicate)
- predicate: to represent the characteristic function of the digital object
- cellular space: the cellular digital space in which the boundary of the digital object is well defined
- digital surface: to connect all boundary elements of the digital object as a graph
- graph visitor: to define neighborhoods on the digital object boundary
- digital plane computer: to recognize points of the boundary that belongs to the same plane
- umbrellas: to decompose the digital surface into cells
- viewers: to see intermediate and final results of our algorithm

[TOC]

\section tutoPolyhedralisation_sec1 Set up your project

We will write a new C++ source file (say polyhedralizer.cpp) that uses
the DGtal library. You can follow for instance \ref
moduleHowToUseDGtal. Then you can already start with the following
skeleton that includes the main required headers (Qt will be used for
displaying results).

\code
#include <iostream>
#include <vector>
#include <set>
#include <map>
#include <queue>
#include <QtGui/qapplication.h>
#include "DGtal/base/Common.h"
#include "DGtal/helpers/StdDefs.h"
\endcode

We will also play with some .vol file. There are a few in the
directory DGtal/examples/samples. We pick below the Al Capone volume
file. The program will also be parameterized by the `threshold` value on
the volume file and the integers `wp` and `wq`, such that `wp`/`wq` is the
tolerance used for decomposing the volume boundary into planes.

\code
using namespace std;
using namespace DGtal;
using namespace Z3i;
int main( int argc, char** argv )
{
  QApplication application(argc,argv);
  string inputFilename = argc > 1 ? argv[ 1 ] : "DGtal/examples/samples/Al.100.vol";
  int threshold = argc > 2 ? atoi( argv[ 2 ] ) : 0; // volume is (val > threshold)
  int wp = argc > 3 ? atoi( argv[ 3 ] ) : 1;
  int wq = argc > 4 ? atoi( argv[ 4 ] ) : 1;
  ...
  return 0;
}
\endcode

\section tutoPolyhedralisation_sec2 Reading the volume file and making the digital object

We store our volume as an image, i.e. a raster of value. We therefore
use the class ImageContainerBySTLVector, parameterized by the usual
Domain of Z3 (defined in namespace Z3i) and `int`.

\code
  typedef ImageContainerBySTLVector< Domain, int> Image;
  Image image = VolReader<Image>::importVol(inputFilename);
\endcode

However an image is not a digital object. We define a digital object
implicitly as a Predicate : Point -> bool. Hence, we define the
digital object as a threshold of the image with class
SimpleThresholdForegroundPredicate.

\code
  typedef SimpleThresholdForegroundPredicate<Image> DigitalObject;
  DigitalObject digitalObject( image, threshold );
\endcode

Of course, class SimpleThresholdForegroundPredicate is a wrapper
around the image and only references the image.

\section tutoPolyhedralisation_sec3 Wrapping a surface around the boundary of the digital object




*/

}
