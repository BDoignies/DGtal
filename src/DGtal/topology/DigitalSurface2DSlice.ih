/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file DigitalSurface2DSlice.ih
 * @author Jacques-Olivier Lachaud (\c jacques-olivier.lachaud@univ-savoie.fr )
 * Laboratory of Mathematics (CNRS, UMR 5127), University of Savoie, France
 *
 * @date 2012/02/29
 *
 * Implementation of inline methods defined in DigitalSurface2DSlice.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------

/**
 * Destructor.
 */
template <typename TDigitalSurfaceContainer>
inline
DGtal::DigitalSurface2DSlice<TDigitalSurfaceContainer>::
~DigitalSurface2DSlice()
{
}
//-----------------------------------------------------------------------------
template <typename TDigitalSurfaceContainer>
inline
DGtal::DigitalSurface2DSlice<TDigitalSurfaceContainer>::
DigitalSurface2DSlice( DigitalSurfaceTracker* tracker, 
                       Dimension i )
{
  init( tracker, i );
}
//-----------------------------------------------------------------------------
template <typename TDigitalSurfaceContainer>
bool 
DGtal::DigitalSurface2DSlice<TDigitalSurfaceContainer>::
init( DigitalSurfaceTracker* tracker, Dimension i )
{
  const KSpace & K = tracker->surface().space();
  Surfel start = tracker->current(); // the start surfel
  Surfel current;  // the current surfel during the extraction
  Surfel next;     // the surfel after the current surfel during the extraction
  uint8_t code = 0;// the code turn when going to the next surfel.
  Dimension j = i; // the current tracking direction.
  if ( K.sOrthDir( start ) == i ) return false;
  do
    {
      current = tracker->current();
      mySurfels.push_back( current );
      bool direct = K.sDirect( current, j );
      code = tracker->adjacent( next, j, direct );
      if ( code == 0 ) break; // slice is open
      if ( code != 2 ) // 1 or 3, swap tracking dir and orthogonal dir.
        j = K.sOrthDir( current );
      tracker->move( next );
    }
  while ( next != start );
  // Test if we have looped or if the slice is open.
  myIsClosed = code != 0;
  if ( ! myIsClosed )
    { // open slice 
      tracker->move( start );
      j = i;
      current = start;
      bool indirect = ! K.sDirect( current, j );
      while ( code = tracker->adjacent( next, j, indirect ) )
        { // valid movement;
          mySurfels.push_front( next );
          if ( code != 2 ) // 1 or 3, swap tracking dir and orthogonal dir.
            j = K.sOrthDir( current );
          tracker->move( next );
          current = next;
          indirect = ! K.sDirect( current, j );
        }
    }
  return true;
}
//-----------------------------------------------------------------------------
template <typename TDigitalSurfaceContainer>
inline
typename DGtal::DigitalSurface2DSlice<TDigitalSurfaceContainer>::Size
DGtal::DigitalSurface2DSlice<TDigitalSurfaceContainer>::
size() const
{
  return mySurfels.size();
}

//-----------------------------------------------------------------------------
template <typename TDigitalSurfaceContainer>
inline
typename DGtal::DigitalSurface2DSlice<TDigitalSurfaceContainer>::ConstIterator
DGtal::DigitalSurface2DSlice<TDigitalSurfaceContainer>::
begin() const
{
  return mySurfels.begin();
}
//-----------------------------------------------------------------------------
template <typename TDigitalSurfaceContainer>
inline
typename DGtal::DigitalSurface2DSlice<TDigitalSurfaceContainer>::ConstIterator
DGtal::DigitalSurface2DSlice<TDigitalSurfaceContainer>::
end() const
{
  return mySurfels.end();
}
//-----------------------------------------------------------------------------
template <typename TDigitalSurfaceContainer>
inline
typename DGtal::DigitalSurface2DSlice<TDigitalSurfaceContainer>::ConstReverseIterator
DGtal::DigitalSurface2DSlice<TDigitalSurfaceContainer>::
rbegin() const
{
  return mySurfels.rbegin();
}
//-----------------------------------------------------------------------------
template <typename TDigitalSurfaceContainer>
inline
typename DGtal::DigitalSurface2DSlice<TDigitalSurfaceContainer>::ConstReverseIterator
DGtal::DigitalSurface2DSlice<TDigitalSurfaceContainer>::
rend() const
{
  return mySurfels.rend();
}
//-----------------------------------------------------------------------------
template <typename TDigitalSurfaceContainer>
inline
typename DGtal::DigitalSurface2DSlice<TDigitalSurfaceContainer>::ConstCirculator
DGtal::DigitalSurface2DSlice<TDigitalSurfaceContainer>::
c() const
{
  return ConstCirculator( this->begin(), this->begin(), this->end() );
}
//-----------------------------------------------------------------------------
template <typename TDigitalSurfaceContainer>
inline
typename DGtal::DigitalSurface2DSlice<TDigitalSurfaceContainer>::ConstReverseCirculator
DGtal::DigitalSurface2DSlice<TDigitalSurfaceContainer>::
rc() const
{
  return ConstReverseCirculator( this->c() );
}

///////////////////////////////////////////////////////////////////////////////
// Interface - public :

/**
 * Writes/Displays the object on an output stream.
 * @param out the output stream where the object is written.
 */
template <typename TDigitalSurfaceContainer>
inline
void
DGtal::DigitalSurface2DSlice<TDigitalSurfaceContainer>::selfDisplay ( std::ostream & out ) const
{
  out << "[DigitalSurface2DSlice]";
}

/**
 * Checks the validity/consistency of the object.
 * @return 'true' if the object is valid, 'false' otherwise.
 */
template <typename TDigitalSurfaceContainer>
inline
bool
DGtal::DigitalSurface2DSlice<TDigitalSurfaceContainer>::isValid() const
{
    return true;
}



///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions                                        //

template <typename TDigitalSurfaceContainer>
inline
std::ostream&
DGtal::operator<< ( std::ostream & out, 
		  const DigitalSurface2DSlice<TDigitalSurfaceContainer> & object )
{
  object.selfDisplay( out );
  return out;
}

//                                                                           //
///////////////////////////////////////////////////////////////////////////////


