/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file CubicalComplex.ih
 * @author Jacques-Olivier Lachaud (\c jacques-olivier.lachaud@univ-savoie.fr )
 * Laboratory of Mathematics (CNRS, UMR 5127), University of Savoie, France
 *
 * @date 2015/08/28
 *
 * Implementation of inline methods defined in CubicalComplex.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
#include <queue>
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------

//-----------------------------------------------------------------------------
template <typename TKSpace, typename TCellContainer>
inline
DGtal::CubicalComplex<TKSpace, TCellContainer>::
~CubicalComplex()
{
}

//-----------------------------------------------------------------------------
template <typename TKSpace, typename TCellContainer>
inline
DGtal::CubicalComplex<TKSpace, TCellContainer>::
CubicalComplex( ConstAlias<KSpace> aK )
  : myKSpace( &aK ), myCells( dimension+1 )
{
}

//-----------------------------------------------------------------------------
template <typename TKSpace, typename TCellContainer>
inline
DGtal::CubicalComplex<TKSpace, TCellContainer>::
CubicalComplex( const CubicalComplex& other )
  : myKSpace( other.myKSpace ), myCells( other.myCells )
{
}

//-----------------------------------------------------------------------------
template <typename TKSpace, typename TCellContainer>
inline
const typename DGtal::CubicalComplex<TKSpace, TCellContainer>::KSpace &
DGtal::CubicalComplex<TKSpace, TCellContainer>::
space() const
{
  return *myKSpace;
}

//-----------------------------------------------------------------------------
template <typename TKSpace, typename TCellContainer>
inline
DGtal::CubicalComplex<TKSpace, TCellContainer>&
DGtal::CubicalComplex<TKSpace, TCellContainer>::
operator=( const CubicalComplex& other )
{
  if ( this != &other )
    {
      myKSpace = other.myKSpace;
      myCells  = other.myCells; 
    }
  return *this;
}

//-----------------------------------------------------------------------------
template <typename TKSpace, typename TCellContainer>
inline
void
DGtal::CubicalComplex<TKSpace, TCellContainer>::
clear()
{
  for ( Dimension d = 0; d <= dimension; ++d )
    clear( d );
}
//-----------------------------------------------------------------------------
template <typename TKSpace, typename TCellContainer>
inline
void
DGtal::CubicalComplex<TKSpace, TCellContainer>::
clear( Dimension d )
{
  myCells[ d ].clear();
}

//-----------------------------------------------------------------------------
template <typename TKSpace, typename TCellContainer>
inline
DGtal::Dimension
DGtal::CubicalComplex<TKSpace, TCellContainer>::
dim() const
{
  Dimension d = myCells.size()-1;
  for ( typename std::vector<CellMap>::const_reverse_iterator it = myCells.rbegin(), itE = myCells.rend();
        it != itE; ++it, --d )
    if ( ! it->empty() ) return d;
  return 0;
}
//-----------------------------------------------------------------------------
template <typename TKSpace, typename TCellContainer>
inline
DGtal::Dimension
DGtal::CubicalComplex<TKSpace, TCellContainer>::
dim( const Cell& c ) const
{
  return myKSpace->uDim( c );
}

//-----------------------------------------------------------------------------
template <typename TKSpace, typename TCellContainer>
inline
void
DGtal::CubicalComplex<TKSpace, TCellContainer>::
insertCell( const Cell& aCell, const Data& data )
{
  insertCell( myKSpace->uDim( aCell ), aCell, data );
}
//-----------------------------------------------------------------------------
template <typename TKSpace, typename TCellContainer>
inline
void
DGtal::CubicalComplex<TKSpace, TCellContainer>::
insertCell( Dimension d, const Cell& aCell, const Data& data )
{
  myCells[ d ][ aCell ] = data;
}

//-----------------------------------------------------------------------------
template <typename TKSpace, typename TCellContainer>
template <typename CellConstIterator>
inline
void
DGtal::CubicalComplex<TKSpace, TCellContainer>::
insertCells( CellConstIterator it, CellConstIterator itE )
{
  for ( ; it != itE; ++it )
    insertCell( *it );
}

//-----------------------------------------------------------------------------
template <typename TKSpace, typename TCellContainer>
template <typename CellConstIterator>
inline
void
DGtal::CubicalComplex<TKSpace, TCellContainer>::
insertCells( Dimension d, CellConstIterator it, CellConstIterator itE )
{
  for ( ; it != itE; ++it )
    insertCell( d, *it );
}

//-----------------------------------------------------------------------------
template <typename TKSpace, typename TCellContainer>
inline
bool
DGtal::CubicalComplex<TKSpace, TCellContainer>::
belongs( const Cell& aCell ) const
{
  return belongs( myKSpace->uDim( aCell ), aCell );
}
//-----------------------------------------------------------------------------
template <typename TKSpace, typename TCellContainer>
inline
bool
DGtal::CubicalComplex<TKSpace, TCellContainer>::
belongs( Dimension d, const Cell& aCell ) const
{
  ASSERT( d <= dimension+1 );
  CellMapConstIterator it = myCells[ d ].find( aCell );
  return it != myCells[ d ].end();
}
//-----------------------------------------------------------------------------
template <typename TKSpace, typename TCellContainer>
template <typename CellOutputIterator>
inline
void
DGtal::CubicalComplex<TKSpace, TCellContainer>::
faces( CellOutputIterator& outIt, const Cell& aCell, bool hintClosed )
{
  Cells all_proper_faces = myKSpace->uFaces( aCell );
  if ( hintClosed )
    std::copy( all_proper_faces.begin(), all_proper_faces.end(), outIt );
  else
    for ( typename Cells::ConstIterator it = all_proper_faces.begin(), 
            itE = all_proper_faces.end(); it != itE; ++it )
      if ( belongs( *it ) )
        *outIt++ = *it;
}
//-----------------------------------------------------------------------------
template <typename TKSpace, typename TCellContainer>
template <typename CellOutputIterator>
inline
void
DGtal::CubicalComplex<TKSpace, TCellContainer>::
coFaces( CellOutputIterator& outIt, const Cell& aCell, bool hintOpen )
{
  Cells all_proper_co_faces = myKSpace->uCoFaces( aCell );
  if ( hintOpen )
    std::copy( all_proper_co_faces.begin(), all_proper_co_faces.end(), outIt );
  else
    for ( typename Cells::ConstIterator it = all_proper_co_faces.begin(), 
            itE = all_proper_co_faces.end(); it != itE; ++it )
      if ( belongs( *it ) )
        *outIt++ = *it;
}
//-----------------------------------------------------------------------------
template <typename TKSpace, typename TCellContainer>
template <typename CellOutputIterator>
inline
void
DGtal::CubicalComplex<TKSpace, TCellContainer>::
directFaces( CellOutputIterator& outIt, const Cell& aCell, bool hintClosed )
{
  Cells all_direct_faces = myKSpace->uLowerIncident( aCell );
  if ( hintClosed )
    std::copy( all_direct_faces.begin(), all_direct_faces.end(), outIt );
  else
    for ( typename Cells::ConstIterator it = all_direct_faces.begin(), 
            itE = all_direct_faces.end(); it != itE; ++it )
      if ( belongs( *it ) )
        *outIt++ = *it;
}
//-----------------------------------------------------------------------------
template <typename TKSpace, typename TCellContainer>
template <typename CellMapIteratorOutputIterator>
inline
void
DGtal::CubicalComplex<TKSpace, TCellContainer>::
directFacesIterators( CellMapIteratorOutputIterator& outIt, const Cell& aCell )
{
  Cells all_direct_faces = myKSpace->uLowerIncident( aCell );
  Dimension k = dim( aCell );
  for ( typename Cells::ConstIterator it = all_direct_faces.begin(), 
          itE = all_direct_faces.end(); it != itE; ++it )
    {
      CellMapIterator map_it = find( *it );
      if ( map_it != end( k-1 ) ) 
        *outIt++ = map_it;
    }
}
//-----------------------------------------------------------------------------
template <typename TKSpace, typename TCellContainer>
template <typename CellOutputIterator>
inline
void
DGtal::CubicalComplex<TKSpace, TCellContainer>::
directCoFaces( CellOutputIterator& outIt, const Cell& aCell, bool hintOpen )
{
  Cells all_direct_co_faces = myKSpace->uUpperIncident( aCell );
  if ( hintOpen )
    std::copy( all_direct_co_faces.begin(), all_direct_co_faces.end(), outIt );
  else
    for ( typename Cells::ConstIterator it = all_direct_co_faces.begin(), 
            itE = all_direct_co_faces.end(); it != itE; ++it )
      if ( belongs( *it ) )
        *outIt++ = *it;
}
//-----------------------------------------------------------------------------
template <typename TKSpace, typename TCellContainer>
template <typename CellMapIteratorOutputIterator>
inline
void
DGtal::CubicalComplex<TKSpace, TCellContainer>::
directCoFacesIterators( CellMapIteratorOutputIterator& outIt, const Cell& aCell )
{
  Cells all_direct_faces = myKSpace->uUpperIncident( aCell );
  Dimension k = dim( aCell );
  for ( typename Cells::ConstIterator it = all_direct_faces.begin(), 
          itE = all_direct_faces.end(); it != itE; ++it )
    {
      CellMapIterator map_it = find( *it );
      if ( map_it != end( k+1 ) ) 
        *outIt++ = map_it;
    }
}

//-----------------------------------------------------------------------------
template <typename TKSpace, typename TCellContainer>
inline
typename DGtal::CubicalComplex<TKSpace, TCellContainer>::CellMapConstIterator
DGtal::CubicalComplex<TKSpace, TCellContainer>::
begin( Dimension d ) const
{
  return myCells[ d ].begin();
}

//-----------------------------------------------------------------------------
template <typename TKSpace, typename TCellContainer>
inline
typename DGtal::CubicalComplex<TKSpace, TCellContainer>::CellMapConstIterator
DGtal::CubicalComplex<TKSpace, TCellContainer>::
end( Dimension d ) const
{
  return myCells[ d ].end();
}

//-----------------------------------------------------------------------------
template <typename TKSpace, typename TCellContainer>
inline
typename DGtal::CubicalComplex<TKSpace, TCellContainer>::CellMapIterator
DGtal::CubicalComplex<TKSpace, TCellContainer>::
begin( Dimension d )
{
  return myCells[ d ].begin();
}

//-----------------------------------------------------------------------------
template <typename TKSpace, typename TCellContainer>
inline
typename DGtal::CubicalComplex<TKSpace, TCellContainer>::CellMapIterator
DGtal::CubicalComplex<TKSpace, TCellContainer>::
end( Dimension d )
{
  return myCells[ d ].end();
}

//-----------------------------------------------------------------------------
template <typename TKSpace, typename TCellContainer>
inline
void
DGtal::CubicalComplex<TKSpace, TCellContainer>::
close()
{
  close( dim() );
}

//-----------------------------------------------------------------------------
template <typename TKSpace, typename TCellContainer>
inline
void
DGtal::CubicalComplex<TKSpace, TCellContainer>::
close( Dimension k )
{
  if ( k <= 0 ) return;
  Dimension l = k - 1;
  for ( CellMapConstIterator it = begin( k ), itE = end( k ); 
        it != itE; ++it )
    {
      Cells direct_faces = myKSpace->uLowerIncident( it->first );
      for ( typename Cells::const_iterator cells_it = direct_faces.begin(), 
              cells_it_end = direct_faces.end(); cells_it != cells_it_end; ++cells_it )
        insertCell( l, *cells_it );
    }
  close( l );
}

//-----------------------------------------------------------------------------
template <typename TKSpace, typename TCellContainer>
inline
typename DGtal::CubicalComplex<TKSpace, TCellContainer>::CellMapConstIterator
DGtal::CubicalComplex<TKSpace, TCellContainer>::
find( const Cell& aCell ) const
{
  return find( dim( aCell ), aCell );
}

//-----------------------------------------------------------------------------
template <typename TKSpace, typename TCellContainer>
inline
typename DGtal::CubicalComplex<TKSpace, TCellContainer>::CellMapConstIterator
DGtal::CubicalComplex<TKSpace, TCellContainer>::
find( Dimension d, const Cell& aCell ) const
{
  return myCells[ d ].find( aCell );
}

//-----------------------------------------------------------------------------
template <typename TKSpace, typename TCellContainer>
inline
typename DGtal::CubicalComplex<TKSpace, TCellContainer>::CellMapIterator
DGtal::CubicalComplex<TKSpace, TCellContainer>::
find( const Cell& aCell )
{
  return find( dim( aCell ), aCell );
}

//-----------------------------------------------------------------------------
template <typename TKSpace, typename TCellContainer>
inline
typename DGtal::CubicalComplex<TKSpace, TCellContainer>::CellMapIterator
DGtal::CubicalComplex<TKSpace, TCellContainer>::
find( Dimension d, const Cell& aCell )
{
  return myCells[ d ].find( aCell );
}




//-----------------------------------------------------------------------------
template <typename TKSpace, typename TCellContainer>
template <typename CellConstIterator, typename CellMapIteratorPriority>
void
DGtal::CubicalComplex<TKSpace, TCellContainer>::
collapse( CellConstIterator S_itb, CellConstIterator S_itE, 
          const CellMapIteratorPriority& priority, 
          bool hintIsSClosed, bool hintIsKClosed )
{
  using namespace std;
  // NB : a maximal k-cell is collapsible if it has a free incident k-1-cell.
  Dimension n = dim();
  vector< CellMapIterator > S;
  vector< CellMapIterator > Q_low;
  vector< CellMapIterator > Q_collapsible;
  CellMapIterator it_c;
  typename vector< CellMapIterator >::const_iterator itlow;
  typename vector< CellMapIterator >::const_iterator itqup;

  cout << "[CC::collapse]-+ tag collapsible elements... " << flush;
  // Restricts the set of elements that are collapsible.
  if ( hintIsSClosed )
    for ( CellConstIterator S_it = S_itb; S_it != S_itE; ++S_it )
      {
        Cell c = *S_it;
        Dimension k = dim( c );
        it_c = find( k, c );
        ASSERT( it_c != end( k ) );
        S.push_back( it_c );
	uint32_t& ccdata = it_c->second.data;
	if ( ! ( ccdata & (FIXED | COLLAPSIBLE ) ) )
	  {
	    ccdata |= COLLAPSIBLE;
	    Q_collapsible.push_back( it_c );
	  }
      }
  else // not ( hintIsSClosed )
    for ( CellConstIterator S_it = S_itb; S_it != S_itE; ++S_it )
      {
        Cell c = *S_it;
        Dimension k = dim( c );
        it_c = find( k, c );
        ASSERT( it_c != end( k ) );
        S.push_back( it_c );
        uint32_t& ccdata = it_c->second.data;
        if ( ! ( ccdata & (FIXED | COLLAPSIBLE ) ) )
          {
            ccdata |= COLLAPSIBLE;
            Q_collapsible.push_back( it_c );
          }
        vector<Cell> cells;
        back_insert_iterator< vector<Cell> > back_it( cells );
        this->faces( back_it, c, hintIsKClosed );
        for ( typename vector<Cell>::const_iterator it = cells.begin(), itE = cells.end();
              it != itE; ++it )
          {
            it_c = find( *it );
            uint32_t& ccdata = it_c->second.data;
            if ( ! ( ccdata & (FIXED | COLLAPSIBLE ) ) )
              {
                ccdata |= COLLAPSIBLE;
                Q_collapsible.push_back( it_c );
              }
          }
      }
  cout << " " << Q_collapsible.size() << " found." << endl;

  // Fill queue
  priority_queue
    < CellMapIterator, vector<CellMapIterator>, CellMapIteratorPriority > PQ( priority );

  
  cout << "[CC::collapse]-+ entering collapsing loop. " << endl;
  uint64_t nb_pass = 0;
  uint64_t nb_examined = 0;
  while ( ! S.empty() ) 
    {
      cout << "[CC::collapse]---+ Pass " << ++nb_pass << ", Card(PQ)=";
      for ( typename vector< CellMapIterator >::const_iterator it = S.begin(), itE = S.end();
            it != itE; ++it )
	{
	  PQ.push( *it );
	  (*it)->second.data |= USER1;
	}
      S.clear();
      cout << PQ.size() << " elements, " << "nb_exam=" << nb_examined << endl;
      
      // Try to collapse elements according to priority queue.
      while ( ! PQ.empty() )
	{
	  // Get top element.
	  CellMapIterator itcur = PQ.top();
	  PQ.pop();
	  ++nb_examined;
          uint32_t& cur_data = itcur->second.data;
	  ASSERT( cur_data & USER1 );
          cur_data &= ~USER1;
	  // Check if the cell is removable
	  if ( ( cur_data & REMOVED ) || ( ! ( cur_data & COLLAPSIBLE ) ) )
            continue;

	  // Cell may be removable.
	  // Check if it is a maximal cell
	  const Cell & cur_c = itcur->first;
	  CellMapIterator itup;
	  uint32_t cur_c_type = computeCellType( n, cur_c, itup );
	  bool found_pair = false;
	  CellMapIterator it_cell_c;
	  CellMapIterator it_cell_d;
          // trace.info() << "  - Cell " << cur_c << " Dim=" << dim( cur_c ) << " Type=" << cur_c_type << std::endl;
	  if ( cur_c_type == 0 )
	    { // maximal cell... must find a free face
	      // check faces to find a free face.
              back_insert_iterator< vector<CellMapIterator> > back_it( Q_low );
              directFacesIterators( back_it, cur_c );
	      CellMapIterator best_free_face_it = end( 0 );
	      for ( typename vector<CellMapIterator>::const_iterator it = Q_low.begin(), itE = Q_low.end();
                    it != itE; ++it )
		{
                  CellMapIterator low_ic = *it;
                  uint32_t& data = low_ic->second.data;
                  // trace.info() << "    + Cell " << low_ic->first << " data=" << data << std::endl;
		  if ( ( data & REMOVED ) || ! ( data & COLLAPSIBLE ) ) continue;
		  const Cell& cur_d = low_ic->first;
		  uint cur_d_type = computeCellType( n, cur_d, itup );
                  // trace.info() << "      + Type=" << cur_d_type << std::endl;
		  if ( cur_d_type == 1 )
		    { // found a free n-1-face ic
		      if ( ( best_free_face_it == end( 0 ) )
			   || ( ! priority( low_ic, best_free_face_it ) ) )
			best_free_face_it = low_ic;
		    }
		}
	      if ( best_free_face_it != end( 0 ) )
		{
		  // delete c and ic.
		  found_pair = true;
		  it_cell_c = itcur;
		  it_cell_d = best_free_face_it;
		  // Q_low already contains cells that should be
		  // checked again
		}
	    }
	  else if ( cur_c_type == 1 )
	    { // free face... check that its 1-up-incident face is maximal.
	      const Cell& cur_d = itup->first;
	      CellMapIterator it_up_up;
	      uint32_t cur_d_type = computeCellType( n, cur_d, it_up_up );
	      if ( cur_d_type == 0 )
		{ // found a maximal face.
		  found_pair = true;
		  it_cell_c = itup;
		  it_cell_d = itcur;
		  // Q_low will contain cells that should be checked
		  // again
                  back_insert_iterator< vector<CellMapIterator> > back_it( Q_low );
                  directFacesIterators( back_it, it_cell_c->first );
		}
	    }
	  if ( found_pair )
	    {
	      it_cell_c->second.data |= REMOVED;
	      it_cell_d->second.data |= REMOVED;

	      // Incident cells have to be checked again.
	      for ( typename vector<CellMapIterator>::const_iterator it = Q_low.begin(), itE = Q_low.end();
                    it != itE; ++it )
                {
                  CellMapIterator it_cell = *it;
		  uint32_t& data_qlow = it_cell->second.data;
		  if ( ( ! ( data_qlow & REMOVED ) )
		       && ( data_qlow & COLLAPSIBLE )
		       && ( ! ( data_qlow & USER1 ) ) )
		    {
		      S.push_back( it_cell ); // WARNING, was "insert"
		    }
		}
	    }
          Q_low.clear();
	} // while ( ! PQ.empty() )
    } // while ( ! S.empty() ) 

  // Now clean the complex so that removed cells are effectively
  // removed and no more cell is tagged as collapsible.
  for ( typename vector< CellMapIterator >::const_iterator it = Q_collapsible.begin(),
          itE = Q_collapsible.end(); it != itE; ++it )
    {
      if ( (*it)->second.data & REMOVED ) 
        myCells[ dim( (*it)->first ) ].erase( *it );
      else
	(*it)->second.data &= ~COLLAPSIBLE;
    }
}

/**
 * Given a cell [c], tells if it is a maximal cell in the complex
 * (return 0), or if it is a free face of the cell pointed by
 * [it_cell_up] (return 1) or if it is not a free face.
 *
 * The complex must be closed. In computing the 1-up-incident
 * cells, this method ignores cell marked as REMOVED. Furthermore,
 * if one 1-up-incident cell is not marked as COLLAPSIBLE, the
 * method returns 2.
 *
 * @param c a cubical cell (belonging to 'this')
 *
 * @param it_cell_up (returns) a pointer on a cell d if c is a
 * free face of d.
 *
 * @return 0 if the cell is maximal, 1 if the cell is a free face,
 * 2 otherwise.
 */
//-----------------------------------------------------------------------------
template <typename TKSpace, typename TCellContainer>
inline
DGtal::uint32_t
DGtal::CubicalComplex<TKSpace, TCellContainer>::
computeCellType( Dimension n, const Cell& c, CellMapIterator& it_cell_up )
{
  // Check if it is a maximal cell
  Dimension k = dim( c );
  if ( k == n ) return 0;
  
  std::vector< CellMapIterator > Q_up;
  std::back_insert_iterator< std::vector< CellMapIterator > > back_it( Q_up );
  this->directCoFacesIterators( back_it, c );
  
  // Filtering unwanted up-incident cells.
  uint32_t nb = 0;
  for ( typename std::vector< CellMapIterator >::const_iterator it = Q_up.begin(), itE = Q_up.end();
        it != itE; ++it )
    {
      uint32_t& data = (*it)->second.data;
      if ( ! ( data & COLLAPSIBLE ) ) return 2;
      if ( ! ( data & REMOVED ) )
	{
	  ++nb;
	  if ( nb > 1 ) return 2;
	  it_cell_up = *it;
	}
    }
  return nb;
}



///////////////////////////////////////////////////////////////////////////////
// Interface - public :

/**
 * Writes/Displays the object on an output stream.
 * @param out the output stream where the object is written.
 */
template <typename TKSpace, typename TCellContainer>
inline
void
DGtal::CubicalComplex<TKSpace, TCellContainer>::selfDisplay ( std::ostream & out ) const
{
  out << "[CubicalComplex dim=" << dim();
  for ( Dimension i = 0; i < myCells.size(); ++i )
    out << " #" << i << "=" << myCells[ i ].size();
  out << "]";
}

/**
 * Checks the validity/consistency of the object.
 * @return 'true' if the object is valid, 'false' otherwise.
 */
template <typename TKSpace, typename TCellContainer>
inline
bool
DGtal::CubicalComplex<TKSpace, TCellContainer>::isValid() const
{
    return true;
}



///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions                                        //

template <typename TKSpace, typename TCellContainer>
inline
std::ostream&
DGtal::operator<< ( std::ostream & out, 
		  const CubicalComplex<TKSpace, TCellContainer> & object )
{
  object.selfDisplay( out );
  return out;
}

//                                                                           //
///////////////////////////////////////////////////////////////////////////////


