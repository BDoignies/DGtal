/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file KhalimskySpaceND.ih
 * @author Jacques-Olivier Lachaud (\c jacques-olivier.lachaud@univ-savoie.fr )
 * Laboratory of Mathematics (CNRS, UMR 5807), University of Savoie, France
 *
 * @date 2011/02/08
 *
 * Implementation of inline methods defined in KhalimskySpaceND.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// KhalimskyCell
///////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger >
inline
DGtal::KhalimskyCell< dim, TInteger >::
KhalimskyCell()
{
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger >
inline
DGtal::KhalimskyCell< dim, TInteger >::
KhalimskyCell( const KhalimskyCell & other )
  : myCoordinates( other.myCoordinates )
{
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger >
inline
DGtal::KhalimskyCell< dim, TInteger >::
KhalimskyCell( const Point & p )
  : myCoordinates( p )
{
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger >
inline
DGtal::KhalimskyCell< dim, TInteger > &
DGtal::KhalimskyCell< dim, TInteger >::
operator=( const KhalimskyCell & other )
{
  if ( this != &other )
    myCoordinates = other.myCoordinates;
  return *this;
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger >
inline
bool
DGtal::KhalimskyCell< dim, TInteger >::
operator==( const KhalimskyCell & other ) const
{
  return myCoordinates == other.myCoordinates;
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger >
inline
bool
DGtal::KhalimskyCell< dim, TInteger >::
operator<( const KhalimskyCell & other ) const
{
  return myCoordinates < other.myCoordinates;
}
//-----------------------------------------------------------------------------
template < std::size_t dim,
	   typename TInteger >
inline
std::ostream & 
DGtal::operator<<( std::ostream & out, 
		   const KhalimskyCell< dim, TInteger > & object )
{
  out << "(" << object.myCoordinates[ 0 ];
  for ( std::size_t i = 1; i < dim; ++i )
    out << "," << object.myCoordinates[ i ];
  out << ")";
  return out;
}

///////////////////////////////////////////////////////////////////////////////
// SignedKhalimskyCell
///////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger >
inline
DGtal::SignedKhalimskyCell< dim, TInteger >::
SignedKhalimskyCell()
{
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger >
inline
DGtal::SignedKhalimskyCell< dim, TInteger >::
SignedKhalimskyCell( const SignedKhalimskyCell & other )
  : myCoordinates( other.myCoordinates, other.myPositive )
{
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger >
inline
DGtal::SignedKhalimskyCell< dim, TInteger >::
SignedKhalimskyCell( const Point & p, bool positive )
  : myCoordinates( p ), myPositive( positive )
{
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger >
inline
DGtal::SignedKhalimskyCell< dim, TInteger > &
DGtal::SignedKhalimskyCell< dim, TInteger >::
operator=( const SignedKhalimskyCell & other )
{
  if ( this != &other )
    {
      myCoordinates = other.myCoordinates;
      myPositive = other.myPositive;
    }
  return *this;
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger >
inline
bool
DGtal::SignedKhalimskyCell< dim, TInteger >::
operator==( const SignedKhalimskyCell & other ) const
{
  return ( myPositive == other.myPositive )
    && ( myCoordinates == other.myCoordinates );
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger >
inline
bool
DGtal::SignedKhalimskyCell< dim, TInteger >::
operator<( const SignedKhalimskyCell & other ) const
{
  return ( myPositive < other.myPositive )
    || ( ( myPositive == other.myPositive )
	 && ( myCoordinates < other.myCoordinates ) );
}
//-----------------------------------------------------------------------------
template < std::size_t dim,
	   typename TInteger >
inline
std::ostream & 
DGtal::operator<<( std::ostream & out, 
		   const SignedKhalimskyCell< dim, TInteger > & object )
{
  out << "(" << object.myCoordinates[ 0 ];
  for ( std::size_t i = 1; i < dim; ++i )
    out << "," << object.myCoordinates[ i ];
  out << "," << ( object.myPositive ? '+' : '-' );
  out << ")";
  return out;
}

///////////////////////////////////////////////////////////////////////////////
// KhalimskySpaceND
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
~KhalimskySpaceND()
{
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
KhalimskySpaceND()
{
  Point low, high;
  for ( Dimension i = 0; i < staticDimension; ++i )
    {
      low[ i ] = IntegerTraits< Integer >::min() / 2 + 1;
      high[ i ] = IntegerTraits< Integer >::max() / 2 - 1;
    }
  init( low, high, true );
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
bool 
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
init( const Point & lower,
      const Point & upper,
      bool closed )
{
  myIsClosed = closed;
  myLower = lower;
  myUpper = upper;
  if ( IntegerTraits< Integer >::isBounded() == BOUNDED )
    {
      for ( Dimension i = 0; i < staticDimension; ++i )
	{
	  if ( ( lower[ i ] 
		 <= ( IntegerTraits< Integer >::min() / 2 ) )
	       || ( upper[ i ] 
		    >= ( IntegerTraits< Integer >::max() / 2 ) ) )
	    return false;
	}
    }
  for ( Dimension i = 0; i < staticDimension; ++i )
    {
      myCellLower.myCoordinates[ i ] = lower[ i ] * 2
	+ closed ? 0 : 1;
      myCellUpper.myCoordinates[ i ] = upper[ i ] * 2
	+ closed ? 2 : 1;
    }
  return true;
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
TDimension
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
dimension() const
{
  return staticDimension;
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
TSize
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
size( Dimension k ) const
{
  ASSERT( k < staticDimension );
  return myUpper[ k ] + IntegerTraits<Integer>::ONE - myLower[ k ];
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
typename DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::Cell
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
uCell( const Point & kp ) const
{
  return Cell( kp );
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
typename DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::Cell
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
uCell( const Point & p, const Cell & c ) const
{
  Cell nc( p );
  for ( Dimension i = 0; i < DIM; ++i )
    nc.myCoordinates[ i ] += p[ i ] + ( c.myCoordinates[ i ] & 0x1 );
  return nc;
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
typename DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::SCell
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
sCell( const Point & kp, Sign sign ) const
{
  return SCell( kp, sign == POS );
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
typename DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::SCell
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
sCell( const Point & p, const SCell & c ) const
{
  SCell nc( p, c.myPositive );
  for ( Dimension i = 0; i < DIM; ++i )
    nc.myCoordinates[ i ] += p[ i ] + ( c.myCoordinates[ i ] & 0x1 );
  return nc;
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
typename DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::Cell
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
uSpel( const Point & p ) const
{
  Cell nc( p );
  for ( Dimension i = 0; i < DIM; ++i )
    nc.myCoordinates[ i ] += p[ i ] + 1;
  return nc;
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
typename DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::SCell
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
sSpel( const Point & p, Sign sign ) const
{
  SCell nc( p, sign );
  for ( Dimension i = 0; i < DIM; ++i )
    nc.myCoordinates[ i ] += p[ i ] + 1;
  return nc;
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
typename DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::Cell
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
uPointel( const Point & p ) const
{
  Cell nc( p );
  for ( Dimension i = 0; i < DIM; ++i )
    nc.myCoordinates[ i ] += p[ i ];
  return nc;
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
typename DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::SCell
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
sPointel( const Point & p, Sign sign ) const
{
  SCell nc( p, sign );
  for ( Dimension i = 0; i < DIM; ++i )
    nc.myCoordinates[ i ] += p[ i ];
  return nc;
}
//-----------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
typename DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::Integer
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
uKCoord( const Cell & c, Dimension k ) const
{
  ASSERT( k < DIM );
  return c.myCoordinates[ k ];
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
typename DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::Integer 
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
uCoord( const Cell & c, Dimension k ) const
{
  ASSERT( k < DIM );
  return c.myCoordinates[ k ] >> 1;
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
typename DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::Point
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
uKCoords( const Cell & c ) const
{
  return c.myCoordinates;
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
typename DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::Point
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
uCoords( const Cell & c ) const
{
  Point dp;
  for ( Dimension i = 0; i < DIM; ++i )
    dp[ i ] = c.myCoordinates[ i ] >> 1;
  return dp;
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
typename DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::Integer
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
sKCoord( const SCell & c, Dimension k ) const
{
  ASSERT( k < DIM );
  return c.myCoordinates[ k ];
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
typename DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::Integer 
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
sCoord( const SCell & c, Dimension k ) const
{
  ASSERT( k < DIM );
  return c.myCoordinates[ k ] >> 1;
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
typename DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::Point
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
sKCoords( const SCell & c ) const
{
  return c.myCoordinates;
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
typename DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::Point
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
sCoords( const SCell & c ) const
{
  Point dp;
  for ( Dimension i = 0; i < DIM; ++i )
    dp[ i ] = c.myCoordinates[ i ] >> 1;
  return dp;
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
typename DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::Sign
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
sSign( const SCell & c ) const
{
  return c.myPositive ? POS : NEG;
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
typename DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::SCell 
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
signs( const Cell & p, Sign s ) const
{
  return sCell( p.myCoordinates, s );
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
typename DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::Cell 
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
unsigns( const SCell & p ) const
{
  return uCell( p.myCoordinates );
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
typename DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::SCell 
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
sOpp( const SCell & p ) const
{
  return sCell( p.myCoordinates, ! p.myPositive );
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
void
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
uSetKCoord( Cell & c, Dimension k, const Integer & i ) const
{
  ASSERT( k < DIM 
	  && myCellLower.myCoordinates[ k ] <= i 
	  && i <= myCellUpper.myCoordinates[ k ] );
  c.myCoordinates[ k ] = i;
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
void
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
sSetKCoord( SCell & c, Dimension k, const Integer & i ) const
{
  ASSERT( k < DIM 
	  && myCellLower.myCoordinates[ k ] <= i 
	  && i <= myCellUpper.myCoordinates[ k ] );
  c.myCoordinates[ k ] = i;
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
void
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
uSetCoord( Cell & c, Dimension k, const Integer & i ) const
{
  ASSERT( k < DIM );
  i = ( i << 1 ) + ( c.myCoordinates[ k ] & 1 );
  ASSERT( myCellLower.myCoordinates[ k ] <= i 
	  && i <= myCellUpper.myCoordinates[ k ] );
  c.myCoordinates[ k ] = i;
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
void
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
sSetCoord( SCell & c, Dimension k, const Integer & i ) const
{
  ASSERT( k < DIM );
  i = ( i << 1 ) + ( c.myCoordinates[ k ] & 1 );
  ASSERT( myCellLower.myCoordinates[ k ] <= i 
	  && i <= myCellUpper.myCoordinates[ k ] );
  c.myCoordinates[ k ] = i;
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
void
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
uSetKCoords( Cell & c, const Point & kp ) const
{
  c.myCoordinates = kp;
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
void
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
sSetKCoords( SCell & c, const Point & kp ) const
{
  c.myCoordinates = kp;
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
void
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
uSetCoords( Cell & c, const Point & p ) const
{
  Integer i;
  for ( Dimension k = 0; k < DIM; ++k )
    {
      i = ( p[ k ] << 1 ) + ( c.myCoordinates[ k ] & 1 );
      ASSERT( myCellLower.myCoordinates[ k ] <= i 
	      && i <= myCellUpper.myCoordinates[ k ] );
      c.myCoordinates[ k ] = i;
    }
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
void
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
sSetCoords( SCell & c, const Point & p ) const
{
  Integer i;
  for ( Dimension k = 0; k < DIM; ++k )
    {
      i = ( p[ k ] << 1 ) + ( c.myCoordinates[ k ] & 1 );
      ASSERT( myCellLower.myCoordinates[ k ] <= i 
	      && i <= myCellUpper.myCoordinates[ k ] );
      c.myCoordinates[ k ] = i;
    }
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
void
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
sSetSign( SCell & c, Sign s ) const
{
  c.myPositive = ( s == POS );
}
//-----------------------------------------------------------------------------
// ------------------------- Cell topology services -----------------------
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
TInteger
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
uTopology( const Cell & p ) const
{
  Integer i = IntegerTraits<Integer>::ZERO;
  Integer j = IntegerTraits<Integer>::ONE;
  for ( Dimension k = 0; k < DIM; ++k )
    {
      if ( p.myCoordinates[ k ] & IntegerTraits<Integer>::ONE )
	i |= j;
      j <<= 1;
    }
  return i;
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
TInteger
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
sTopology( const SCell & p ) const
{
  Integer i = IntegerTraits<Integer>::ZERO;
  Integer j = IntegerTraits<Integer>::ONE;
  for ( Dimension k = 0; k < DIM; ++k )
    {
      if ( p.myCoordinates[ k ] & IntegerTraits<Integer>::ONE )
	i |= j;
      j <<= 1;
    }
  return i;
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
TDimension
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
uDim( const Cell & p ) const
{
  Integer i = IntegerTraits<Integer>::ZERO;
  for ( Dimension k = 0; k < DIM; ++k )
    if ( p.myCoordinates[ k ] & IntegerTraits<Integer>::ONE )
      ++i;
  return i;
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
TDimension
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
sDim( const SCell & p ) const
{
  Integer i = IntegerTraits<Integer>::ZERO;
  for ( Dimension k = 0; k < DIM; ++k )
    if ( p.myCoordinates[ k ] & IntegerTraits<Integer>::ONE )
      ++i;
  return i;
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
bool
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
uIsSurfel( const Cell & b ) const
{
  return udim( b ) == ( DIM - 1 );
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
bool
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
sIsSurfel( const SCell & b ) const
{
 return sdim( b ) == ( DIM - 1 );
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
bool
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
uIsOpen( const Cell & p, Dimension k ) const
{
  return p.myCoordinates[ k ] & IntegerTraits<Integer>::ONE;
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
bool
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
sIsOpen( const SCell & p, Dimension k ) const
{
  return p.myCoordinates[ k ] & IntegerTraits<Integer>::ONE;
}

//-----------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
typename DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::DirIterator
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
uDirs( const Cell & p ) const
{
  return DirIterator( uTopology( p ) );
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
typename DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::DirIterator
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
sDirs( const SCell & p ) const
{
  return DirIterator( sTopology( p ) );
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
typename DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::DirIterator
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
uOrthDirs( const Cell & p ) const
{
  Integer i = IntegerTraits<Integer>::ZERO;
  Integer j = IntegerTraits<Integer>::ONE;
  for ( Dimension k = 0; k < DIM; ++k )
    {
      if ( ! ( p.myCoordinates[ k ] & IntegerTraits<Integer>::ONE ) )
	i |= j;
      j <<= 1;
    }
  return DirIterator( i );
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
typename DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::DirIterator
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
sOrthDirs( const SCell & p ) const
{
  Integer i = IntegerTraits<Integer>::ZERO;
  Integer j = IntegerTraits<Integer>::ONE;
  for ( Dimension k = 0; k < DIM; ++k )
    {
      if ( ! ( p.myCoordinates[ k ] & IntegerTraits<Integer>::ONE ) )
	i |= j;
      j <<= 1;
    }
  return DirIterator( i );
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
TDimension 
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
uOrthDir( const Cell & s ) const
{
  Integer i = IntegerTraits<Integer>::ZERO;
  for ( Dimension k = 0; k < DIM; ++k )
    {
      if ( ! ( s.myCoordinates[ k ] & IntegerTraits<Integer>::ONE ) )
	return k;
    }
  ASSERT( false );
  return IntegerTraits<Dimension>::ZERO;
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
TDimension 
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
sOrthDir( const SCell & s ) const
{
  Integer i = IntegerTraits<Integer>::ZERO;
  for ( Dimension k = 0; k < DIM; ++k )
    {
      if ( ! ( s.myCoordinates[ k ] & IntegerTraits<Integer>::ONE ) )
	return k;
    }
  ASSERT( false );
  return IntegerTraits<Dimension>::ZERO;
}
//-----------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
typename DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::Cell
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
uFirst( const Cell & p ) const
{
  return uCell( myLower, p );
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
typename DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::Cell
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
uLast( const Cell & p ) const
{
  return uCell( myUpper, p );
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
typename DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::Cell
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
uGetIncr( const Cell & p, Dimension k ) const
{
  Cell q = p;
  q.myCoordinates[ k ] += 2;
  return q;
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
bool 
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
uIsMax( const Cell & p, Dimension k ) const
{
  return p.myCoordinates[ k ] >= myCellUpper.myCoordinates[ k ];
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
typename DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::Cell
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
uGetMax( const Cell & p, Dimension k ) const
{
  return uProjection( p, myCellUpper, k );
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
typename DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::Cell
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
uGetDecr( const Cell & p, Dimension k ) const
{
  Cell q = p;
  q.myCoordinates[ k ] -= 2;
  return q;
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
bool
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
uIsMin( const Cell & p, Dimension k ) const
{
  return p.myCoordinates[ k ] <= myCellLower.myCoordinates[ k ];
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
typename DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::Cell
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
uGetMin( const Cell & p, Dimension k ) const
{
  return uProjection( p, myCellLower, k );
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
typename DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::Cell
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
uGetAdd( const Cell & p, Dimension k, const Integer & x ) const
{
  Cell q = p;
  q.myCoordinates[ k ] += 2*x;
  return q;
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
typename DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::Cell
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
uGetSub( const Cell & p, Dimension k, const Integer & x ) const
{
  Cell q = p;
  q.myCoordinates[ k ] -= 2*x;
  return q;
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
TInteger
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
uDistanceToMax( const Cell & p, Dimension k ) const
{
  return ( myCellUpper.myCoordinates[ k ] - p.myCoordinates[ k ] ) >> 1;
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
TInteger
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
uDistanceToMin( const Cell & p, Dimension k ) const
{
  return ( p.myCoordinates[ k ] - myCellLower.myCoordinates[ k ] ) >> 1;
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
typename DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::Cell
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
uTranslation( const Cell & p, const Vector & vec ) const
{
  Cell q = p;
  for ( Dimension k = 0; k < DIM; ++k )
    q.myCoordinates[ k ] += ( vec[ k ] << 1 );
  return q;
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
typename DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::Cell
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
uProjection( const Cell & p, const Cell & bound, Dimension k ) const
{
  Cell q = p;
  q.myCoordinates[ k ] = bound.myCoordinates[ k ];
  return q;
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
void
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
uProject( Cell & p, const Cell & bound, Dimension k ) const
{
  p.myCoordinates[ k ] = bound.myCoordinates[ k ];
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
bool
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
uNext( Cell & p, const Cell & lower, const Cell & upper ) const
{
  Dimension k = IntegerTraits<Dimension>::ZERO;
  if ( uCoord( p, k ) == uCoord( upper, k ) )
    {
      if ( p == upper ) return false;
      uProject( p, lower, k );
      for ( k = 1; k < DIM; ++k )
	{
	  if ( uCoord( p, k ) == uCoord( upper, k ) )
	    uProject( p, lower, k );
	  else  
	    {
	      p.myCoordinates[ k ] += 2;
	      break;
	    }
	}
      return true;
    }
  p.myCoordinates[ k ] += 2;
  return true;
}

//-----------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
typename DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::SCell
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
sFirst( const SCell & p ) const
{
  return sCell( myLower, p );
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
typename DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::SCell
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
sLast( const SCell & p ) const
{
  return sCell( myUpper, p );
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
typename DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::SCell
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
sGetIncr( const SCell & p, Dimension k ) const
{
  SCell q = p;
  q.myCoordinates[ k ] += 2;
  return q;
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
bool 
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
sIsMax( const SCell & p, Dimension k ) const
{
  return p.myCoordinates[ k ] >= myCellUpper.myCoordinates[ k ];
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
typename DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::SCell
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
sGetMax( const SCell & p, Dimension k ) const
{
  return sProjection( p, myCellUpper, k );
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
typename DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::SCell
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
sGetDecr( const SCell & p, Dimension k ) const
{
  SCell q = p;
  q.myCoordinates[ k ] -= 2;
  return q;
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
bool
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
sIsMin( const SCell & p, Dimension k ) const
{
  return p.myCoordinates[ k ] <= myCellLower.myCoordinates[ k ];
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
typename DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::SCell
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
sGetMin( const SCell & p, Dimension k ) const
{
  return sProjection( p, myCellLower, k );
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
typename DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::SCell
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
sGetAdd( const SCell & p, Dimension k, const Integer & x ) const
{
  SCell q = p;
  q.myCoordinates[ k ] += 2*x;
  return q;
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
typename DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::SCell
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
sGetSub( const SCell & p, Dimension k, const Integer & x ) const
{
  SCell q = p;
  q.myCoordinates[ k ] -= 2*x;
  return q;
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
TInteger
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
sDistanceToMax( const SCell & p, Dimension k ) const
{
  return ( myCellUpper.myCoordinates[ k ] - p.myCoordinates[ k ] ) >> 1;
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
TInteger
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
sDistanceToMin( const SCell & p, Dimension k ) const
{
  return ( p.myCoordinates[ k ] - myCellLower.myCoordinates[ k ] ) >> 1;
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
typename DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::SCell
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
sTranslation( const SCell & p, const Vector & vec ) const
{
  SCell q = p;
  for ( Dimension k = 0; k < DIM; ++k )
    q.myCoordinates[ k ] += ( vec[ k ] << 1 );
  return q;
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
typename DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::SCell
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
sProjection( const SCell & p, const SCell & bound, Dimension k ) const
{
  SCell q = p;
  q.myCoordinates[ k ] = bound.myCoordinates[ k ];
  return q;
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
void
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
sProject( SCell & p, const SCell & bound, Dimension k ) const
{
  p.myCoordinates[ k ] = bound.myCoordinates[ k ];
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
bool
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
sNext( SCell & p, const SCell & lower, const SCell & upper ) const
{
  Dimension k = IntegerTraits<Dimension>::ZERO;
  if ( sCoord( p, k ) == sCoord( upper, k ) )
    {
      if ( p == upper ) return false;
      sProject( p, lower, k );
      for ( k = 1; k < DIM; ++k )
	{
	  if ( sCoord( p, k ) == sCoord( upper, k ) )
	    sProject( p, lower, k );
	  else  
	    {
	      p.myCoordinates[ k ] += 2;
	      break;
	    }
	}
      return true;
    }
  p.myCoordinates[ k ] += 2;
  return true;
}

//-----------------------------------------------------------------------------
// ----------------------- Neighborhood services --------------------------
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
typename DGtal::KhalimskySpaceND< dim, TInteger, 
				  TSize, TDimension >::Neighborhood 
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
uNeighborhood( const Cell & c ) const
{
  Neighborhood N;
  for ( Dimension k = 0; k < DIM; ++k )
    {
      if ( ! uIsMin( c, k ) )
	N.push_back( uGetDecr( c, k ) );
      if ( ! uIsMax( c, k ) )
	N.push_back( uGetIncr( c, k ) );
    }
  return N;
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
typename DGtal::KhalimskySpaceND< dim, TInteger, 
				  TSize, TDimension >::SNeighborhood 
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
sNeighborhood( const SCell & c ) const
{
  SNeighborhood N;
  for ( Dimension k = 0; k < DIM; ++k )
    {
      if ( ! sIsMin( c, k ) )
	N.push_back( sGetDecr( c, k ) );
      if ( ! sIsMax( c, k ) )
	N.push_back( sGetIncr( c, k ) );
    }
  return N;
}

//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
void
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
selfDisplay ( std::ostream & out ) const
{
  out << "[KhalimskySpaceND]";
}
//-----------------------------------------------------------------------------
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
bool
DGtal::KhalimskySpaceND< dim, TInteger, TSize, TDimension >::
isValid() const
{
  return true;
}



///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions                                        //
template < std::size_t dim, typename TInteger, typename TSize, 
	   typename TDimension >
inline
std::ostream&
DGtal::operator<< ( std::ostream & out, 
		  const KhalimskySpaceND< dim, TInteger, TSize, TDimension > & object )
{
  object.selfDisplay( out );
  return out;
}

//                                                                           //
///////////////////////////////////////////////////////////////////////////////


