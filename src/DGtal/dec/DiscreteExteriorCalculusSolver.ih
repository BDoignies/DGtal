
template <typename C, typename S, Order order_in, Duality duality_in, Order order_out, Duality duality_out>
DiscreteExteriorCalculusSolver<C, S, order_in, duality_in, order_out, duality_out>&
DiscreteExteriorCalculusSolver<C, S, order_in, duality_in, order_out, duality_out>::compute(const Operator& linear_operator)
{
		solver.compute(linear_operator.container);
		calculus = linear_operator.calculus;
		return *this;
}

template <typename C, typename S, Order order_in, Duality duality_in, Order order_out, Duality duality_out>
KForm<C, order_in, duality_in>
DiscreteExteriorCalculusSolver<C, S, order_in, duality_in, order_out, duality_out>::solve(const InputKForm& input_kform) const
{
		ASSERT( calculus == input_kform.calculus );
		SolutionKForm solution(*input_kform.calculus, solver.solve(input_kform.container));
		//trace.info() << solver.info() << std::endl;
		return solution;
}

template <typename C, typename S, Order order_in, Duality duality_in, Order order_out, Duality duality_out>
bool
DiscreteExteriorCalculusSolver<C, S, order_in, duality_in, order_out, duality_out>::info() const
{
		return solver.info() == 0;
}

