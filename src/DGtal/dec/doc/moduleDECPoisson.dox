/**
 * @file moduleDECPoisson.dox
 * @author David Coeurjolly (\c david.coeurjolly@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Systemes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 *
 * @date 2014/04/04
 *
 * Documentation file for feature DECPoisson
 *
 * This file is part of the DGtal library.
 */

/*
 * Useful to avoid writing DGtal:: in front of every class.
 * Do not forget to add an entry in src/DGtal/base/Config.h.in !
 */
namespace DGtal {
//----------------------------------------
/*!
@page moduleDECPoisson Poisson problem
@writers Pierre Gueth


[TOC]

\section sectDECPoissonProblem Poisson equation

First the structure is created from a digital set. Here we used the EigenLinearAlgebraBackend.

\snippet exampleDiscreteExteriorCalculusSolve.cpp calculus_creation

Then the linear operator is defined. It is a regularized Laplace operator on dual 0-cells.

\f[ f = \Delta + \lambda I \f]

where \f$I\f$ is the identity operator and is generated using
DiscreteExteriorCalculusSolver.identity. 

\snippet exampleDiscreteExteriorCalculusSolve.cpp laplace_definition

@note The laplace operator could have been
defined as illustrated above from Hodge and exterior derivative
operators. However, DiscreteExteriorCalculus provides a method
to get the operator directly.

Input k-form \f$y\f$ is a Dirac delta positioned on the dual 0-cell at coordinates \f$(2,5)\f$.
Dual 0-cells are created by KhalimskySpaceND.sSpel.
DiscreteExteriorCalculus.getIndex return the index of the dual 0-form container associated with the dirac position cell.

The following illustration represents the dual of the input. Hence,
since we have specified a dirac on "dual 0-cell", its primal
representation attaches information to (primal) 2-cells.

\section sectDECPoisson1D 1D Poisson resolution

In this problem, we create an 1D linear structure embedded in a 2D space and we want to solve a Poisson equation on this structure.
The Poisson equation can be written as:

\f[ \Delta \phi = f \f]

where \f$\Delta\f$ is the Laplace operator, \f$\phi\f$ the solution of the problem and \f$f\f$ the input of the problem.
The Poisson equation can be viewed as the heat equation when permanent regime is reached.
\f$f\f$ is the heating applied to the structure and \f$\phi\f$ is the temperature reached in permanent regime.
Here we choose \f$f\f$ to be a Dirac delta function \f$\delta\f$ to simulation a punctual heating on the structure.

Boundary conditions will change to result on the problem.
The two classical boundary conditions are:
- Neumann boundary condition forces the derivative to be null along the border of the structure. Here, this means that heat can't flow out the start and the end of the linear structure.
- Dirichlet boundary condition connects borders of the structure to null potential. With own heat analogy, this means that the start and the end of the linear structure are connected to thermostat, which are given the null temperature.

Using the DEC package in 2D, one can define the Laplace operator using Hodge duality operators \f$\star\f$ and exterior derivative operators \f$d\f$.

\f[ \Delta = \star_2' d_1' \star_1 d_0 \f]

We show how to solve this problem and  how to change boundary conditions between Neumann and Dirichlet conditions by adding dangling 1-cells at the beginning and at the end of the structure.

\subsection sectDECPoisson1DNeumann Neumann boundary condition

First, an empty calculus structure is created and, using simple for loops, it is filled with some 0-cells and 1-cells to from a linear structure.
When filled manually with DiscreteExteriorCalculus.insertSCell, one can pass the primal over dual size ratio of each cell which defaults to 1.
Temperature nodes are associated primal 0-cells.
Note that to enforce Neumann boundary conditions, the linear structure has to end with 0-cells.
Moreover some 1-cells are inserted as negative cells to match their orientation with the orientation of the linear structure.

\snippet testLinearStructure.cpp neumann-creation

The input heat vector \f$f\f$, which is primal 0-form in the DEC formulation, is then created and is given values of a \f$\delta\f$.

\snippet testLinearStructure.cpp input-dirac

\image html linear_structure_neumann_dirac.png "Linear structure with Neumann boundary conditions. The input dirac 0-form is displayed, the red 0-cell is where the non zero point is located."

The Laplace operator \f$\Delta\f$ is pretty straight forward from its above definition.
One can use DiscreteExteriorCalculus.primalHodge and DiscreteExteriorCalculus.dualHodge to generate \f$\star\f$ operators and DiscreteExteriorCalculus.derivative to generate \f$d\f$ operators.

\snippet testLinearStructure.cpp neumann-laplace-definition

Now the problem is fully defined and there one thing left to do: solving it.
The resolution is done by DiscreteExteriorCalculusSolver.
This class takes the actual linear solver used as the second template parameter.
One can use any class that validates the CLinearAlgebraSolver concept.
Some solvers are provided inside the linear algebra backend we are using EigenLinearAlgebraBackend.
Here we will use the SolverSparseQR solver.
Once created the solver is given the operator using DiscreteExteriorCalculusSolver.compute.
The input dirac 0-form is passed to DiscreteExteriorCalculusSolver.solve, which return the solution of the problem.

\snippet testLinearStructure.cpp neumann-solve

Since the dirac input is null everywhere except at a single point, this means that the second derivative of the solution is null everywhere except at the dirac position.
An analytic form can be expressed as a continuous piece-wise quadratic function.
Numerical values of the solution fit analytic values with at least a relative precision of 1e-5.

\image html linear_structure_neumann_solution.png "Linear structure with Neumann boundary conditions. Solution 0-form is displayed."
\image html linear_structure_neumann_solution_gradient.png "Linear structure with Neumann boundary conditions. Gradient 1-form and vector field are displayed."
\image html linear_structure_neumann_fit.png "Numerical values computed using the solver and analytic solution for the Neumann problem."

\subsection sectDECPoisson1DDirichlet Dirichlet boundary condition

Dirichlet boundary condition fix value of 0-forms to be constant outside of definition domain.
In this package this constant value is chosen to be null.
Two dangling 1-cells are added at each end of the structure to describe Dirichlet boundary condition.
Since those 1-cells are not connected to a 0-cell on one of their border, this will simulate the presence of zero-valued 0-cell in those places through enforcing Dirichlet boundary conditions.

\snippet testLinearStructure.cpp dirichlet-creation

Input dirac can be used as it is since no 0-cells has been added to the structure.

\image html linear_structure_dirichlet_dirac.png "Linear structure with Dirichlet boundary conditions. The input dirac 0-form is displayed, the red 0-cell is where the non zero point is located."

However Laplace operator need to be rebuild.
Note that the code is the same as for the Neumann case.

\snippet testLinearStructure.cpp dirichlet-laplace-definition

Solving the problem is achieved by using the same code as for the Neumann case.
This time to analytical solution is piece-wise linear and take a constant null value at the border of the structure, as expect from the Dirichlet boundary condition.

\snippet testLinearStructure.cpp dirichlet-solve

Numerical values of the solution fit analytic values with at least a relative precision of 1e-5.

\image html linear_structure_dirichlet_solution.png "Linear structure with Dirichlet boundary conditions. Solution 0-form is displayed."
\image html linear_structure_dirichlet_solution_gradient.png "Linear structure with Dirichlet boundary conditions. Gradient 1-form and vector field are displayed."
\image html linear_structure_dirichlet_fit.png "Numerical and analytic solution for the Dirichlet problem."

\section sectDECPoisson2D 2D Poisson problem

\snippet exampleDiscreteExteriorCalculusSolve.cpp dirac_definition
\image html solve_laplace_calculus.png "DEC structure with input dual 0-form."

We tried to solve the problem using EigenLinearAlgebraBackend::SolverSimplicialLLT, but it DiscreteExteriorCalculusSolver.isValid() reports an error.
Underlying linear algebra solver DiscreteExteriorCalculusSolver.solver reports a 'numerical_error'.

\snippet exampleDiscreteExteriorCalculusSolve.cpp solve_llt
\image html solve_laplace_simplicial_llt.png "Poisson problem solution computed with simplicial LLT solver. Solver reports a numerical error."

Since the first solver we used failed, let's use another one: EigenLinearAlgebraBackend::SolverSimplicialLDLT for example.
This time DiscreteExteriorCalculusSolver.isValid is true after computing problem solution and the solution dual 0-form contains the solution of the problem.

\snippet exampleDiscreteExteriorCalculusSolve.cpp solve_ldlt
\image html solve_laplace_simplicial_ldlt.png "Poisson problem solution computed with simplicial LDLT solver. Solver solution is valid."

*/

}
