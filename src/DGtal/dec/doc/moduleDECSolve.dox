/**
 * @file moduleDECSolve.dox
 * @author David Coeurjolly (\c david.coeurjolly@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Systemes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 *
 * @date 2014/04/04
 *
 * Documentation file for feature DECSolve
 *
 * This file is part of the DGtal library.
 */

/*
 * Useful to avoid writing DGtal:: in front of every class.
 * Do not forget to add an entry in src/DGtal/base/Config.h.in !
 */
namespace DGtal {
//----------------------------------------
/*!
@page moduleDECSolve Documentation for usage of linear solver in the DEC package.
@writers Pierre Gueth


[TOC]

\section sectDECSolve1 DEC linear problem

Using the DEC package, one can solve any equation of the type:

\f[ f(x) = y \f]

where \f$x\f$ and \f$y\f$ are k-forms, with potentially different orders and dualities, and \f$f\f$ is a linear operator between k-forms.
k-forms are represented using KForm classes and linear operators are represented by LinearOperator classes.
One can create linear operators by manually filling LinearOperator.myContainer, but it's often easier to combine derivative \f$d\f$ and duality operators \f$\star\f$ computed by DiscreteExteriorCalculus.derivative, DiscreteExteriorCalculus.primalHodge and DiscreteExteriorCalculus.dualHodge.
Classical vector analysis operator such as gradient \f$\nabla\f$, divergence \f$\nabla\cdot\f$, curl \f$\nabla\wedge\f$ and laplacian \f$\Delta\f$ can be easily expressed with those operators:

\f[\nabla x = ( d x )^\sharp \f]

\f[\nabla\cdot x = \star d \star x^\flat \f]

\f[\nabla\wedge x = ( \star d x^\flat )^\sharp \f]

\f[\Delta x = \star d \star d x \f]

Recall that \f$\flat\f$ and \f$\sharp\f$ are operators that turn a vector field into a 1-form and the other way around.
Those operator are linear but don't transform k-forms into k-forms and therefore can't be represented by LinearOperator.
However DiscreteExteriorCalculus provide two apply those transformations on the associated k-form, namely DiscreteExteriorCalculus.flat and DiscreteExteriorCalculus.sharp.
We chose to disable \f$\flat\f$ and \f$\sharp\f$ representation because the quantity of information stored in the associated 1-form is always bigger than the quantity of information stored in the vector field.

\section sectDECSolve2 DEC linear solver

If your problem factorize as above, you can use DiscreteExteriorCalculusSolver to solve it.
The solving method used is provided as the second template parameter of DiscreteExteriorCalculusSolver.
It depends on the linear algebra backend you used as second template argument in the definition of DiscreteExteriorCalculus.
Usually some linear solvers are provided in the linear algebra backend itself, but you can create your own as long as it models the CLinearAlgebraSolver concept.

If you activated Eigen support during compilation, you can use any solver provided in the EigenSupport.h header.
It is recommended to use the EigenSparseLinearAlgebraBackend since it is fast and provide a lot of linear solvers.

Once the DEC solver is created, the linear operator \f$f\f$ must be passed via DiscreteExteriorCalculusSolver.compute.
Depending on the linear solver used, this will factorize the problem or do precomputation on the linear operator.
This speed up the resolution of problems that share the same linear operator.
Input k-form \f$y\f$ is passed to the solver via DiscreteExteriorCalculusSolver.solve which return the solution k-form \f$x\f$.
If the resolution was successful, then DiscreteExteriorCalculusSolver.isValid will return true.
If there was a problem, it can be further investigated by direct access to the linear algebra solver DiscreteExteriorCalculusSolver.solver. 

\section sectDECSolve3 Poisson equation

First the structure is created from a digital set. Here we used the EigenSparseLinearAlgebraBackend.

\snippet exampleDiscreteExteriorCalculusSolve.cpp calculus_creation

Then the linear operator is defined. It is a regularized Laplace operator on dual 0-cells.

\f[ f = \Delta + \lambda I \f]

where \f$I\f$ is the identity operator and is generated using DiscreteExteriorCalculusSolver.identity.

\snippet exampleDiscreteExteriorCalculusSolve.cpp laplacian_definition

Input k-form \f$y\f$ is a Dirac delta positioned on the dual 0-cell at coordinates \f$(2,5)\f$.
Dual 0-cells are created by KhalimskySpaceND.sSpel.
DiscreteExteriorCalculus.getIndex return the index of the dual 0-form container associated with the dirac position cell.

\snippet exampleDiscreteExteriorCalculusSolve.cpp dirac_definition
\image html solve_calculus.png "DEC structure with input dual 0-form."

We tried to solve the problem using EigenSparseLinearAlgebraBackend::SolverSimplicialLLT, but it DiscreteExteriorCalculusSolver.isValid() reports an error.
Underlying linear algebra solver DiscreteExteriorCalculusSolver.solver reports a 'numerical_error'.

\snippet exampleDiscreteExteriorCalculusSolve.cpp solve_llt
\image html solve_simplicial_llt.png "Poisson problem solution computed with simplicial LLT solver. Solver reports a numerical error."

Since the first solver we used failed, let's use another one: EigenSparseLinearAlgebraBackend::SolverSimplicialLDLT for example.
This time DiscreteExteriorCalculusSolver.isValid is true after computing problem solution and the solution dual 0-form contains the solution of the problem.

\snippet exampleDiscreteExteriorCalculusSolve.cpp solve_ldlt
\image html solve_simplicial_ldlt.png "Poisson problem solution computed with simplicial LDLT solver. Solver solution is valid."

\section sectDECSolve4 Helmoltz decomposition

\snippet exampleDiscreteExteriorCalculusSolve.cpp 2d_primal_decomposition_input_field_definition
\snippet exampleDiscreteExteriorCalculusSolve.cpp 2d_dual_decomposition_input_field_definition

\image html solve_2d_primal_decomposition_calculus.png "Primal Helmoltz decomposition. Primal input vector field and 1-form."
\image html solve_2d_dual_decomposition_calculus.png "Dual Helmoltz decomposition. Dual input vector field and 1-form."

\snippet exampleDiscreteExteriorCalculusSolve.cpp 2d_primal_decomposition_operator_definition
\snippet exampleDiscreteExteriorCalculusSolve.cpp 2d_dual_decomposition_operator_definition

\snippet exampleDiscreteExteriorCalculusSolve.cpp 2d_primal_decomposition_curl_free_solve
\snippet exampleDiscreteExteriorCalculusSolve.cpp 2d_dual_decomposition_curl_free_solve

\image html solve_2d_primal_decomposition_curl_free.png "Primal Helmoltz decomposition curl-free component."
\image html solve_2d_dual_decomposition_curl_free.png "Dual Helmoltz decomposition curl-free component."

\snippet exampleDiscreteExteriorCalculusSolve.cpp 2d_primal_decomposition_div_free_solve
\snippet exampleDiscreteExteriorCalculusSolve.cpp 2d_dual_decomposition_div_free_solve

\image html solve_2d_primal_decomposition_div_free.png "Primal Helmoltz decomposition divergence-free component."
\image html solve_2d_dual_decomposition_div_free.png "Dual Helmoltz decomposition divergence-free component."

\snippet exampleDiscreteExteriorCalculusSolve.cpp 2d_primal_decomposition_solution
\snippet exampleDiscreteExteriorCalculusSolve.cpp 2d_dual_decomposition_solution

\image html solve_2d_primal_decomposition_harmonic.png "Primal Helmoltz decomposition harmonic component."
\image html solve_2d_dual_decomposition_harmonic.png "Dual Helmoltz decomposition harmonic component."

*/

}
