/**
 * @file moduleDECOperators.dox
 * @author David Coeurjolly (\c david.coeurjolly@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Systemes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 *
 * @date 2014/04/04
 *
 * Documentation file for feature DECOperators
 *
 * This file is part of the DGtal library.
 */

/*
 * Useful to avoid writing DGtal:: in front of every class.
 * Do not forget to add an entry in src/DGtal/base/Config.h.in !
 */
namespace DGtal {
//----------------------------------------
/*!
@page moduleDECOperators Discrete Exterior Calculus
@writers Pierre Gueth


[TOC]


\section sectDECOperators0 Scalar fields, vector fields and k-forms 

\subsection subsectDECOperators21 Vector space

Linear operators form vector spaces and can be added together and scaled by a scalar.

\section sectDECOperators1 Linear operators between k-forms

\image html operators_3d.png "DEC operators with definition cells for a rectangular grid."


\subsection subsectDECOperators11 Hodge duality operator

Hodge operators take primal (resp. dual) k-forms as input and create dual (resp. primal) k-forms.
The order is preserved and the duality is negated.

\subsection subsectDECOperators12 Exterior derivative

Exterior derivatives take k-forms as inputs and create (k+1)-forms.
Input and output forms have the same duality.
Operators therefore come in two flavors, primal and dual.

\subsection subsectDECOperators22  Laplace operator

\image html operators_3d_laplace.png "DEC operators with definition cells for a rectangular grid. Highlighted dual laplace operator."

\sectDECOperators1 sectDECOperators5 More formal insight

- Keenan Crane Siggraph lecture 2012-13
- My presentation

\section sectDECSolve1 DEC Linear Problem

Using the DEC package, one can solve any equation of the type:

\f[ f(x) = y \f]

where \f$x\f$ and \f$y\f$ are k-forms, with potentially different orders and dualities, and \f$f\f$ is a linear operator between k-forms.
k-forms are represented using KForm class and linear operators are represented by LinearOperator class.
One can create linear operators by manually filling LinearOperator.myContainer, but it's often easier to combine derivative \f$d\f$ and duality operators \f$\star\f$ computed by DiscreteExteriorCalculus.derivative, DiscreteExteriorCalculus.primalHodge and DiscreteExteriorCalculus.dualHodge.
Classical vector analysis operator such as gradient \f$\nabla\f$, divergence \f$\nabla\cdot\f$, curl \f$\nabla\wedge\f$ and Laplace operator \f$\Delta\f$ can be easily expressed with those operators:

\f[\nabla x = ( d x )^\sharp \f]

\f[\nabla\cdot x = \star d \star x^\flat \f]

\f[\nabla\wedge x = ( \star d x^\flat )^\sharp \f]

\f[\Delta x = \star d \star d x \f]

Recall that \f$\flat\f$ and \f$\sharp\f$ are operators that turn a vector field into a 1-form and the other way around.
Those operators are linear but do not transform k-forms into k-forms and therefore can't be represented by LinearOperator.
However DiscreteExteriorCalculus allows us to apply those transformations on associated k-forms and vector fields, namely DiscreteExteriorCalculus.flat and DiscreteExteriorCalculus.sharp.
These operators are cached in the DiscreteExteriorCalculus object and support intense load, as Hodge and derivative operators do.
We chose to disable \f$\flat\f$ and \f$\sharp\f$ representation because the quantity of information stored in the associated 1-form is always bigger than the quantity of information stored in the vector field.

\subsection sectDECSolve2 DEC Linear Solver

If your problem can be described in terms of exterior derivative,
hodge operators and sharp/flat as discussed above, you can use DiscreteExteriorCalculusSolver to solve it.
Or at least try to ;)

The solving method used is provided as the second template parameter of DiscreteExteriorCalculusSolver.
It depends on the linear algebra backend you pass as second template argument in the definition of DiscreteExteriorCalculus.
Usually some linear solvers are provided in the linear algebra backend itself, but you can create your own as long as it models the CLinearAlgebraSolver concept.

If you activated Eigen support during compilation (i.e. "-DWITH_EIGEN=true"), you can use any solver provided in the EigenSupport.h header.
It is recommended to use the EigenLinearAlgebraBackend since it is fast and provide a lot of linear solvers.

Once the DEC solver is created, the linear operator \f$f\f$ must be passed via DiscreteExteriorCalculusSolver.compute.
Depending on the linear solver used, this will factorize the problem or do precomputation on the linear operator.
This speed up the resolution of problems that share the same linear operator.
Input k-form \f$y\f$ is passed to the solver via DiscreteExteriorCalculusSolver.solve which return the solution k-form \f$x\f$.
If the resolution was successful, then DiscreteExteriorCalculusSolver.isValid will return true.
If there was a problem, it can be further investigated by direct access to the linear algebra solver DiscreteExteriorCalculusSolver.solver. 

Choosing the right solver for the right problem has a direct impact on overall performances.
The EigenLinearAlgebraBackend provide wrapper for all linear algebra solvers included in the Eigen library.
This <a href="http://eigen.tuxfamily.org/dox/group__TopicSparseSystems.html">documentation page</a> provides a nice summary of wrappable solvers along with their main traits.

\section sectDECOperators3 Creating calculus

In this package, the main DEC object is DiscreteExteriorCalculus.
The first template parameter is the dimension of the embedding space, and
therefore be at least equals to the dimension of object one would like to represent.
The second template parameter is a linear algebra backend used internally.
By now, there is only one available backend: EigenLinearAlgebraBackend.
For example, here is a snippet that define a working two dimensionnal DEC object.

\snippet exampleDiscreteExteriorCalculusUsage.cpp usage_calculus_typedef

The DiscreteExteriorCalculus provides a default constructor that initializes an empty structure, ready to be filled with DiscreteExteriorCalculus::SCell through the DiscreteExteriorCalculus.insertSCell member.
A DiscreteExteriorCalculus object can also be created from a set of points implementing the CDigitalSet concept. This constructor inserts each point as an primal n-cell in the structure and then fills in between k-cells to glue all n-cells together. Borders can be added or removed from the genarated structure using the add_border boolean.
Dual k-cells are created automatically with the right size ratio.
Note that the struture can be altered after creation to adjust small details (DiscreteExteriorCalculus.insertSCell and DiscreteExteriorCalculus.eraseSCell),
but it should not be modified during the instanciation of any DEC objects or operators.

This snippet creates shows how to create a DEC structure.
The first call to DiscreteExteriorCalculus.eraseSCell remove the primal n-cell located of the right of the structure.
The associated dual 0-cell is detroyed automatically.
Note that n-cell are created using KhalimskySpaceND.sSpel, and that coordinates of such cells are given in the same system as points from the input set.
The second call removes a primal 1-cell and opens the hole created by the first call.
Here coordinates are given in the KhalimskySpaceND signed cell frame of reference.

\snippet exampleDiscreteExteriorCalculusUsage.cpp usage_calculus_definition_with_border
\image html usage_calculus_with_border.png "Calculus with border."

If you want to have border-less structure, simply reset the add_border boolean.
The second call to DiscreteExteriorCalculus.eraseSCell isn't nedd anymore since the edge was not inserted in the first place.

\snippet exampleDiscreteExteriorCalculusUsage.cpp usage_calculus_definition_without_border
\image html usage_calculus_without_border.png "Calculus without border."

\section sectDECOperators4 KForms and vector fields

\snippet exampleDiscreteExteriorCalculusUsage.cpp usage_primal_fill_zero_form
\image html usage_primal_zero_form.png "Primal 0-form."

\snippet exampleDiscreteExteriorCalculusUsage.cpp usage_primal_form_algebra
\snippet exampleDiscreteExteriorCalculusUsage.cpp usage_primal_gradient
\image html usage_primal_one_form.png "Gradient primal 1-form and primal vector field."

\snippet exampleDiscreteExteriorCalculusUsage.cpp usage_primal_flat_sharp
\image html usage_primal_one_form_sharp_flat.png "Primal and dual vector fields."

\snippet exampleDiscreteExteriorCalculusUsage.cpp usage_primal_hodge_gradient
\image html usage_primal_one_form_hodge.png "Dual gradient field."




*/

}
