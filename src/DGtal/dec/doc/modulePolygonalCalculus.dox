/**
 * @file 
 * @author David Coeurjolly (\c david.coeurjolly@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Systemes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 *
 * @date 2021/09/07
 *
 * Documentation file for feature PolygonalCalculus
 *
 * This file is part of the DGtal library.
 */

/*
 * Useful to avoid writing DGtal:: in front of every class.
 * Do not forget to add an entry in src/DGtal/base/Config.h.in !
 */
namespace DGtal {
//----------------------------------------
/*!
@page modulePolygonalCalculus Discretre differential calculus on polyongal surfaces
@writers David Coeurjolly

[TOC]

@since 1.2

  Part of package \ref packageDEC.

In this documentation page, we detail the operators and tools allowing
to perform differential calculus computations on generic polygonal surfaces
(PolygonalCalculus class).  Such polygonal surfaces could be generic
meshes (with non planar, non convex faces), or DigitalSurface models.

The main principle, compared to the \ref moduleDECIntroduction
approach, is to define per face operators which can be later combined
to define global ones.

This module documents operators defined in \cite degoes2020discrete.



@note All illustrations below have been obtained using the DGtal+[polyscope](https://polyscope.run) examples \ref dgtalCalculus.cpp and dgtalCalculus-single.cpp. To build these examples, enable the `BUILD_POLYSCOPE_EXAMPLES` variable (e.g. `cmake .. -DBUILD_POLYSCOPE_EXAMPLES=ON`).


\section sectPolygonalCalculusIntro Introduction

The main idea of \cite degoes2020discrete is to define discrete operators per face, which can be combined to obtain a global operator acting on meshes. For vertex valued scalar or vector fields, this class implements elementary differential operators. 




\section sectPolygonalCalculus2 Per face operators

Let us consider a single (non-planar, non-convex) face example. Using

@code
using SurfMesh = SurfaceMesh<Z3i::RealPoint,Z3i::RealVector>;
using namespace Z3i;

//Vertices
std::vector<RealPoint> positions={ {0,0,0},{20,0,0},{20,10,0},{10,8,5}, {0,15,1} };
//Single face
std::vector<std::vector<size_t>> faces={{ 0,1,2,3,4 }};

mesh = SurfMesh(positions.begin(),positions.end(),faces.begin(),faces.end());
  
PolygonalCalculus<SurfMesh> calculus(mesh);
@endcode

we obtain a single SurfaceMesh instance and its associated PolygonalCalculus object.

 Example| Example 
--|--
@image html images/poly/face.png "" | @image html images/poly/face_rot.png ""

Let us add a scalar function on vertices. For instance, using Eigen syntax, we can use;

@code
PolygonalCalculus<SurfMesh>::Vector phi(5); //5 vertices
phi << 1.0, 2.0, 0.0, 5.0 ,1.5;
@endcode

@note As the face is nonconvex / nonplanar, the vertex  scalar quantity  interpolation and the rendering in polyscope may be a bit odd.

Phi| Interpolated phi
--|--
@image html images/poly/face_phi.png "" | @image html images/poly/face_phi_interp.png  ""


\subsubsection susub1 Basic operators

We first describe the standard operators. 

Operator  | Output | Description
------------- | ------------- | ----
`calculus.X(f)`  | \f$ n_f\times 3\f$ | position of the face vertices
`calculus.E(f)`  | \f$ n_f\times 3\f$ | returns the edge vectors of the face
`calculus.A(f)`  | \f$ n_f\times n_f\f$ | average operator that average some values on vertices to values on edges (vectors \f$(p_{i+1}-p_{i})\in\mathbb{R}^3\f$)
`calculus.B(f)`  | \f$ n_f\times 3\f$ | the edge mid-point operator of the face
`calculus.vectorArea(f)`  | \f$ n_f\f$ vector | the corrected vector area of the face (uses the embedder)
`calculus.faceArea(f)`  | scalar | the corrected face  area  (uses the embedder)
`calculus.faceNormalVector(f)`| vector in \f$\mathbb{R}^3\f$ | the corrected (unitary) normal vector of the face  (uses the embedder)
`calculus.faceNormalAsDGtalVector(f)`| RealVector | the corrected (unitary) normal vector of the face  (uses the embedder)
`calculus.centroid(f)`| vector in \f$\mathbb{R}^3\f$ | the corrected centroid of the face
`calculus.centroidAsDGtalVector(f)`| RealVector | the corrected centroid of the face

\subsubsection subderiv Derivatives

Operator  | Output | Description
------------- | ------------- | ----
`calculus.D(f)`  | \f$ n_f\times n_f\f$ | derivative operator (d0 in DEC) mapping scalar values on vertices to values on edges (vertex scalars to a  1-form)
`calculus.gradient(f)`|  \f$ 3 \times n_f\f$  | the gradient operator for vertex valued scalar functions of the face f
`calculus.coGradient(f)`|  \f$ 3 \times n_f\f$  | the co-gradient operator for vertex valued scalar functions of the face f


A*phi | D*phi (discrete 1-form)
--| --
@image html images/poly/A_phi.png "" | @image html images/poly/D_phi.png "" 


gradient | co-gradient | corrected normal
--| -- | --
@image html images/poly/gradient.png ""  | @image html images/poly/cogradient.png ""  | @image html images/poly/normal.png ""





\subsubsection subdflat Flat/sharp and projection operators


Operator  | Output | Description
------------- | ------------- | ----
`calculus.V(f)`  | \f$ n_f\times 3\f$ | Flat operator that maps an ambient vector to a local discrete 1-form 
`calculus.U(f)`|  \f$ 3 \times n_f\f$  | Sharp operator that maps a discrete 1-form to an ambient vector
`calculus.P(f)`|  \f$ n_f \times n_f\f$  | Projection operator acting on a discrete 1-form and remove the associated non-tangential part of the vector reconstructed using the sharp operator

Discrete flat and sharp operators match with the DEC operators (see @moduleDECIntroduction). For short, the flat operator represent a ambient vector as a discrete 1-form (roughly values on the face edges) while the sharp operator pull-back a 1-form to reconstruct a vector in @f$\mathbb{R}^3@f$. These operators are rank 2 and @f$ U_f V_f s = s\f$ for any vector @f$s@f$ in the face tangent plane, but the property reversing the order on 1-forms does not hold (due to rank deficiencies of the matrices). 
This is quantified by the projection operator @f$P@f$ (see @cite degoes2020discrete for structural lemmas, e.g. @f$ normal_f\cdot (U_f V_f s)=0\quad \forall s\in$\mathbb{R}^3@f$...).






a vector in @f$\mathbb{R}^3@f$  | a vector in @f$\mathbb{R}^3@f$ | Flat (1-form) | Sharp of the flat | Sharp and normal vector
--| -- | -- | -- | --
@image html images/poly/face_vec.png ""  | @image html images/poly/face_vec1.png ""  | @image html images/poly/face_flat.png ""  | @image html images/poly/face_sharp.png ""   | @image html images/poly/face_sharpnorm.png ""



\subsubsection sublap Inner product and Laplace-Beltrami operators

Operator  | Output | Description
------------- | ------------- | ----
`calculus.M(f,lambda)`  | \f$ n_f\times 3\f$ | Inner product operator on discrete 1-forms operator (lambda is a regularization parameter, see @cite degoes2020discrete)
`calculus.LaplaceBeltrami(f,lambda)`|  \f$ 3 \times n_f\f$  | Laplace-Beltrami operator \f$ D^tMD \f$ (lambda is a regularization parameter, see @cite degoes2020discrete), the matrix is PSD

 

\section sectPolygonalCalculusGlo Global calculus

Given a scalar function defined on a generic surface mesh vertices, all previously mentioned operators can be applied to obtain consistent quantities on the overall mesh. For instance:


Surface  | Phi | Gradient | Gradient+co-gradient 
--|--|--|--
@image html images/poly/init.png "" | @image html images/poly/goursat_phi.png "" | @image html images/poly/goursat_grad.png "" | @image html images/poly/goursat_gradcograd.png ""


To solve some global PDE (e.g. Poisson problems on the mesh @f$ \Delta u = f @f$), one can combine the local operators into a global one, gathering the contributions of each face. 

For example, the PolygonalCalculus<SurfMesh>::globalLaplaceBeltrami() method outputs a global (sparse) Laplace-Beltrami operator which can latter be used for diffusion.


\section sectPolygonalCalculusHP Cache mechanisms and high performance computing

For the sake of readability, each operator has been implemented implicitly. For example, the @e M @e  operator per face is given by
@code
DenseMatrix M(const Face f, const double lambda=1.0) const
{
  auto Uf=U(f);
  auto Pf=P(f);
  return faceArea(f) * Uf.transpose()*Uf + lambda * Pf.transpose()*Pf;
}
@endcode 
which could be time consuming as the internal operators may be computed several times. 

For high performance computations, we provide a generic cache mechanism to explicitly store all per face operators of a surface mesh (stored in a random access container).

A Typical usages is 
@code
auto cacheU        = getOperatorCacheMatrix( [&](Face f){ return(calculus.U(f);} );
auto cachefaceArea = getOperatorCacheMatrix( [&](Face f){ return(calculus.faceArea(f);} );
auto cacheP        = getOperatorCacheMatrix( [&](Face f){ return(calculus.P(f);} );
@endcode

Then, cached operators can be access and combined:
@code
auto Mf =   cachefaceArea[f] * cacheU[f].transpose()*cacheU[f] + lambda * cacheP[f].transpose() * cacheP[f];
@endcode 



*/

}
