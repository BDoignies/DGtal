/**
 * @file moduleDECPropagation.dox
 * @author David Coeurjolly (\c david.coeurjolly@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Systemes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 *
 * @date 2015/03/27
 *
 * Documentation file for feature DECPropagation
 *
 * This file is part of the DGtal library.
 */

/*
 * Useful to avoid writing DGtal:: in front of every class.
 * Do not forget to add an entry in src/DGtal/base/Config.h.in !
 */
namespace DGtal {
//----------------------------------------
/*!
@page moduleDECPropagation Propagation equation
@writers Pierre Gueth

[TOC]

\section sectDECPropagationIntro Intro

Propagation plays a important role in physics as it models a lots a problem ranging from classical oscillators electromagnetics to electromagnetics and quantum mechanics.
Here we will study the linear propagation of a time dependent scalar field \f$\psi(x,t)\f$, modelled as dual 0-form in the example.

\f[ \Delta \psi + \frac{1}{c^2} \frac{\partial^2\psi}{\partial t^2} = \left( \Delta + \frac{1}{c^2} \frac{\partial^2}{\partial t^2} \right) \psi = \rho \f]

where \f$c\f$ is propagation speed inside the medium and \f$\rho(x,t)\f$ is the concentration field that generate waves.
The \f$+\f$ differs from the classical physics equation since here we consider \f$\Delta\f$ to have positive eigen values,
which is the opposite of the definition of the Laplace operator in physics.
As DEC handles only spatial dimensions, we will present classic but useful tricks that can be used to handle the time dependent in many physics problems.
For simplicity of notation, we define the propapagation operator \f$\square\f$.

\f[ \square  = \Delta + \frac{1}{c^2} \frac{\partial^2}{\partial t^2} \f]

\section sectDECPropagationTime Temporal resolution with initial condition

In this example, we compute the time evolution of a wave given it initial (potentially complex) wave function \f$\psi(x,0)=\psi_0(x)\f$.
Consider the homogeneous propagation where \f$\rho(x,t) = 0\f$

\f[ \square \psi = 0 \f]

First consider the Laplace operator. Since it is a positive semi definite real valued hermitian operator, its eigen pairs are all real and positive.

\f[ \Delta \phi_i = k_i^2 \, \phi_i \f]

where \f$\phi_i\f$ are eigen vectors and \f$k_i^2\f$ are corresponding eigen values.
The Laplace operator \f$\Delta\f$ is computed using DiscreteExteriorCalculus.dualLaplace.
A small DiscreteExteriorCalculus.identity to ensure a proper definition of \f$\Delta\f$.

\snippet examplePropagation.cpp time_laplace

\f$k_i^2\f$ and \f$\phi_i\f$ can be computed using Eigen::SelfAdjointEigenSolver for small system.
\f$\phi_i\f$ is the ith column of the eigen_vectors matrix.
For larger systems, one can use more advance techniques such as band shift invert resolution.

\snippet examplePropagation.cpp time_eigen

\f$\phi_i\f$ form an orthonormal basis of the Laplace operator solutions.
One can use this property to define \f$\psi_i\f$ an orthonormal basis of solutions of the homogeneous propagation equation (it is easy to check that \f$\square \psi_i = 0\f$).

\f[ \psi_i(x,t) = \phi_k(x) \, e^{j c k_i t} \f]

where \f$j\f$ is the imaginary unit.
Using this basis, one can project any solution \f$\psi\f$ of the propagation equation on it.
The (potentially complex) coordinates \f$p_i\f$ in the \f$\psi_i\f$ basis are

\f[ p_i = \left< \psi | \psi_i \right> \f]

where for each \f$t\f$, \f$\left< \bullet | \bullet \right> \f$ is the inner product between dual 0-forms.
In the DEC framework, such a product can be computed as the scalar product between the discrete value vector KForm.myContainer.
We can then write \f$\psi\f$ as

\f[ \psi = p_i \, \psi_i \f]

where the summation over \f$i\f$ is implicit.
Note that for \f$t=0\f$, \f$\psi_i(x,0) = \phi_i(x)\f$.
To solve the temporal evolution from \f$\psi_0(x)\f$, all we need to do is find its initial projections \f$p_{0i}\f$ and let complex exponentials do the their duty to predict future (and past) wave functions.

\f[ p_{0i} = \left< \psi_0 | \phi_i \right>  \f]

Those inner product are computed by multiplying the initial wave 0-form container with the transposed eigen_vectors matrix.

\snippet examplePropagation.cpp time_init_proj

For aesthetic reason, initial projections are filtered to keep only low frequency (high wavelength) components.

\snippet examplePropagation.cpp time_low_pass

To get the wave function for any other time \f$t\f$, \f$\psi\f$ is computed as

\f[ \psi(x,t) = p_{0i} \, \psi_i(x,t) = p_{0i} \, \phi_i(x) \, e^{j c k_i t} \f]

This translate to the following code where the term \f$c k_i\f$ is precomputed for all times.

\snippet examplePropagation.cpp time_omega
\snippet examplePropagation.cpp time_solve_time

For real wave functions, knowing the initial wave is not enough the get a unique answer. One would have to know temporal initial wave derivative as well to fully determine the propagation behavior. When one use complex wave functions, the derivative initial conditions are replaced by the phase of the initial wave. By changing the phase field, one would get different behavior. For example if one choose initial wave as described above, one would get a nice uniform propagation of the wave.

\snippet examplePropagation.cpp time_phase_null
\image html propagation_time_wave_i.gif "Real part of wave propagating from initial conditions with null phase."

If, on the other hand, one starts to mess with the phase on the initial wave and introduce phase variation along y, one would get a directional propagation of the wave along -y.

\snippet examplePropagation.cpp time_phase_yy
\image html propagation_time_wave_ii.gif "Real part of wave propagating from initial conditions with phase variation along y."

\section sectDECPropagationForced Forced permanent regime solution

Wavenumber \f$k_p = \frac{2 \pi}{\lambda_p}\f$
\f[ \rho(x,t) = \rho_p(x) \, e^{j c k_p t} = \rho_p(x) \, e^{\frac{2 \pi c t}{\lambda_p}} \f]

\f[ \psi(x,t) = \psi_p(x) \, e^{j c k_p t} \f]

\f[ \square \psi = \rho \;\Leftrightarrow\; ( \Delta - k_p^2 \, I ) \, \psi_p = \rho_p \;\Leftrightarrow\; \psi_p = ( \Delta - k_p^2 \, I )^{-1} \, \rho_p \f]

\f[ \Delta \phi_i = k_{\Delta i}^2 \, \phi_i \f]

\f[ ( \Delta - k_p^2 \, I )^{-1} \phi_i = \frac{1}{k_{\Delta i}^2-k_p^2} \, \phi_i \f]

\f[ p_{pi} = \left< \psi_p | \phi_i \right>  \; r_{pi} = \left<\rho_p | \phi_i \right> \f]

\f[ p_{pi} = \frac{r_{pi}}{k_{\Delta i}^2 - k_p^2} \f]

\snippet examplePropagation.cpp forced_lambda
\snippet examplePropagation.cpp forced_dalembert_eigen
\snippet examplePropagation.cpp forced_wave

\image html propagation_forced_wave_0.png "Forced permanent regime for lambda = lambda_0."
\image html propagation_forced_wave_1.png "Forced permanent regime for lambda = lambda_1."
\image html propagation_forced_wave_2.png "Forced permanent regime for lambda = lambda_2."
\image html propagation_forced_wave_3.png "Forced permanent regime for lambda = lambda_3."
\image html propagation_forced_wave_4.png "Forced permanent regime for lambda = lambda_4."
\image html propagation_forced_wave_5.png "Forced permanent regime for lambda = lambda_5."
\image html propa_samples.png "Forced permanent regime samples along vertical, horizontal and diagonal lines for lambda_k."

*/

}
