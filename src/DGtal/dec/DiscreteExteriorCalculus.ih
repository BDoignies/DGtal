/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file DiscreteExteriorCalculus.ih
 * @author Pierre Gueth (\c pierre.gueth@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Systemes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 *
 * @date 2014/03/27
 *
 * Implementation of inline methods defined in DiscreteExteriorCalculus.h
 *
 * This file is part of the DGtal library.
 */

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------

template <typename D, typename LAB>
template <typename DigitalSet>
DGtal::DiscreteExteriorCalculus<D, LAB>::DiscreteExteriorCalculus(const DigitalSet& _set, const bool& add_border)
    : myDomain(_set.domain()), myKSpace(), cell_properties()
{
    BOOST_STATIC_ASSERT(( boost::is_same<typename DigitalSet::Domain, Domain>::value ));

    // init khalimsky space
    // FIXME borders are removed from set => better not initialize kspace
    // FIXME should be open or closed?
    //bool kspace_init_ok = const_cast<KSpace&>(myKSpace).init(myDomain.lowerBound(), myDomain.upperBound(), false);
    //ASSERT(kspace_init_ok);

    // compute raw cell size
    typedef std::map<SCell, Scalar> Accum;
    Accum cell_size_accum;
    for (typename DigitalSet::ConstIterator ri=_set.begin(), rie=_set.end(); ri!=rie; ri++)
    {
        const Point& point = *ri;
        const SCell cell_point = myKSpace.sSpel(point, KSpace::POS);

        Points neighborhood;
        neighborhoodRecurseSizeMask(dimension-1, cell_point.myCoordinates, neighborhood);
        for (typename Points::const_iterator pi=neighborhood.begin(), pie=neighborhood.end(); pi!=pie; pi++)
        {
            const SCell cell = myKSpace.sCell(*pi, KSpace::POS);
            if (cell_size_accum.find(cell) == cell_size_accum.end()) cell_size_accum[cell] = 0;
            cell_size_accum[cell] += 1;
        }
    }

    // normalize cell size and set flipped flag
    for (typename Accum::const_iterator csi=cell_size_accum.begin(), csie=cell_size_accum.end(); csie!=csi; csi++)
    {
        const SCell& cell = csi->first;
        const DGtal::Dimension dual_dim = dimension-myKSpace.sDim(cell);
        const Scalar factor = 1/pow(2, dual_dim);

        const Scalar normalized_size = csi->second * factor;
        ASSERT(normalized_size > 0 && normalized_size <= 1);

        if (!add_border && normalized_size < 1) continue;

        Property property;
        property.display_flipped = false;
        property.size_ratio = normalized_size;

        cell_properties[cell] = property;
    }

    // compute cell index
    for (typename Properties::iterator csi=cell_properties.begin(), csie=cell_properties.end(); csie!=csi; csi++)
    {
        const SCell& cell = csi->first;
        const DGtal::Dimension dim = myKSpace.sDim(cell);
        ASSERT( myKSpace.sSign(cell) == KSpace::POS );
        ASSERT( cell.myPositive == true );

        csi->second.index = index_cells[dim].size();
        index_cells[dim].push_back(cell);
    }
}

template <typename D, typename LAB>
DGtal::DiscreteExteriorCalculus<D, LAB>::DiscreteExteriorCalculus(const D& _domain)
    : myDomain(_domain), myKSpace(), cell_properties()
{
}

///////////////////////////////////////////////////////////////////////////////
// Interface - public :

template <typename D, typename LAB>
bool
DGtal::DiscreteExteriorCalculus<D, LAB>::eraseSCell(const SCell& _cell)
{
    const SCell abs_cell = absoluteSCell(_cell);

    typename Properties::iterator iter_property = cell_properties.find(abs_cell);
    if (iter_property == cell_properties.end())
        return false;

    const DGtal::Dimension dim = myKSpace.sDim(abs_cell);
    const Index index = iter_property->second.index;
    cell_properties.erase(iter_property);

    typename SCells::iterator iter_index = index_cells[dim].begin() + index;
    ASSERT( *iter_index==abs_cell );
    iter_index = index_cells[dim].erase(iter_index);

    for (typename SCells::const_iterator iter_index_end = index_cells[dim].end(); iter_index!= iter_index_end; iter_index++)
    {
        const SCell cell_next = *iter_index;
        typename Properties::iterator iter_property_next = cell_properties.find(cell_next);
        ASSERT( iter_property_next!=cell_properties.end() );
        ASSERT( iter_property_next->second.index > index );
        iter_property_next->second.index -= 1;
    }

    return true;
}

template <typename D, typename LAB>
bool
DGtal::DiscreteExteriorCalculus<D, LAB>::insertSCell(const SCell& _cell, const Scalar& _primal_size)
{
    SCell abs_cell = _cell;
    Property property;
    property.size_ratio = _primal_size;
    property.display_flipped = false;

    if (!abs_cell.myPositive)
    {
        abs_cell = myKSpace.sOpp(abs_cell);
        //property.size_ratio = -property.size_ratio;
        property.display_flipped = true;
    }

    typename Properties::iterator iter = cell_properties.find(abs_cell);
    const bool need_insert = (iter == cell_properties.end());

    if (need_insert) // new cell new index computation
    {
        const DGtal::Dimension dim = myKSpace.sDim(abs_cell);
        property.index = index_cells[dim].size();
        index_cells[dim].push_back(abs_cell);
        cell_properties[abs_cell] = property;
        iter = cell_properties.find(abs_cell);
    }
    else
    {
        property.index = iter->second.index;
    }

    ASSERT( property.index == iter->second.index );

    iter->second = property;

    return need_insert;
}

template <typename D, typename LAB>
std::string
DGtal::DiscreteExteriorCalculus<D, LAB>::className() const
{
    return "Calculus";
}

template <typename D, typename LAB>
void
DGtal::DiscreteExteriorCalculus<D, LAB>::selfDisplay(std::ostream & os) const
{
    typedef DiscreteExteriorCalculus<D, LAB> Calculus;

    os << "[DiscreteExteriorCalculus ";
    os << myDomain;
    for (DGtal::Order order=0; order<=Calculus::dimension; order++)
        os << " | primal " << order << "-cells <-> dual " << Calculus::dimension-order << "-cells (" << kFormLength(order, PRIMAL) << ")";
    os << "]";
}

template <typename D, typename LAB>
void
DGtal::DiscreteExteriorCalculus<D, LAB>::neighborhoodRecurseSizeMask(const DGtal::Dimension& dimension, const Point& current_point, Points& neighborhood)
{
    typedef typename Point::Coordinate Coordinate;

    for (Coordinate delta=-1; delta<2; delta++)
    {
        Point point = current_point;
        point[dimension] += delta;

        if (dimension==0)
        {
            neighborhood.push_back(point);
            continue;
        }

        neighborhoodRecurseSizeMask(dimension-1, point, neighborhood);
    }
}

template <typename D, typename LAB>
template <DGtal::Order order, DGtal::Duality duality>
DGtal::LinearOperator<DGtal::DiscreteExteriorCalculus<D, LAB>, order, duality, order, duality>
DGtal::DiscreteExteriorCalculus<D, LAB>::identity() const
{

    typedef LinearOperator<DiscreteExteriorCalculus<D, LAB>, order, duality, order, duality> Operator;
    Operator id(*this);
    id.myContainer.setIdentity();
    return id;
}

template <typename D, typename LAB>
DGtal::LinearOperator<DGtal::DiscreteExteriorCalculus<D, LAB>, 0, DGtal::PRIMAL, 0, DGtal::PRIMAL>
DGtal::DiscreteExteriorCalculus<D, LAB>::primalLaplace() const
{
    const PrimalDerivative0 d0 = derivative<0, PRIMAL>();
    const LinearOperator<DiscreteExteriorCalculus<D, LAB>, dimension-1, DUAL, dimension, DUAL> d1p = derivative<dimension-1, DUAL>();
    const PrimalHodge1 h1 = primalHodge<1>();
    const LinearOperator<DiscreteExteriorCalculus<D, LAB>, dimension, DUAL, 0, PRIMAL> h2p = dualHodge<dimension>();
    return h2p * d1p * h1 * d0;
}

template <typename D, typename LAB>
DGtal::LinearOperator<DGtal::DiscreteExteriorCalculus<D, LAB>, 0, DGtal::DUAL, 0, DGtal::DUAL>
DGtal::DiscreteExteriorCalculus<D, LAB>::dualLaplace() const
{
    const DualDerivative0 d0 = derivative<0, DUAL>();
    const LinearOperator<DiscreteExteriorCalculus<D, LAB>, dimension-1, PRIMAL, dimension, PRIMAL> d1p = derivative<dimension-1, PRIMAL>();
    const DualHodge1 h1 = dualHodge<1>();
    const LinearOperator<DiscreteExteriorCalculus<D, LAB>, dimension, PRIMAL, 0, DUAL> h2p = primalHodge<dimension>();
    return h2p * d1p * h1 * d0;
}

template <typename D, typename LAB>
template <DGtal::Order order, DGtal::Duality duality>
DGtal::LinearOperator<DGtal::DiscreteExteriorCalculus<D, LAB>, order, duality, order+1, duality>
DGtal::DiscreteExteriorCalculus<D, LAB>::derivative() const
{
    BOOST_STATIC_ASSERT(( order >= 0 ));
    BOOST_STATIC_ASSERT(( order < dimension ));

    typedef LinearOperator<DiscreteExteriorCalculus<D, LAB>, order, duality, order+1, duality> Derivative;
    Derivative _derivative(*this);
    ASSERT( _derivative.myContainer.rows() == kFormLength(order+1, duality) );
    ASSERT( _derivative.myContainer.cols() == kFormLength(order, duality) );

    // iterate over output form values
    for (Index index_output=0; index_output<_derivative.myContainer.rows(); index_output++)
    {
        const SCell& cell = index_cells[actualOrder(order+1, duality)][index_output];
        ASSERT( myKSpace.sSign(cell) == KSpace::POS );
        ASSERT( cell.myPositive == true );

        // find hodge sign
        Scalar sign = 1;
        if (duality == DUAL) sign = hodgeSign(absoluteSCell(cell), PRIMAL);

        // find cell border
        typedef typename KSpace::SCells Border;
        Border border;
        if (duality == PRIMAL) border = myKSpace.sLowerIncident(cell);
        else border = myKSpace.sUpperIncident(cell);

        // iterate over cell border
        for (typename Border::const_iterator bi=border.begin(), bie=border.end(); bi!=bie; bi++)
        {
            const SCell& cell_border = *bi;
            ASSERT( myKSpace.sDim(cell_border) == actualOrder(order, duality) );

            const typename Properties::const_iterator iter_property = cell_properties.find(absoluteSCell(cell_border));
            if ( iter_property == cell_properties.end() )
                continue;

            const Index index_input = iter_property->second.index;
            ASSERT( index_input < _derivative.myContainer.cols() );

            Scalar proper_sign = sign * (cell_border.myPositive ? -1 : 1);
            if (duality == DUAL) proper_sign *= hodgeSign(absoluteSCell(cell_border), PRIMAL);

            // fill container with cell sign
            _derivative.myContainer(index_output, index_input) = proper_sign;
        }
    }

    if (duality == DUAL && order == 1) _derivative.myContainer *= -1; // FIXME fix dual derivative for dual 1-form to dual 2-form sign
    return _derivative;
}

template <typename D, typename LAB>
template <DGtal::Order order>
DGtal::LinearOperator<DGtal::DiscreteExteriorCalculus<D, LAB>, order, DGtal::PRIMAL, DGtal::DiscreteExteriorCalculus<D, LAB>::dimension-order, DGtal::DUAL>
DGtal::DiscreteExteriorCalculus<D, LAB>::primalHodge() const
{
    BOOST_STATIC_ASSERT(( order >= 0 ));
    BOOST_STATIC_ASSERT(( order <= dimension ));

    typedef LinearOperator<DiscreteExteriorCalculus<D, LAB>, order, PRIMAL, dimension-order, DUAL> PrimalHodge;
    PrimalHodge primal_hodge(*this);
    ASSERT( primal_hodge.myContainer.rows() == primal_hodge.myContainer.cols() );
    ASSERT( primal_hodge.myContainer.rows() == kFormLength(order, PRIMAL) );

    // iterate over output form values
    for (Index index=0; index<primal_hodge.myContainer.rows(); index++)
    {
        const SCell& cell = index_cells[order][index];
        const typename Properties::const_iterator iter_property = cell_properties.find(cell);
        ASSERT(iter_property != cell_properties.end());

        primal_hodge.myContainer(index, index) = hodgeSign(cell, PRIMAL)*iter_property->second.size_ratio;
    }

    return primal_hodge;
}

template <typename D, typename LAB>
template <DGtal::Order order>
DGtal::LinearOperator<DGtal::DiscreteExteriorCalculus<D, LAB>, order, DGtal::DUAL, DGtal::DiscreteExteriorCalculus<D, LAB>::dimension-order, DGtal::PRIMAL>
DGtal::DiscreteExteriorCalculus<D, LAB>::dualHodge() const
{
    BOOST_STATIC_ASSERT(( order >= 0 ));
    BOOST_STATIC_ASSERT(( order <= dimension ));

    typedef LinearOperator<DiscreteExteriorCalculus<D, LAB>, order, DUAL, DiscreteExteriorCalculus<D, LAB>::dimension-order, PRIMAL> DualHodge;
    DualHodge dual_hodge(*this);
    ASSERT( dual_hodge.myContainer.rows() == dual_hodge.myContainer.cols() );
    ASSERT( dual_hodge.myContainer.rows() == kFormLength(order, DUAL) );

    // iterate over output form values
    for (Index index=0; index<dual_hodge.myContainer.rows(); index++)
    {
        const SCell& cell = index_cells[dimension-order][index];
        const typename Properties::const_iterator iter_property = cell_properties.find(cell);
        ASSERT(iter_property != cell_properties.end());

        dual_hodge.myContainer(index, index) = hodgeSign(cell, DUAL)/iter_property->second.size_ratio;
    }

    return dual_hodge;
}

template <typename D, typename LAB>
template <DGtal::Duality duality>
DGtal::VectorField<DGtal::DiscreteExteriorCalculus<D, LAB>, duality>
DGtal::DiscreteExteriorCalculus<D, LAB>::sharp(const DGtal::KForm<DGtal::DiscreteExteriorCalculus<D, LAB>, 1, duality>& one_form) const
{
    typedef VectorField<DiscreteExteriorCalculus, duality> Field;
    Field field(*this);

    ASSERT( field.myCoordinates.size() == dimension);
    for (DGtal::Dimension dim=0; dim<dimension; dim++)
        ASSERT( field.myCoordinates[dim].rows() == kFormLength(0, duality) );

    // iterate over points
    for (int kk=0; kk<kFormLength(0, duality); kk++)
    {
        const SCell& cell = index_cells[actualOrder(0, duality)][kk];
        ASSERT( myKSpace.sSign(cell) == KSpace::POS );
        ASSERT( cell.myPositive == true );

        typedef typename KSpace::SCells Edges;
        Edges edges;
        if (duality == PRIMAL) edges = myKSpace.sUpperIncident(cell);
        else edges = myKSpace.sLowerIncident(cell);

        // collect 1-form values over neighboring edges
        typedef boost::array<Scalar, dimension> Normalize;
        Normalize normalize;
        normalize.assign(0);
        for (typename Edges::const_iterator ei=edges.begin(), eie=edges.end(); ei!=eie; ei++)
        {
            const SCell& cell_border = absoluteSCell(*ei);
            ASSERT( myKSpace.sDim(cell_border) == actualOrder(1, duality) );
            ASSERT( myKSpace.sSign(cell_border) == KSpace::POS );

            const typename Properties::const_iterator iter_property = cell_properties.find(cell_border);
            if (iter_property == cell_properties.end())
                continue;

            const Index& cell_border_index = iter_property->second.index;
            ASSERT( cell_border_index < index_cells[actualOrder(1, duality)].size());
            ASSERT( cell_border_index < one_form.myContainer.rows() );

            const DGtal::Dimension direction = edgeDirection(cell_border, duality);

            normalize[direction]++;
            field.myCoordinates[direction](kk) += one_form.myContainer(cell_border_index);
        }

        // normalize vector field
        for (DGtal::Dimension dim=0; dim<dimension; dim++)
            if (normalize[dim])
                field.myCoordinates[dim](kk) /= normalize[dim];
    }

    return field;
}

template <typename D, typename LAB>
template <DGtal::Duality duality>
DGtal::KForm<DGtal::DiscreteExteriorCalculus<D, LAB>, 1, duality>
DGtal::DiscreteExteriorCalculus<D, LAB>::flat(const DGtal::VectorField<DGtal::DiscreteExteriorCalculus<D, LAB>, duality>& vector_field) const
{
    typedef KForm<DiscreteExteriorCalculus, 1, duality> OneForm;
    OneForm one_form(*this);

    // iterate over edges
    for (int kk=0; kk<kFormLength(1, duality); kk++)
    {
        const SCell& cell = index_cells[actualOrder(1, duality)][kk];
        ASSERT( myKSpace.sSign(cell) == KSpace::POS );
        ASSERT( cell.myPositive == true );

        const DGtal::Dimension& direction = edgeDirection(cell, duality);

        typedef typename KSpace::SCells Points;
        Points points;
        if (duality == PRIMAL) points = myKSpace.sLowerIncident(cell);
        else points = myKSpace.sUpperIncident(cell);

        // project vector field along edge from neighboring points
        ASSERT( points.size() == 2 );
        Scalar normalize = 0;
        for (typename Points::const_iterator pi=points.begin(), pie=points.end(); pi!=pie; pi++)
        {
            const SCell cell_border = absoluteSCell(*pi);
            ASSERT( myKSpace.sDim(cell_border) == actualOrder(0, duality) );
            ASSERT( myKSpace.sSign(cell_border) == KSpace::POS );

            const typename Properties::const_iterator iter_property = cell_properties.find(cell_border);
            if (iter_property == cell_properties.end())
                continue;

            const Index& cell_border_index = iter_property->second.index;
            ASSERT( cell_border_index < index_cells[actualOrder(0, duality)].size());
            ASSERT( cell_border_index < kFormLength(0, duality) );

            normalize++;
            one_form.myContainer(kk) += vector_field.myCoordinates[direction](cell_border_index);
        }

        // normalize one-form
        if (normalize)
            one_form.myContainer(kk) /= normalize;
    }

    return one_form;
}

template <typename D, typename LAB>
typename DGtal::DiscreteExteriorCalculus<D, LAB>::Properties
DGtal::DiscreteExteriorCalculus<D, LAB>::getProperties() const
{
    return cell_properties;
}

template <typename D, typename LAB>
typename DGtal::DiscreteExteriorCalculus<D, LAB>::SCell
DGtal::DiscreteExteriorCalculus<D, LAB>::getSCell(const Order& order, const Duality& duality, const Index& index) const
{
    const Order& actual_order = actualOrder(order, duality);
    const SCell& cell = index_cells[actual_order][index];
    ASSERT( myKSpace.sDim(cell) == actual_order );
    return cell;
}

template <typename D, typename LAB>
bool
DGtal::DiscreteExteriorCalculus<D, LAB>::isSCellFlipped(const SCell& cell) const
{
    const typename Properties::const_iterator iter_property = cell_properties.find(absoluteSCell(cell));
    ASSERT( iter_property != cell_properties.end() );
    return iter_property->second.display_flipped;
}

template <typename D, typename LAB>
typename DGtal::DiscreteExteriorCalculus<D, LAB>::Index
DGtal::DiscreteExteriorCalculus<D, LAB>::getSCellIndex(const SCell& cell) const
{
    const typename Properties::const_iterator iter_property = cell_properties.find(absoluteSCell(cell));
    ASSERT( iter_property != cell_properties.end() );
    return iter_property->second.index;
}

template <typename D, typename LAB>
typename DGtal::DiscreteExteriorCalculus<D, LAB>::ConstIterator
DGtal::DiscreteExteriorCalculus<D, LAB>::begin() const
{
    return cell_properties.begin();
}

template <typename D, typename LAB>
typename DGtal::DiscreteExteriorCalculus<D, LAB>::ConstIterator
DGtal::DiscreteExteriorCalculus<D, LAB>::end() const
{
    return cell_properties.end();
}

template <typename D, typename LAB>
typename DGtal::DiscreteExteriorCalculus<D, LAB>::Index
DGtal::DiscreteExteriorCalculus<D, LAB>::kFormLength(const DGtal::Order& order, const DGtal::Duality& duality) const
{
    return index_cells[actualOrder(order, duality)].size();
}

template <typename D, typename LAB>
DGtal::Order
DGtal::DiscreteExteriorCalculus<D, LAB>::actualOrder(const DGtal::Order& order, const DGtal::Duality& duality) const
{
    return (duality == PRIMAL) ? order : dimension-order;
}

template <typename D, typename LAB>
typename DGtal::DiscreteExteriorCalculus<D, LAB>::Scalar
DGtal::DiscreteExteriorCalculus<D, LAB>::hodgeSign(const SCell& cell, const DGtal::Duality& duality) const
{
    const DGtal::Dimension& primal_dim = myKSpace.sDim(cell);
    const bool apply_sign = ((dimension-primal_dim)*primal_dim % 2 == 1);
    if (!apply_sign) return cell.myPositive ? 1 : -1;

    typename KSpace::DirIterator di = myKSpace.sDirs(cell);

    DGtal::Dimension span_count = 0;
    DGtal::Dimension iter_count = 0;
    while (di!=0)
    {
        span_count += *di;
        iter_count ++;
        ++di;
    }
    ASSERT( iter_count == primal_dim );
    if (duality == DUAL) span_count++;

    const Scalar sign = pow(-1, span_count);
    return cell.myPositive ? sign : -sign;
}

template <typename D, typename LAB>
typename DGtal::DiscreteExteriorCalculus<D, LAB>::SCell
DGtal::DiscreteExteriorCalculus<D, LAB>::absoluteSCell(const SCell& cell) const
{
    if (cell.myPositive) return cell;
    return myKSpace.sOpp(cell);
}

template <typename D, typename LAB>
typename DGtal::Dimension
DGtal::DiscreteExteriorCalculus<D, LAB>::edgeDirection(const SCell& cell, const DGtal::Duality& duality) const
{
    ASSERT( myKSpace.sDim(cell) == actualOrder(1, duality) );

    typename KSpace::DirIterator di = myKSpace.sDirs(cell);
    if (duality == DUAL) di = myKSpace.sOrthDirs(cell);

    ASSERT( di != 0 );
    const DGtal::Dimension direction = *di;
    ++di;
    ASSERT( !(di != 0) );
    ASSERT( direction < dimension );

    return direction;
}

template <typename D, typename LAB>
bool
DGtal::DiscreteExteriorCalculus<D, LAB>::isValid() const
{
    return true;
}

///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions                                        //

template <typename D, typename LAB>
std::ostream&
DGtal::operator<<(std::ostream & out, const DiscreteExteriorCalculus<D, LAB>& object)
{
  object.selfDisplay(out);
  return out;
}

//                                                                           //
///////////////////////////////////////////////////////////////////////////////
