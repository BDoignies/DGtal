/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file DiscreteExteriorCalculus.ih
 * @author Pierre Gueth (\c pierre.gueth@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Systemes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 *
 * @date 2014/03/27
 *
 * Implementation of inline methods defined in DiscreteExteriorCalculus.h
 *
 * This file is part of the DGtal library.
 */

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------

template <DGtal::Dimension dim_embedded, DGtal::Dimension dim_ambient, typename TLinearAlgebraBackend, typename TInteger>
template <typename TDigitalSet>
DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>::DiscreteExteriorCalculus(const TDigitalSet& _set, const bool& add_border)
    : myKSpace(), myCachedOperatorsModified(true)
{
    BOOST_CONCEPT_ASSERT(( concepts::CDigitalSet<TDigitalSet> ));

    BOOST_STATIC_ASSERT(( dim_embedded == dim_ambient ));

    initKSpace(_set.domain());

    // compute raw cell size
    typedef std::map<Cell, Scalar> Accum;
    Accum cell_size_accum;
    for (typename TDigitalSet::ConstIterator ri=_set.begin(), rie=_set.end(); ri!=rie; ri++)
    {
        const Point& point = *ri;
        const Cell cell_point = myKSpace.uSpel(point);

        typedef DGtal::SpaceND<dim_ambient, TInteger> Space;
        typedef DGtal::HyperRectDomain<Space> Neighborbood;
        const Point cell_coords = myKSpace.uKCoords(cell_point);
        const Neighborbood neighborhood(cell_coords-Point::diagonal(1), cell_coords+Point::diagonal(1));
        for (typename Neighborbood::ConstIterator pi=neighborhood.begin(), pie=neighborhood.end(); pi!=pie; pi++)
        {
            const Cell cell = myKSpace.uCell(*pi);
            if (cell_size_accum.find(cell) == cell_size_accum.end()) cell_size_accum[cell] = 0;
            cell_size_accum[cell] += 1;
        }
    }

    // normalize cell size and set flipped flag
    for (typename Accum::const_iterator csi=cell_size_accum.begin(), csie=cell_size_accum.end(); csie!=csi; csi++)
    {
        const Cell& cell = csi->first;
        const DGtal::Dimension dual_dim = dim_ambient-myKSpace.uDim(cell);
        const Scalar factor = 1/pow(2, dual_dim);

        const Scalar normalized_size = csi->second * factor;
        ASSERT(normalized_size > 0 && normalized_size <= 1);

        if (!add_border && normalized_size < 1) continue;

        Property property;
        property.flipped = false;
        property.size_ratio = normalized_size;

        myCellProperties[cell] = property;
    }

    // compute cell index
    for (typename Properties::iterator csi=myCellProperties.begin(), csie=myCellProperties.end(); csie!=csi; csi++)
    {
        const Cell& cell = csi->first;
        const DGtal::Dimension cell_dim = myKSpace.uDim(cell);

        csi->second.index = myIndexSignedCells[cell_dim].size();

        const SCell& signed_cell = myKSpace.signs(cell, KSpace::POS);
        myIndexSignedCells[cell_dim].push_back(signed_cell);
    }
}

template <DGtal::Dimension dim_embedded, DGtal::Dimension dim_ambient, typename TLinearAlgebraBackend, typename TInteger>
DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>::DiscreteExteriorCalculus()
    : myKSpace(), myCachedOperatorsModified(true)
{
}

template <DGtal::Dimension dim_embedded, DGtal::Dimension dim_ambient, typename TLinearAlgebraBackend, typename TInteger>
template <typename TDomain>
void
DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>::initKSpace(const TDomain& _domain)
{
    BOOST_CONCEPT_ASSERT(( concepts::CDomain<TDomain> ));

    // FIXME borders are removed from set => better not initialize kspace
    // FIXME should be open or closed? => closed = true
    const bool kspace_init_ok = const_cast<KSpace&>(myKSpace).init(_domain.lowerBound(), _domain.upperBound(), true);
    ASSERT(kspace_init_ok);
}

///////////////////////////////////////////////////////////////////////////////
// Interface - public :

template <DGtal::Dimension dim_embedded, DGtal::Dimension dim_ambient, typename TLinearAlgebraBackend, typename TInteger>
bool
DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>::eraseCell(const Cell& _cell)
{
    typename Properties::iterator iter_property = myCellProperties.find(_cell);
    if (iter_property == myCellProperties.end())
        return false;

    const DGtal::Dimension cell_dim = myKSpace.uDim(_cell);
    const Index index = iter_property->second.index;
    myCellProperties.erase(iter_property);

    typename SCells::iterator iter_index = myIndexSignedCells[cell_dim].begin() + index;
    ASSERT( myKSpace.unsigns(*iter_index) == _cell );
    iter_index = myIndexSignedCells[cell_dim].erase(iter_index);

    for (typename SCells::const_iterator iter_index_end = myIndexSignedCells[cell_dim].end(); iter_index!= iter_index_end; iter_index++)
    {
        const SCell signed_cell_next = *iter_index;
        const Cell cell_next = myKSpace.unsigns(signed_cell_next);
        typename Properties::iterator iter_property_next = myCellProperties.find(cell_next);
        ASSERT( iter_property_next != myCellProperties.end() );
        ASSERT( iter_property_next->second.index > index );
        iter_property_next->second.index -= 1;
    }

    myCachedOperatorsModified = true;

    return true;
}

template <DGtal::Dimension dim_embedded, DGtal::Dimension dim_ambient, typename TLinearAlgebraBackend, typename TInteger>
bool
DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>::insertSCell(const SCell& _signed_cell, const Scalar& _primal_size)
{
    const Cell cell = myKSpace.unsigns(_signed_cell);
    const DGtal::Dimension cell_dim = myKSpace.uDim(cell);
    Property property;
    property.size_ratio = _primal_size;
    property.flipped = ( myKSpace.sSign(_signed_cell) == KSpace::NEG );

    ASSERT_MSG( cell_dim >= 0 && cell_dim <= dim_embedded, "wrong cell dimension");
    ASSERT_MSG( cell_dim != 0 || !property.flipped , "can't insert negative 0-cells" );
    ASSERT_MSG( cell_dim != dim_ambient || !property.flipped , "can't insert negative n-cells" );

    typename Properties::iterator iter = myCellProperties.find(cell);
    const bool need_insert = (iter == myCellProperties.end());

    if (need_insert) // new cell new index computation
    {
        property.index = myIndexSignedCells[cell_dim].size();
        myIndexSignedCells[cell_dim].push_back(_signed_cell);
        myCellProperties[cell] = property;
        iter = myCellProperties.find(cell);
    }
    else
    {
        property.index = iter->second.index;
        myIndexSignedCells[cell_dim][property.index] = _signed_cell;
    }

    ASSERT( property.index == iter->second.index );

    iter->second = property;

    if (need_insert) myCachedOperatorsModified = true;

    return need_insert;
}

template <DGtal::Dimension dim_embedded, DGtal::Dimension dim_ambient, typename TLinearAlgebraBackend, typename TInteger>
std::string
DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>::className() const
{
    return "Calculus";
}

template <DGtal::Dimension dim_embedded, DGtal::Dimension dim_ambient, typename TLinearAlgebraBackend, typename TInteger>
void
DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>::selfDisplay(std::ostream & os) const
{
    os << "[dec";
    for (DGtal::Order order=0; order<=dim_embedded; order++)
        os << " | primal " << order << "-cells <-> dual " << dim_embedded-order << "-cells (" << kFormLength(order, PRIMAL) << ")";
    os << "]";
}

template <DGtal::Dimension dim_embedded, DGtal::Dimension dim_ambient, typename TLinearAlgebraBackend, typename TInteger>
template <DGtal::Order order, DGtal::Duality duality>
DGtal::LinearOperator<DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>, order, duality, order, duality>
DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>::identity() const
{
    typedef LinearOperator<Self, order, duality, order, duality> Operator;
    Operator id(*this);
    id.myContainer.setIdentity();
    return id;
}

template <DGtal::Dimension dim_embedded, DGtal::Dimension dim_ambient, typename TLinearAlgebraBackend, typename TInteger>
DGtal::LinearOperator<DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>, 0, DGtal::PRIMAL, 0, DGtal::PRIMAL>
DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>::primalLaplace() const
{
    const PrimalDerivative0 d0 = derivative<0, PRIMAL>();
    const LinearOperator<Self, dim_embedded-1, DUAL, dim_embedded, DUAL> d1p = derivative<dim_embedded-1, DUAL>();
    const PrimalHodge1 h1 = primalHodge<1>();
    const LinearOperator<Self, dim_embedded, DUAL, 0, PRIMAL> h2p = dualHodge<dim_embedded>();
    const Scalar sign = ( dim_ambient%2 == 0 ? -1 : 1 );
    return sign * h2p * d1p * h1 * d0;
}

template <DGtal::Dimension dim_embedded, DGtal::Dimension dim_ambient, typename TLinearAlgebraBackend, typename TInteger>
DGtal::LinearOperator<DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>, 0, DGtal::DUAL, 0, DGtal::DUAL>
DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>::dualLaplace() const
{
    const DualDerivative0 d0 = derivative<0, DUAL>();
    const LinearOperator<Self, dim_embedded-1, PRIMAL, dim_embedded, PRIMAL> d1p = derivative<dim_embedded-1, PRIMAL>();
    const DualHodge1 h1 = dualHodge<1>();
    const LinearOperator<Self, dim_embedded, PRIMAL, 0, DUAL> h2p = primalHodge<dim_embedded>();
    const Scalar sign = ( dim_ambient%2 == 0 ? -1 : 1 );
    return sign * h2p * d1p * h1 * d0;
}

template <DGtal::Dimension dim_embedded, DGtal::Dimension dim_ambient, typename TLinearAlgebraBackend, typename TInteger>
template <DGtal::Duality duality>
DGtal::LinearOperator<DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>, 0, duality, 0, duality>
DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>::laplace() const
{
    typedef DGtal::LinearOperator<Self, 0, duality, 1, duality> Derivative;
    typedef DGtal::LinearOperator<Self, 1, duality, 0, duality> Antiderivative;
    const Derivative d = derivative<0, duality>();
    const Antiderivative ad = antiderivative<1, duality>();
    return ad * d;
}

template <DGtal::Dimension dim_embedded, DGtal::Dimension dim_ambient, typename TLinearAlgebraBackend, typename TInteger>
template <DGtal::Order order, DGtal::Duality duality>
DGtal::LinearOperator<DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>, order, duality, order-1, duality>
DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>::antiderivative() const
{
    BOOST_STATIC_ASSERT(( order > 0 ));
    BOOST_STATIC_ASSERT(( order <= dim_embedded ));

    typedef DGtal::LinearOperator<Self, order, duality, dim_embedded-order, OppositeDuality<duality>::duality> FirstHodge;
    typedef DGtal::LinearOperator<Self, dim_embedded-order, OppositeDuality<duality>::duality, dim_embedded-order+1, OppositeDuality<duality>::duality> Derivative;
    typedef DGtal::LinearOperator<Self, dim_embedded-order+1, OppositeDuality<duality>::duality, order-1, duality> SecondHodge;
    const FirstHodge h_first = hodge<order, duality>();
    const Derivative d = derivative<dim_embedded-order, OppositeDuality<duality>::duality>();
    const SecondHodge h_second = hodge<dim_embedded-order+1, OppositeDuality<duality>::duality>();
    const Scalar sign = ( order*(dim_ambient-order)%2 == 0 ? 1 : -1 );
    return sign * h_second * d * h_first;
}

template <DGtal::Dimension dim_embedded, DGtal::Dimension dim_ambient, typename TLinearAlgebraBackend, typename TInteger>
template <DGtal::Order order, DGtal::Duality duality>
DGtal::LinearOperator<DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>, order, duality, order+1, duality>
DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>::derivative() const
{
    BOOST_STATIC_ASSERT(( order >= 0 ));
    BOOST_STATIC_ASSERT(( order < dim_embedded ));

    typedef LinearOperator<Self, order, duality, order+1, duality> Derivative;
    Derivative _derivative(*this);
    ASSERT( _derivative.myContainer.rows() == kFormLength(order+1, duality) );
    ASSERT( _derivative.myContainer.cols() == kFormLength(order, duality) );

    // iterate over output form values
#if defined(WITH_OPENMP) && defined(NDEBUG)
#pragma omp parallel for default(none) shared(_derivative) schedule(static, 64)
#endif
    for (Index index_output=0; index_output<_derivative.myContainer.rows(); index_output++)
    {
        const SCell signed_cell = myIndexSignedCells[actualOrder(order+1, duality)][index_output];

        // find cell border
        typedef typename KSpace::SCells Border;
        const Border border = ( duality == PRIMAL ? myKSpace.sLowerIncident(signed_cell) : myKSpace.sUpperIncident(signed_cell) );

        // iterate over cell border
        for (typename Border::const_iterator bi=border.begin(), bie=border.end(); bi!=bie; bi++)
        {
            const SCell signed_cell_border = *bi;
            ASSERT( myKSpace.sDim(signed_cell_border) == actualOrder(order, duality) );

            const typename Properties::const_iterator iter_property = myCellProperties.find(myKSpace.unsigns(signed_cell_border));
            if ( iter_property == myCellProperties.end() )
                continue;

            const Index index_input = iter_property->second.index;
            ASSERT( index_input < _derivative.myContainer.cols() );

            const bool flipped_border = ( myKSpace.sSign(signed_cell_border) == KSpace::NEG );
            const Scalar orientation = ( flipped_border == iter_property->second.flipped ? 1 : -1 );

#if defined(WITH_OPENMP) && defined(NDEBUG)
#pragma omp critical
#endif
            {
                // fill container with cell sign
                _derivative.myContainer(index_output, index_input) = orientation;
            }
        }
    }

    if (duality == DUAL && (order*(dim_embedded-order))%2 != 0) _derivative.myContainer *= -1;

    return _derivative;
}

template <DGtal::Dimension dim_embedded, DGtal::Dimension dim_ambient, typename TLinearAlgebraBackend, typename TInteger>
template <DGtal::Order order>
DGtal::LinearOperator<DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>, order, DGtal::PRIMAL, dim_embedded-order, DGtal::DUAL>
DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>::primalHodge() const
{
    BOOST_STATIC_ASSERT(( order >= 0 ));
    BOOST_STATIC_ASSERT(( order <= dim_embedded ));

    typedef LinearOperator<Self, order, PRIMAL, dim_embedded-order, DUAL> PrimalHodge;
    PrimalHodge primal_hodge(*this);
    ASSERT( primal_hodge.myContainer.rows() == primal_hodge.myContainer.cols() );
    ASSERT( primal_hodge.myContainer.rows() == kFormLength(order, PRIMAL) );

    // iterate over output form values
    for (Index index=0; index<primal_hodge.myContainer.rows(); index++)
    {
        const Cell cell = myKSpace.unsigns(myIndexSignedCells[order][index]);

        const typename Properties::const_iterator iter_property = myCellProperties.find(cell);
        ASSERT(iter_property != myCellProperties.end());

        primal_hodge.myContainer(index, index) = hodgeSign(cell, PRIMAL)*iter_property->second.size_ratio;
    }

    return primal_hodge;
}

template <DGtal::Dimension dim_embedded, DGtal::Dimension dim_ambient, typename TLinearAlgebraBackend, typename TInteger>
template <DGtal::Order order>
DGtal::LinearOperator<DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>, order, DGtal::DUAL, dim_embedded-order, DGtal::PRIMAL>
DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>::dualHodge() const
{
    BOOST_STATIC_ASSERT(( order >= 0 ));
    BOOST_STATIC_ASSERT(( order <= dim_embedded ));

    typedef LinearOperator<Self, order, DUAL, dim_embedded-order, PRIMAL> DualHodge;
    DualHodge dual_hodge(*this);
    ASSERT( dual_hodge.myContainer.rows() == dual_hodge.myContainer.cols() );
    ASSERT( dual_hodge.myContainer.rows() == kFormLength(order, DUAL) );

    // iterate over output form values
    for (Index index=0; index<dual_hodge.myContainer.rows(); index++)
    {
        const Cell cell = myKSpace.unsigns(myIndexSignedCells[dim_embedded-order][index]);

        const typename Properties::const_iterator iter_property = myCellProperties.find(cell);
        ASSERT(iter_property != myCellProperties.end());

        dual_hodge.myContainer(index, index) = hodgeSign(cell, DUAL)/iter_property->second.size_ratio;
    }

    return dual_hodge;
}

template <DGtal::Dimension dim_embedded, DGtal::Dimension dim_ambient, typename TLinearAlgebraBackend, typename TInteger>
template <DGtal::Order order, DGtal::Duality duality>
DGtal::LinearOperator<DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>, order, duality, dim_embedded-order, DGtal::OppositeDuality<duality>::duality>
DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>::hodge() const
{
    BOOST_STATIC_ASSERT(( order >= 0 ));
    BOOST_STATIC_ASSERT(( order <= dim_embedded ));

    typedef LinearOperator<Self, order, duality, dim_embedded-order, OppositeDuality<duality>::duality> Hodge;
    Hodge hodge(*this);
    ASSERT( hodge.myContainer.rows() == hodge.myContainer.cols() );
    ASSERT( hodge.myContainer.rows() == kFormLength(order, duality) );

    // iterate over output form values
    for (Index index=0; index<hodge.myContainer.rows(); index++)
    {
        const Cell cell = myKSpace.unsigns(myIndexSignedCells[actualOrder(order, duality)][index]);

        const typename Properties::const_iterator iter_property = myCellProperties.find(cell);
        ASSERT(iter_property != myCellProperties.end());

        const Scalar size_ratio = ( duality == DGtal::PRIMAL ? iter_property->second.size_ratio : 1/iter_property->second.size_ratio );
        hodge.myContainer(index, index) = hodgeSign(cell, duality) * size_ratio;
    }

    return hodge;
}

template <DGtal::Dimension dim_embedded, DGtal::Dimension dim_ambient, typename TLinearAlgebraBackend, typename TInteger>
template <DGtal::Duality duality>
DGtal::VectorField<DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>, duality>
DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>::sharp(const DGtal::KForm<Self, 1, duality>& one_form) const
{
    const_cast<Self*>(this)->updateCachedOperators();

    const boost::array<SparseMatrix, dim_ambient>& sharp_operator_matrix = mySharpOperatorMatrixes[static_cast<int>(duality)];

    typedef VectorField<Self, duality> Field;
    Field field(*this);
    ASSERT( field.myCoordinates.cols() == dim_ambient);
    ASSERT( field.myCoordinates.rows() == kFormLength(0, duality));
    for (DGtal::Dimension direction=0; direction<dim_ambient; direction++)
        field.myCoordinates.col(direction) = sharp_operator_matrix[direction]*one_form.myContainer;

    return field;
}

template <DGtal::Dimension dim_embedded, DGtal::Dimension dim_ambient, typename TLinearAlgebraBackend, typename TInteger>
template <DGtal::Duality duality, DGtal::Dimension direction>
DGtal::LinearOperator<DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>, 1, duality, 0, duality>
DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>::sharpDirectional() const
{
    const_cast<Self*>(this)->updateCachedOperators();

    ASSERT( direction < dim_ambient );

    typedef LinearOperator<Self, 1, duality, 0, duality> Operator;
    return Operator(*this, mySharpOperatorMatrixes[static_cast<int>(duality)][direction]);
}

template <DGtal::Dimension dim_embedded, DGtal::Dimension dim_ambient, typename TLinearAlgebraBackend, typename TInteger>
template <DGtal::Duality duality>
void
DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>::updateSharpOperator()
{
    boost::array<SparseMatrix, dim_ambient> sharp_operator_matrix;

    for (DGtal::Dimension direction=0; direction<dim_ambient; direction++)
        sharp_operator_matrix[direction] = SparseMatrix(kFormLength(0, duality), kFormLength(1, duality));

    // iterate over points
    for (Index kk=0; kk<kFormLength(0, duality); kk++)
    {
        const SCell signed_cell = myIndexSignedCells[actualOrder(0, duality)][kk];
        ASSERT( myKSpace.sDim(signed_cell) == actualOrder(0, duality) );
        ASSERT( myKSpace.sSign(signed_cell) == KSpace::POS );
        const Cell cell = myKSpace.unsigns(signed_cell);

        typedef typename KSpace::Cells Edges;
        const Edges edges = ( duality == PRIMAL ? myKSpace.uUpperIncident(cell) : myKSpace.uLowerIncident(cell) );

        // collect 1-form values over neighboring edges
        typedef boost::array< std::list< std::pair<Index, Scalar> >, dim_ambient > BorderIndexes;
        BorderIndexes border_indexes;
        for (typename Edges::const_iterator ei=edges.begin(), eie=edges.end(); ei!=eie; ei++)
        {
            const Cell cell_border = *ei;
            ASSERT( myKSpace.uDim(cell_border) == actualOrder(1, duality) );

            const typename Properties::const_iterator iter_property = myCellProperties.find(cell_border);
            if (iter_property == myCellProperties.end())
                continue;

            const Index& cell_border_index = iter_property->second.index;
            ASSERT( cell_border_index < static_cast<Index>(myIndexSignedCells[actualOrder(1, duality)].size()) );

            const Scalar orientation = ( iter_property->second.flipped ? 1 : -1 );
            const DGtal::Dimension direction = edgeDirection(cell_border, duality);

            border_indexes[direction].push_back(std::make_pair(cell_border_index, orientation));
        }

        for (DGtal::Dimension direction=0; direction<dim_ambient; direction++)
            for (typename std::list< std::pair<Index, Scalar> >::const_iterator bi=border_indexes[direction].begin(), bie=border_indexes[direction].end(); bi!=bie; bi++)
            {
                const Index cell_border_index = bi->first;
                const Scalar cell_border_orientation = bi->second;
                ASSERT( cell_border_index < static_cast<Index>(myIndexSignedCells[actualOrder(1, duality)].size()) );
                ASSERT( cell_border_index < kFormLength(1, duality) );

                const Scalar sign = ( duality == DUAL && (direction*(dim_ambient-direction))%2 == 0 ? -1 : 1 );
                sharp_operator_matrix[direction](kk, cell_border_index) = sign * cell_border_orientation/border_indexes[direction].size();
            }
    }

    mySharpOperatorMatrixes[static_cast<int>(duality)] = sharp_operator_matrix;
}

template <DGtal::Dimension dim_embedded, DGtal::Dimension dim_ambient, typename TLinearAlgebraBackend, typename TInteger>
template <DGtal::Duality duality>
DGtal::KForm<DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>, 1, duality>
DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>::flat(const DGtal::VectorField<Self, duality>& vector_field) const
{
    const_cast<Self*>(this)->updateCachedOperators();

    const boost::array<SparseMatrix, dim_ambient>& flat_operator_matrix = myFlatOperatorMatrixes[static_cast<int>(duality)];

    typedef KForm<Self, 1, duality> OneForm;
    OneForm one_form(*this);
    for (DGtal::Dimension direction=0; direction<dim_ambient; direction++)
        one_form.myContainer += flat_operator_matrix[direction]*vector_field.myCoordinates.col(direction);

    return one_form;
}

template <DGtal::Dimension dim_embedded, DGtal::Dimension dim_ambient, typename TLinearAlgebraBackend, typename TInteger>
template <DGtal::Duality duality, DGtal::Dimension direction>
DGtal::LinearOperator<DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>, 0, duality, 1, duality>
DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>::flatDirectional() const
{
    const_cast<Self*>(this)->updateCachedOperators();

    ASSERT( direction < dim_ambient );

    typedef LinearOperator<Self, 0, duality, 1, duality> Operator;
    return Operator(*this, myFlatOperatorMatrixes[static_cast<int>(duality)][direction]);
}


template <DGtal::Dimension dim_embedded, DGtal::Dimension dim_ambient, typename TLinearAlgebraBackend, typename TInteger>
template <DGtal::Duality duality>
void
DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>::updateFlatOperator()
{
    boost::array<SparseMatrix, dim_ambient> flat_operator_matrix;

    for (DGtal::Dimension direction=0; direction<dim_ambient; direction++)
        flat_operator_matrix[direction] = SparseMatrix(kFormLength(1, duality), kFormLength(0, duality));

    // iterate over edges
    for (Index kk=0; kk<kFormLength(1, duality); kk++)
    {
        const SCell signed_cell = myIndexSignedCells[actualOrder(1, duality)][kk];
        ASSERT( myKSpace.sDim(signed_cell) == actualOrder(1, duality) );
        const Cell cell = myKSpace.unsigns(signed_cell);

        const Scalar orientation = ( myKSpace.sSign(signed_cell) == KSpace::NEG ? 1 : -1 );
        const DGtal::Dimension& direction = edgeDirection(cell, duality);
        const Scalar sign = ( duality == DUAL && (direction*(dim_ambient-direction))%2 == 0 ? -1 : 1 );

        typedef typename KSpace::Cells Points;
        const Points points = ( duality == PRIMAL ? myKSpace.uLowerIncident(cell) : myKSpace.uUpperIncident(cell) );

        // project vector field along edge from neighboring points
        typedef std::list<Index> BorderIndexes;
        BorderIndexes border_indexes;
        for (typename Points::const_iterator pi=points.begin(), pie=points.end(); pi!=pie; pi++)
        {
            const Cell cell_border = *pi;
            ASSERT( myKSpace.uDim(cell_border) == actualOrder(0, duality) );

            const typename Properties::const_iterator iter_property = myCellProperties.find(cell_border);
            if (iter_property == myCellProperties.end())
                continue;

            const Index& cell_border_index = iter_property->second.index;
            ASSERT( cell_border_index < static_cast<Index>(myIndexSignedCells[actualOrder(0, duality)].size()) );
            ASSERT( iter_property->second.flipped == false );

            border_indexes.push_back(cell_border_index);
        }

        for (typename BorderIndexes::const_iterator bi=border_indexes.begin(), bie=border_indexes.end(); bi!=bie; bi++)
        {
            const Index& cell_border_index = *bi;
            ASSERT( cell_border_index < static_cast<Index>(myIndexSignedCells[actualOrder(0, duality)].size()) );
            ASSERT( cell_border_index < kFormLength(0, duality) );

            flat_operator_matrix[direction](kk, cell_border_index) = sign*orientation/border_indexes.size();
        }

    }

    myFlatOperatorMatrixes[static_cast<int>(duality)] = flat_operator_matrix;
}

template <DGtal::Dimension dim_embedded, DGtal::Dimension dim_ambient, typename TLinearAlgebraBackend, typename TInteger>
void
DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>::updateCachedOperators()
{
    if (!myCachedOperatorsModified) return;
    updateFlatOperator<PRIMAL>();
    updateFlatOperator<DUAL>();
    updateSharpOperator<PRIMAL>();
    updateSharpOperator<DUAL>();
    myCachedOperatorsModified = false;
}

template <DGtal::Dimension dim_embedded, DGtal::Dimension dim_ambient, typename TLinearAlgebraBackend, typename TInteger>
typename DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>::Properties
DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>::getProperties() const
{
    return myCellProperties;
}

template <DGtal::Dimension dim_embedded, DGtal::Dimension dim_ambient, typename TLinearAlgebraBackend, typename TInteger>
typename DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>::SCell
DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>::getSCell(const Order& order, const Duality& duality, const Index& index) const
{
    const Order& actual_order = actualOrder(order, duality);
    const SCell& signed_cell = myIndexSignedCells[actual_order][index];
    ASSERT( myKSpace.sDim(signed_cell) == actual_order );
    return signed_cell;
}

template <DGtal::Dimension dim_embedded, DGtal::Dimension dim_ambient, typename TLinearAlgebraBackend, typename TInteger>
bool
DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>::isCellFlipped(const Cell& cell) const
{
    const typename Properties::const_iterator iter_property = myCellProperties.find(cell);
    ASSERT( iter_property != myCellProperties.end() );
    return iter_property->second.flipped;
}

template <DGtal::Dimension dim_embedded, DGtal::Dimension dim_ambient, typename TLinearAlgebraBackend, typename TInteger>
typename DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>::Index
DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>::getCellIndex(const Cell& cell) const
{
    const typename Properties::const_iterator iter_property = myCellProperties.find(cell);
    ASSERT( iter_property != myCellProperties.end() );
    return iter_property->second.index;
}

template <DGtal::Dimension dim_embedded, DGtal::Dimension dim_ambient, typename TLinearAlgebraBackend, typename TInteger>
typename DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>::ConstIterator
DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>::begin() const
{
    return myCellProperties.begin();
}

template <DGtal::Dimension dim_embedded, DGtal::Dimension dim_ambient, typename TLinearAlgebraBackend, typename TInteger>
typename DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>::ConstIterator
DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>::end() const
{
    return myCellProperties.end();
}

template <DGtal::Dimension dim_embedded, DGtal::Dimension dim_ambient, typename TLinearAlgebraBackend, typename TInteger>
typename DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>::Index
DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>::kFormLength(const DGtal::Order& order, const DGtal::Duality& duality) const
{
    return myIndexSignedCells[actualOrder(order, duality)].size();
}

template <DGtal::Dimension dim_embedded, DGtal::Dimension dim_ambient, typename TLinearAlgebraBackend, typename TInteger>
DGtal::Order
DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>::actualOrder(const DGtal::Order& order, const DGtal::Duality& duality) const
{
    return (duality == PRIMAL) ? order : dim_embedded-order;
}

template <DGtal::Dimension dim_embedded, DGtal::Dimension dim_ambient, typename TLinearAlgebraBackend, typename TInteger>
typename DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>::Scalar
DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>::hodgeSign(const Cell& cell, const DGtal::Duality& duality) const
{
    if (duality == PRIMAL) return 1;

    const DGtal::Dimension& primal_dim = myKSpace.uDim(cell);
    const bool apply_sign = ((dim_embedded-primal_dim)*primal_dim % 2 == 1);

    return apply_sign ? -1 : 1;
}

template <DGtal::Dimension dim_embedded, DGtal::Dimension dim_ambient, typename TLinearAlgebraBackend, typename TInteger>
typename DGtal::Dimension
DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>::edgeDirection(const Cell& cell, const DGtal::Duality& duality) const
{
    ASSERT( myKSpace.uDim(cell) == actualOrder(1, duality) );

    typename KSpace::DirIterator di = myKSpace.uDirs(cell);
    if (duality == DUAL) di = myKSpace.uOrthDirs(cell);

    ASSERT( di != 0 );
    const DGtal::Dimension direction = *di;
    ++di;
    ASSERT( !(di != 0) );
    ASSERT( direction < dim_ambient );

    return direction;
}

template <DGtal::Dimension dim_embedded, DGtal::Dimension dim_ambient, typename TLinearAlgebraBackend, typename TInteger>
bool
DGtal::DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>::isValid() const
{
    return true;
}

///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions                                        //

template <DGtal::Dimension dim_embedded, DGtal::Dimension dim_ambient, typename TLinearAlgebraBackend, typename TInteger>
std::ostream&
DGtal::operator<<(std::ostream & out, const DiscreteExteriorCalculus<dim_embedded, dim_ambient, TLinearAlgebraBackend, TInteger>& object)
{
  object.selfDisplay(out);
  return out;
}

//                                                                           //
///////////////////////////////////////////////////////////////////////////////
