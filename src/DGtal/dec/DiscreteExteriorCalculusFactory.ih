/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file DiscreteExteriorCalculusFactory.ih
 * @author Pierre Gueth (\c pierre.gueth@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Systemes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 *
 * @date 2015/05/04
 *
 * Implementation of inline methods for DiscreteExteriorCalculusFactory
 *
 * This file is part of the DGtal library.
 */

///////////////////////////////////////////////////////////////////////////////
// Implementation of inline methods                                          //

template <typename TLinearAlgebraBackend, typename TInteger>
template <typename TDigitalSet>
DGtal::DiscreteExteriorCalculus<TDigitalSet::Point::dimension, TDigitalSet::Point::dimension, TLinearAlgebraBackend, TInteger>
DGtal::DiscreteExteriorCalculusFactory<TLinearAlgebraBackend, TInteger>::createFromDigitalSet(const TDigitalSet& _set, const bool add_border)
{
    BOOST_CONCEPT_ASSERT(( DGtal::concepts::CDigitalSet<TDigitalSet> ));
    typedef DGtal::DiscreteExteriorCalculus<TDigitalSet::Point::dimension, TDigitalSet::Point::dimension, TLinearAlgebraBackend, TInteger> Calculus;
    typedef typename Calculus::Cell Cell;
    typedef typename Calculus::SCell SCell;
    typedef typename Calculus::Scalar Scalar;
    typedef typename Calculus::Point Point;
    typedef typename Calculus::Property Property;
    typedef typename Calculus::Properties Properties;
    typedef typename Calculus::KSpace KSpace;

    Calculus calculus;
    calculus.initKSpace(_set.domain());

    // compute raw cell size
    typedef std::map<Cell, Scalar> Accum;
    Accum cell_size_accum;
    for (typename TDigitalSet::ConstIterator ri=_set.begin(), rie=_set.end(); ri!=rie; ri++)
    {
        const Point& point = *ri;
        const Cell cell_point = calculus.myKSpace.uSpel(point);

        typedef DGtal::SpaceND<Calculus::dimension_ambient, TInteger> Space;
        typedef DGtal::HyperRectDomain<Space> Neighborbood;
        const Point cell_coords = calculus.myKSpace.uKCoords(cell_point);
        const Neighborbood neighborhood(cell_coords-Point::diagonal(1), cell_coords+Point::diagonal(1));
        for (typename Neighborbood::ConstIterator pi=neighborhood.begin(), pie=neighborhood.end(); pi!=pie; pi++)
        {
            const Cell cell = calculus.myKSpace.uCell(*pi);
            if (cell_size_accum.find(cell) == cell_size_accum.end()) cell_size_accum[cell] = 0;
            cell_size_accum[cell] += 1;
        }
    }

    // normalize cell size and set flipped flag
    for (typename Accum::const_iterator csi=cell_size_accum.begin(), csie=cell_size_accum.end(); csie!=csi; csi++)
    {
        const Cell& cell = csi->first;
        const DGtal::Dimension dual_dim = Calculus::dimension_embedded-calculus.myKSpace.uDim(cell);
        const Scalar factor = 1/pow(2, dual_dim);

        const Scalar normalized_size = csi->second * factor;
        ASSERT(normalized_size > 0 && normalized_size <= 1);

        if (!add_border && normalized_size < 1) continue;

        Property property;
        property.flipped = false;
        property.size_ratio = normalized_size;

        calculus.myCellProperties[cell] = property;
    }

    // compute cell index
    for (typename Properties::iterator csi=calculus.myCellProperties.begin(), csie=calculus.myCellProperties.end(); csie!=csi; csi++)
    {
        const Cell& cell = csi->first;
        const DGtal::Dimension cell_dim = calculus.myKSpace.uDim(cell);

        csi->second.index = calculus.myIndexSignedCells[cell_dim].size();

        const SCell& signed_cell = calculus.myKSpace.signs(cell, csi->second.flipped ? KSpace::NEG : KSpace::POS);
        calculus.myIndexSignedCells[cell_dim].push_back(signed_cell);
    }

    return calculus;
}

//                                                                           //
///////////////////////////////////////////////////////////////////////////////


