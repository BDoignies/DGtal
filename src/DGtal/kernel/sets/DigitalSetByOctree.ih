namespace DGtal {
	template<class Space>
	void DigitalSetByOctree<Space>::OctreeIterator::findNextLeaf() {
	    while (myMemory.size() != 0) {
	        TraversalMemory& m = myMemory.top();

	        // Find next unexplored child. Invalid index means no child was explored yet
	        CellIndex k = (m.currentChildIdx == INVALID_IDX) ? 0 : (m.currentChildIdx + 1);
	        for (; k < CELL_COUNT; ++k) {
	            if (myContainer->myNodes[m.lvl][m.idx].children[k] != INVALID_IDX) {
	                // Update explored child
	                m.currentChildIdx = k;
	                break;
	            }
	        }

	        if (k < CELL_COUNT) { // Child found, go down
	        	if (myMemory.top().lvl == myContainer->myNodes.size() - 1) break;

	            TraversalMemory newMemory;
	            newMemory.lvl = m.lvl + 1;
	            newMemory.domain = splitDomain(m.domain, SIDES_FROM_INDEX[k].data());
	            newMemory.idx = myContainer->myNodes[m.lvl][m.idx].children[k];
	            newMemory.currentChildIdx = INVALID_IDX;

	            myMemory.push(std::move(newMemory));
	        } else { // No more child unexplored, go back to parent
	            myMemory.pop();
	        }

	    }

	    if (myMemory.size() != 0) {
	        // For leaves, find first non 0 index
	        auto& mem = myMemory.top();
	        if (mem.currentChildIdx == INVALID_IDX) {
	            for (CellIndex k = 0; k < CELL_COUNT; ++k) {
	                if (myContainer->myNodes[mem.lvl][mem.idx].children[k] != 0) {
	                    mem.currentChildIdx = k;
	                    break;
	                }
	            }
	        }
	    }
	}

	template<class Space>
	DigitalSetByOctree<Space>::DigitalSetByOctree(const Domain& dom) {
        const auto lb = dom.lowerBound();
        const auto ub = dom.upperBound();
        auto size = ub - lb;
        
        // Enforce cubical domain with side that are powers of 2
        CellIndex newSize = 1;
        for (DimIndex d = 0; d < D; ++d) {
            if (!(size[d] & (size[d] - 1))) {
                newSize = (newSize > size[d]) ? newSize : size[d];
            } else {
                CellIndex s = 1 << (static_cast<CellIndex>(std::ceil(std::log(size[d]))) + 1);
                newSize = (newSize > s) ? newSize : s;
            }
        }

        for (DimIndex d = 0; d < D; ++d) {
            size[d] = newSize;
        }

        size_t lvl = static_cast<size_t>(std::ceil(std::log(newSize)));
        myNodes.resize(lvl + 1);
        myNodes[0].push_back(Node());

        myDomain = CowPtr(new Domain(lb, lb + size));
        mySize = 0;
    };

	template<class Space>
    HyperRectDomain<Space> DigitalSetByOctree<Space>::splitDomain(const Domain& domain, const DimIndex* sides) {
              auto lb = domain.lowerBound();
        const auto ub = domain.upperBound();
        const auto size = (ub - lb) / 2;

        for (DimIndex d = 0; d < D; ++d)
            lb[d] += sides[d] * size[d];
        
        return Domain(lb, lb + size);
    }

	template<class Space>
    void DigitalSetByOctree<Space>::insert(const Point& p) {
        if (!myDomain->isInside(p)) return;
        
        if (myState == State::OCTREE) {
            Domain domain = *myDomain;
            CellIndex nodeIdx = 0;
            
            for (size_t i = 0; i < myNodes.size() - 1; ++i) {
                const auto lb = domain.lowerBound();
                const auto ub = domain.upperBound();
                const Point middle = domain.lowerBound() + (ub - lb) / 2;

                CellIndex childIdx = 0;
                DimIndex sides[D]{};
                for (DimIndex d = 0; d < D; ++d) {
                    sides[d]  = (p[d] >= middle[d]);
                    childIdx += sides[d] * (1 << d);
                }

                domain = splitDomain(domain, sides);
                if (myNodes[i][nodeIdx].children[childIdx] == INVALID_IDX) {
                    myNodes[i + 1].push_back(Node());
                    myNodes[i][nodeIdx].children[childIdx] = myNodes[i + 1].size() - 1;
                }

                nodeIdx = myNodes[i][nodeIdx].children[childIdx];
            }

            // This octree does not create nodes for leaves. 
            // We treat them separately and use children field as 
            // a binary array to indicate wether a voxel is stored or not
            const auto lb = domain.lowerBound();
            const auto ub = domain.upperBound();
            const Point middle = domain.lowerBound() + (ub - lb) / 2;

            CellIndex childIdx = 0;
            for (DimIndex d = 0; d < D; ++d) {
                childIdx += (p[d] >= middle[d]) * (1 << (D - d - 1));
            }

            if (myNodes[myNodes.size() - 1][nodeIdx].children[childIdx] != 1) {
                myNodes[myNodes.size() - 1][nodeIdx].children[childIdx]  = 1;
        		mySize ++;
            }
        }
    }

	template<class Space>
    DigitalSetByOctree<Space>::OctreeIterator DigitalSetByOctree<Space>::find(const Point& p) const {
        std::stack<TraversalMemory> traversal;
        Domain domain = *myDomain;
        CellIndex nodeIdx = 0;
        
        TraversalMemory root;
        root.lvl = 0;
        root.domain = domain;
        root.idx = 0;
        traversal.push(root);
        
        if (!domain.isInside(p)) return end();
        for (size_t i = 0; i < myNodes.size() - 1; ++i) {
            const auto lb = domain.lowerBound();
            const auto ub = domain.upperBound();
            const Point middle = domain.lowerBound() + (ub - lb) / 2;

            CellIndex childIdx = 0;

            DimIndex sides[D]{};
            for (DimIndex d = 0; d < D; ++d) {
                sides[d]  = (p[d] >= middle[d]);
                childIdx += sides[d] * (1 << d);
            }
            
            if (myNodes[i][nodeIdx].children[childIdx] == INVALID_IDX) {
                return end();
            }
            
            domain = splitDomain(domain, sides);
            nodeIdx = myNodes[i][nodeIdx].children[childIdx];

            TraversalMemory memory;
            memory.domain = domain;
            memory.lvl = i + 1;
            memory.idx = nodeIdx;
            memory.currentChildIdx = INVALID_IDX;
            
            traversal.top().currentChildIdx = childIdx;
            traversal.push(memory);
        }
        
        const auto lb = domain.lowerBound();
        const auto ub = domain.upperBound();
        const Point middle = domain.lowerBound() + (ub - lb) / 2;
        CellIndex childIdx = 0;
        for (DimIndex d = 0; d < D; ++d) {
            childIdx += (p[d] >= middle[d]) * (1 << (D - d - 1));
        }
        traversal.top().currentChildIdx = childIdx;

        return Iterator(this, traversal);
    }

	template<class Space>
    size_t DigitalSetByOctree<Space>::erase(const Iterator& it) {
        if (it.myMemory.size() == 0) return 0;

        if (myState == State::OCTREE) {
            std::vector<std::pair<CellIndex, CellIndex>> reindex;
            bool childRemoved = true;

            auto mem = it.myMemory;
            while (!mem.empty()) {
                const auto& tmem = mem.top();
                if (childRemoved) { // Can disconnect parent from the child
                    CellIndex child = myNodes[tmem.lvl][tmem.idx].children[tmem.currentChildIdx];
                    myNodes[tmem.lvl][tmem.idx].children[tmem.currentChildIdx] = INVALID_IDX;
                    
                    // Reindex childrens because one was removed in previous layer
                    for (CellIndex i = 0; i < myNodes[tmem.lvl].size(); ++i) {
                        auto& node = myNodes[tmem.lvl][i];
                        for (CellIndex j = 0; j < CELL_COUNT; ++j) {
                            if (node.children[j] != INVALID_IDX && node.children[j] >= child) {
                                node.children[j] --;
                            }
                        }
                    }
                }

                size_t count = 0;
                for (CellIndex i = 0; i < CELL_COUNT; ++i) {
                    count += (myNodes[tmem.lvl][tmem.idx].children[i] != INVALID_IDX);
                }

                if (count == 0) {
                    myNodes[tmem.lvl].erase(myNodes[tmem.lvl].begin() + tmem.idx);
                    childRemoved = true;
                } else {
                    childRemoved = false;
                }

                mem.pop();
            }
            mySize --;
            return 1;
        }
        return 0;
    }

	template<class Space>
    void DigitalSetByOctree<Space>::convertToDAG() {
	    std::vector<size_t> correspondances;
	    for (CellIndex i = myNodes.size() - 1; i > 0; --i) {
	        std::vector<Node> newNodes;
	        std::map<std::array<CellIndex, CELL_COUNT>, size_t> signatures;
	        std::vector<size_t> newCorrespondances(myNodes[i].size());

	        for (CellIndex j = 0; j < myNodes[i].size(); ++j) {
	            std::array<CellIndex, CELL_COUNT> signature;

	            if (correspondances.size() != 0) { // Mostly leaves
	                for (CellIndex k = 0; k < CELL_COUNT; ++k) {
	                    if (myNodes[i][j].children[k] != INVALID_IDX) {
	                        myNodes[i][j].children[k] = correspondances[myNodes[i][j].children[k]];
	                    }
	                    signature[k] = myNodes[i][j].children[k];
	                }
	            } else {
	                for (CellIndex k = 0; k < CELL_COUNT; ++k) {
	                    signature[k] = myNodes[i][j].children[k];
	                }
	            }
	            
	            auto it = signatures.find(signature);
	            if (it != signatures.end()) {
	                newCorrespondances[i] = it->second;
	            } else {
	                newNodes.push_back(myNodes[i][j]);
	                signatures[signature] = newNodes.size() - 1;
	                newCorrespondances[i] = newNodes.size() - 1;
	            }
	        }
	        
	        myNodes[i] = newNodes;
	        correspondances = newCorrespondances;
	    }

	    // New pointers for root lvl:
	    if (correspondances.size() != 0) {
	        for (CellIndex k = 0; k < CELL_COUNT; ++k) {
	            if (myNodes[0][0].children[k] != INVALID_IDX) 
	                myNodes[0][0].children[k] = correspondances[myNodes[0][0].children[k]];
	        }
	    }
	    shrink();
	    myState = State::DAG;
	}

	template<class Space>
	void DigitalSetByOctree<Space>::dumpOctree() const {
	    for (size_t i = 0; i < myNodes.size(); ++i) {
	        std::cout << "===" << i << "===\n";
	        for (size_t j = 0; j < myNodes[i].size(); j++) {
	            std::cout << "  -> " << j << "\n";
	            for (size_t k = 0; k < CELL_COUNT; k++) {
	                std::cout << "\t" << k << ": ";
	                if (myNodes[i][j].children[k] == INVALID_IDX) {
	                    std::cout << "N.A." << "\n";
	                } else {
	                    std::cout << myNodes[i][j].children[k] << "\n";
	                }
	            }
	        }
	    }
	    std::cout << std::flush;
	}
}