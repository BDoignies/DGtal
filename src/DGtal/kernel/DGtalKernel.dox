/**
 * @file DGtalKernel.dox
 * @author David Coeurjolly (\c david.coeurjolly@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Syst√®mes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 *
 * @date 2011/03/04
 *
 * Documentation file for feature DGtalKernel
 *
 * This file is part of the DGtal library.
 */

/* 
 * Useful to avoid writing DGtal:: in front of every class.
 * Do not forget to add an entry in src/DGtal/base/Config.h.in !
 */
namespace DGtal {
//----------------------------------------
/*!
@page DGtalKernel Introduction to DGtal Kernel 
@author David Coeurjolly


This part of the manual describes the DGtal kernel and its
classes. More precisely, we define several key concepts in DGtal such as
Space or Domain. All classes and utilities defined in the DGtal
library require a specification of the digital space in which the
objects are defined. 

For DGtal users, the specification of the digital Space  usually
corresponds to the first lines of DGtal codes. 

Table of contents:
 -# \ref sectSpace
 -# \ref sectPointVector
 -# \ref sectDomain 
   -# \ref sectDomDef
   -# \ref sectDomIter
 -# \ref sectImage


\section sectSpace DGtal Space

A DGtal Space parametrized by two things: a dimension
 (SpaceND::dimension) and a type for
 integers (SpaceND::Integer). Using these information,  we aim at approximating the
 digital space \f$Z^n\f$ by \f$Integer^{dimension}\f$.
 Hence, we have several constraints these parameters:
 - the dimension should also be a integer;
 - Integer should characterize a commutative ring with unity using the
 addition and multiplication operators. 


Since the Space is obtained by direct product of the range associated
to the type Integer. Such type is also used to characterized the
coordinates of points lying in this space.

In DGtal, Space specification is addresses by the class
DGtal::SpaceND. More precisely, this class is templated by two
arguments (the static dimension and the Integer type) and provides
types for several objects that can be deduced from the template
parameters. For example, once the parameter are specified, the
class provides a type Point for all points in the space. 

For example, digital spaces can be defined as follows:

@code
#include "DGtal/base/Common.h"
#include "DGtal/kernel/SpaceND.h"
{...}
typedef DGtal::SpaceND<3, DGtal::int32_t> MySpace32;
typedef DGtal::SpaceND<1, DGtal::int64_t> MySpace64;
typedef DGtal::SpaceND<3, mpz_class> MySpaceGMP;
@endcode

In the latter example, we construct a digital space using the GMP
arbitrary precision integers.

However, if we try:
@code
typedef DGtal::SpaceND<2, unsigned char> MySpaceUChar;
@endcode
a build error is raised by the compiler since we cannot define a ring
based on "unsigned char". 

@note To check the constraints on template parameter types, DGtal is
based on a concept framework and concept checking utilities (see
dedicated documentation). In this example, the type "unsigned char" is
not a model of the concept CSignedInteger and thus cannot be used to
define a DGtal space.

Using the shortcuts provides in StdDefs.h, the types defined in the
namespace  DGtal::Z2i correspond to a digital space in dimension 2
based on unsigned int (uint32_t). Hence, we can simple define MySpace
as:

@code
#include "DGtal/base/Common.h"
#include "DGtal/helpers/StdDefs.h"
{...}
typedef DGtal::Z2i::Space MySpace; 
@endcode

We can construct a point lying in this space as follows:

@code
#include "DGtal/base/Common.h"
#include "DGtal/helpers/StdDefs.h"
{...}
using namespace DGtal::Z2i;
//We use default types Z2i::Space and Z2i::Point
Point p(13,-5);
@endcode


Beside the type Point (defined as a specialization of the class
PointVector),  SpaceND (or Z2i::Space) provides several other types
and methodes such as
 - types associated to the canonical vector space  (SpaceND::Point, SpaceND::Vector,...)
 - types and methods for subspace and subcospace construction
 - ...

\section sectPointVector Points and Vectors

Points and Vectors are fundamental objects in the digital space. Indeed, they allow  us to access to grid point location or to represent displacements between grid points. Many methods are defined for Point and Vector instances. For example we have 
 - arithmetic operators (*, -, ...)
 - comparison operators (< ,>, ...)
 - methods associate to the canonical lattice associated to points (inf, sup, isLower,...)
 - methods to compute various norms of Points/Vectors.
 - last but not least, the interface also provides iterators and accessors.


@note For the sake of simplicity, both SpaceND::Point and SpaceND::Vector in a space DGtal::SpaceND<dimension,Integer> are aliases of the specialized type DGtal::PointVector<dimension,Integer>. In other words, these two types can be exchanged without any problem, even if it does not make sense in a  mathematical. For instance, from a vector, we can define its opposite but the opposite does not make sense for a point. 


 An element of a Point has type Coordinate and an element of a Vector has type Component. For instance, the following code is valid in terms of type.
@code
 Point p;
 Point::Coordinate coord = 24;
 for(Dimension d = 0 ; d < Space::dimension; ++d)
    p[d] = coord;
@endcode
However, we encourage the use of iterators as follows
@code
 Point p;
 Point::Coordinate coord = 24;
 for(Point::Iterator it=p.begin(), itend=p.end() ; 
     it != itend;
     ++it)
     (*it) = coord;
@endcode


@note Similarly to the previous note and since Vector and Space are aliases, SpaceND::Point::Coordinate and SpaceND::Vector::Component are aliases of  SpaceND::Integer. It does not lead to a strong typing of Point and Vector but it helps the user to design code as close as possible to a mathematical formulation.


\section sectDomain Domains and) HyperRectDomains

\subsection sectDomDef Definition

Once we have defined the fundamental characteristics of our digital
space, we can define a domain on which all the computations will
done. A domain is characterized by a starting point A, an end point B and
a way to scan all the point  between A and B. In most situation, one
may want the domain to be a finite isothetic subset of the digital
space. Hence, an important model of the concept of domain (specified
in the CDomain class) is the class HyperRectDomain. Since the domain
lies on a digital space, the HyperRectDomain class has a template
argument which correspond to the type of space we consider.

For example, let us consider the following code snippet
@code
#include <DGtal/base/Common.h>
#include <DGtal/kernel/SpaceND.h>
#include <DGtal/helpers/StdDefs.h>
#include <DGtal/kernel/domains/HyperRectDomain.h>
{...}
using namespace DGtal::Z2i;
@endcode

An instance of HyperRectDomain can be created as follows:
@code
typedef HyperRectDomain<Space> MyDomain;
Point a(-3,-4);
Point b(10,4);
MyDomain domain(a,b);
@endcode

The instance is thus an isothetic domain lying on the space SpaceND<2,DGtal::uint32_t> 
defined by the bounding box of the points a and b. Note that  type  Z2i::Domain in StdDefs.h exctly corresponds to HyperRectDomain<Space>.
 We can visualise the domain using the DGtalBoard stream mechanism (see \ref dgtal_dgtalboard).

@image html kernel-domain.png "Illustration of a simple 2-D domain"
@image latex kernel-domain.png "Illustration of a simple 2-D domain"  width=6cm

The HyperRectDomain class provides several methods such as HyperRectDomain::isInside to decide if a point is inside the domain or not.

@code
 Point c(5,1);
 if ( domain.isInside( c ) )
    trace.info() << "C is inside the domain"<<endl;
 else
    trace.info() << "C is outside the domain"<<endl;
 @endcode

@image html kernel-domain-point.png "Illustration of a simple 2-D domain with a point"
@image latex kernel-domain-point.png "Illustration of a simple 2-D domain with a point"  width=6cm


\subsection sectDomIter Iterating over an  HyperRectDomain

An important feature of DGtal domain is based on iterators it defines to scan the grid points in various orders. For example, to scan the domain we can use

@code
for( MyDomain::ConstIterator it = domain.begin(), itend = domain.end();
     it != itend;   
     ++it)
  trace.info() << "Processing point"<< (*it) << endl;
@endcode    

By default, HyperRectDomain iterators use the lexicographic order on the dimensions. To visualise this order in dimension 2, we can use the following code snippet in which we display each point by a color map from blue to red according to the order (blue point corresponds to the first point and the red one to the last point).
Note that in this example, we use a specific drawing primitive (selfDraw) in order to draw a SpaceND::Vector as an arrow..

Again, for details on the DGtalBoard mechanism, please refer to \ref dgtal_dgtalboard.

@code
 //We draw an arrow between two consecutive points during the iteration.
  MyDomain::ConstIterator itPrec = domain.begin();
  MyDomain::ConstIterator it = itPrec;
  Space::Vector shift;
  ++it;

  board << (*itPrec); //We display the first point as a pixel.
  for( MyDomain::ConstIterator itend = domain.end();
       it != itend;   
       ++it, ++itPrec)
    {
      shift =   (*it) -(*itPrec);
      shift.selfDraw(board, (*itPrec));
    }
  board.saveSVG("kernel-domain-it-arrow.svg");
@endcode

\image html kernel-domain-it-arrow.png "Iteration over a domain with displacements depicted as arrows."
\image latex kernel-domain-it-arrow.png "Iteration over a domain with displacements depicted as arrows."  width=5cm


@todo A specific section of the documentation will be devoted to customizable iterators. 


\section sectImage Image



*/

}
