/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file PointVector.ih
 * @author David Coeurjolly (\c david.coeurjolly@liris.cnrs.fr )
 * @author Guillaume Damiand (\c guillaume.damiand@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Syst√®mes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 *
 * @date 2010/05/14
 *
 * Implementation of inline methods defined in PointVector.h
 *
 * This file is part of the DGtal library.
 */

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
#include <cmath>
#include <DGtal/base/BasicFunctors.h>
//////////////////////////////////////////////////////////////////////////////

template<Dimension dim, typename Component>
inline
DGtal::PointVector<dim, Component>::PointVector()
{
  for ( Dimension i = 0; i < dim; ++i )
    myArray[ i ] = 0;
}
//------------------------------------------------------------------------------
template<Dimension dim, typename Component>
template<typename Functor>
inline
DGtal::PointVector<dim, Component>::PointVector(const PointVector& apoint1,
    const PointVector& apoint2,
    const Functor& f)
{
  for ( Dimension i = 0; i < dim; ++i )
    myArray[ i ] = f.operator() (apoint1[i], apoint2[i]);
}
//------------------------------------------------------------------------------

template<Dimension dim, typename Component>
inline
DGtal::PointVector<dim, Component>::~PointVector()
{}
//------------------------------------------------------------------------------
template<Dimension dim, typename Component>
inline
DGtal::PointVector<dim, Component>::PointVector( const Component * ptrValues )
{
  // The problem here is that we have no guaranty on the size of init !!
  for ( Dimension i = 0; i < dim; ++i )
    myArray[ i ] = ptrValues[ i ];
}

//------------------------------------------------------------------------------
template<Dimension dim, typename Component>
inline
DGtal::PointVector<dim, Component>::PointVector( const Component & x, const Component & y )
{
  ASSERT( dim >= 2 );
  myArray[ 0 ] = x;
  myArray[ 1 ] = y;
  for ( Dimension i = 2; i < dim; ++i )
    myArray[ i ] = 0;
}
//------------------------------------------------------------------------------
template<Dimension dim, typename Component>
inline
DGtal::PointVector<dim, Component>::PointVector( const Component & x, const Component & y, const Component & z )
{
  ASSERT( dim >= 3 );
  myArray[ 0 ] = x;
  myArray[ 1 ] = y;
  myArray[ 2 ] = z;
  for ( Dimension i = 3; i < dim; ++i )
    myArray[ i ] = 0;
}
//------------------------------------------------------------------------------
template<Dimension dim, typename Component>
inline
DGtal::PointVector<dim, Component>::PointVector( const Component & x, const Component & y,
    const Component & z, const Component & t )
{
  ASSERT( dim >= 4 );
  myArray[ 0 ] = x;
  myArray[ 1 ] = y;
  myArray[ 2 ] = z;
  myArray[ 3 ] = t;
  for ( Dimension i = 4; i < dim; ++i )
    myArray[ i ] = 0;
}
//------------------------------------------------------------------------------
#ifdef CPP0X_INITIALIZER_LIST
template<Dimension dim, typename Component>
inline
DGtal::PointVector<dim, Component>::PointVector(std::initializer_list<Component> init)
{
  unsigned int i = 0;
  for (const Component *p = init.begin (); p != init.end () && i < dim; ++p, ++i)
    myArray[ i ] = *p;
  for ( ; i < dim; ++i)
    myArray[i] = 0;
}
#endif // CPP0X_INITIALIZER_LIST
//------------------------------------------------------------------------------
template<Dimension dim, typename Component>
inline
DGtal::PointVector<dim, Component>::PointVector ( const PointVector<dim, Component> & other )
    : myArray( other.myArray )
{}
//------------------------------------------------------------------------------
template<Dimension dim, typename Component>
inline
typename DGtal::PointVector<dim, Component>::Iterator
DGtal::PointVector<dim, Component>::begin()
{
  return myArray.begin();
}
//------------------------------------------------------------------------------
template<Dimension dim, typename Component>
inline
typename DGtal::PointVector<dim, Component>::Iterator
DGtal::PointVector<dim, Component>::end()
{
  return myArray.end();
}
//------------------------------------------------------------------------------
template<Dimension dim, typename Component>
inline
typename DGtal::PointVector<dim, Component>::ConstIterator
DGtal::PointVector<dim, Component>::begin() const
{
  return myArray.begin();
}
//------------------------------------------------------------------------------
template<Dimension dim, typename Component>
inline
typename DGtal::PointVector<dim, Component>::ConstIterator
DGtal::PointVector<dim, Component>::end() const
{
  return myArray.end();
}
//------------------------------------------------------------------------------
template<Dimension dim, typename Component>
inline
typename DGtal::Dimension
DGtal::PointVector<dim, Component>::size()
{
  return dim;
}
//------------------------------------------------------------------------------
template<Dimension dim, typename Component>
inline
typename DGtal::Dimension
DGtal::PointVector<dim, Component>::dimension()
{
  return dim;
}
//------------------------------------------------------------------------------
template<Dimension dim, typename Component>
inline
const Component&
DGtal::PointVector<dim, Component>::at ( Dimension i ) const
{
  ASSERT ( i < dim );
  return myArray.at( i );
}
//------------------------------------------------------------------------------
template<Dimension dim, typename Component>
inline Component& DGtal::PointVector<dim, Component>::at( Dimension i )
{
  ASSERT ( i < dim );
  return myArray.at( i );
}
//------------------------------------------------------------------------------
template<Dimension dim, typename Component>
inline
const Component&
DGtal::PointVector<dim, Component>::operator[]( Dimension i ) const
{
  ASSERT ( i < dim );
  return myArray[i];
}
//------------------------------------------------------------------------------
template<Dimension dim, typename Component>
inline Component& DGtal::PointVector<dim, Component>::operator[]( Dimension i )
{
  ASSERT ( i < dim );
  return myArray[i];
}
//------------------------------------------------------------------------------
template<Dimension dim, typename Component>
DGtal::PointVector<dim, Component>&
DGtal::PointVector<dim, Component>::operator*= ( Component coeff )
{
  for ( Dimension i = 0; i < myArray.size(); ++i )
    myArray[ i ] *= coeff;
  return *this;
}
//------------------------------------------------------------------------------
template<Dimension dim, typename Component>
DGtal::PointVector<dim, Component>
DGtal::PointVector<dim, Component>::operator* ( Component coeff )
{
  PointVector v = *this;
  v *= coeff;
  return v;
}
//------------------------------------------------------------------------------
template<Dimension dim, typename Component>
inline
DGtal::PointVector<dim, Component>&
DGtal::PointVector<dim, Component>::operator= ( const PointVector<dim, Component> & pv )
{
  myArray = pv.myArray;
  return *this;
}
//------------------------------------------------------------------------------
#ifdef CPP0X_INITIALIZER_LIST
template<Dimension dim, typename Component>
template<typename Size>
inline
DGtal::PointVector<dim, Component>&
DGtal::PointVector<dim, Component>::partialCopy ( const PointVector<dim, Component> & pv,
    std::initializer_list<Size> dimensions
                                      )
{
  std::vector<Size> sortedDim;
  sortedDim.reserve(dimensions.size());
  for (const Size *c = dimensions.begin ();
      c != dimensions.end (); ++c)
  {
    ASSERT( *c < dim );
    sortedDim.push_back(*c);
  }
  std::sort(sortedDim.begin(), sortedDim.end());

  Size i = 0, j = 0;
  for ( ; i < sortedDim.size() && j < dim; ++j )
  {
    if ( sortedDim[i] == j )
    {
      myArray[j] = pv.myArray[j];
      ++i;
      ASSERT(i == sortedDim.size() || sortedDim[i-1] != sortedDim[i]);
    }
  }
  return *this;
}
#endif
template<Dimension dim, typename Component>
template<typename Size>
inline
DGtal::PointVector<dim, Component>&
DGtal::PointVector<dim, Component>::partialCopy ( const PointVector<dim, Component> & pv,
    const std::vector<Size> &dimensions)
{
  std::vector<Size> sortedDim;
  typedef typename std::vector<Size>::const_iterator const_iterator;
  sortedDim.reserve(dimensions.size());
  for (const_iterator it = dimensions.begin ();
      it != dimensions.end (); ++it)
  {
    ASSERT( *it < dim );
    sortedDim.push_back(*it);
  }
  std::sort(sortedDim.begin(), sortedDim.end());

  Size i = 0, j = 0;
  for ( ; i < sortedDim.size() && j < dim; ++j )
  {
    if ( sortedDim[i] == j )
    {
      myArray[j] = pv.myArray[j];
      ++i;
      ASSERT(i == sortedDim.size() || sortedDim[i-1] != sortedDim[i]);
    }
  }
  return *this;
}
//------------------------------------------------------------------------------
template<Dimension dim, typename Component>
inline
bool
DGtal::PointVector<dim, Component>::operator== ( const PointVector<dim, Component> & pv ) const
{
  return (myArray == pv.myArray);
}
//------------------------------------------------------------------------------
template<Dimension dim, typename Component>
inline
bool
DGtal::PointVector<dim, Component>::operator!= ( const PointVector<dim, Component> & pv ) const
{
  return (myArray != pv.myArray);
}
//------------------------------------------------------------------------------
template<Dimension dim, typename Component>
inline
bool
DGtal::PointVector<dim, Component>::operator< ( const PointVector<dim, Component> & pv ) const
{
  return (myArray < pv.myArray);
}
//------------------------------------------------------------------------------
template<Dimension dim, typename Component>
inline
bool
DGtal::PointVector<dim, Component>::operator<= ( const PointVector<dim, Component> & pv ) const
{
  return (myArray <= pv.myArray);
}
//------------------------------------------------------------------------------
template<Dimension dim, typename Component>
inline
bool
DGtal::PointVector<dim, Component>::operator> ( const PointVector<dim, Component> & pv ) const
{
  return (myArray > pv.myArray);
}
//------------------------------------------------------------------------------
template<Dimension dim, typename Component>
inline
bool
DGtal::PointVector<dim, Component>::operator>= ( const PointVector<dim, Component> & pv ) const
{
  return (myArray >= pv.myArray);
}
//------------------------------------------------------------------------------
template<Dimension dim, typename Component>
inline
DGtal::PointVector<dim, Component>&
DGtal::PointVector<dim, Component>::operator+= ( const PointVector<dim, Component>& v )
{
  for ( Dimension i = 0; i < dim; ++i )
    this->myArray[ i ] += v.at ( i );
  return *this;
}
//------------------------------------------------------------------------------
template<Dimension dim, typename Component>
inline
DGtal::PointVector<dim, Component>
DGtal::PointVector<dim, Component>::operator+ ( const PointVector<dim, Component>& v ) const
{
  return PointVector(*this, v, std::plus<Component>());
}
//------------------------------------------------------------------------------
template<Dimension dim, typename Component>
inline
DGtal::PointVector<dim, Component>&
DGtal::PointVector<dim, Component>::operator-= ( const PointVector<dim, Component>& v )
{
  for ( Dimension i = 0; i < dim; ++i )
    this->myArray[ i ] -= v.at ( i );
  return *this;
}
//------------------------------------------------------------------------------
template<Dimension dim, typename Component>
inline
DGtal::PointVector<dim, Component>
DGtal::PointVector<dim, Component>::operator- ( const PointVector<dim, Component>& v ) const
{
  return PointVector(*this, v, MinusFunctor<Component>());
}
//------------------------------------------------------------------------------
template<Dimension dim, typename Component>
inline
void
DGtal::PointVector<dim, Component>::reset()
{
  for ( Dimension i = 0; i < myArray.size(); ++i )
    myArray[ i ] = 0;
}
//------------------------------------------------------------------------------
template<Dimension dim, typename Component>
inline
DGtal::PointVector<dim, Component>
DGtal::PointVector<dim, Component>::inf( const PointVector& apoint ) const
{
  return PointVector(*this, apoint, MinFunctor<Component>());
}
//------------------------------------------------------------------------------
template<Dimension dim, typename Component>
inline
DGtal::PointVector<dim, Component>
DGtal::PointVector<dim, Component>::sup( const PointVector& apoint ) const
{
  return PointVector(*this, apoint, MaxFunctor<Component>());
}
//------------------------------------------------------------------------------
template<Dimension dim, typename Component>
inline
bool
DGtal::PointVector<dim, Component>::isLower( const PointVector& p ) const
{
  for ( Dimension i = 0; i < myArray.size(); ++i )
    if ( p[ i ] < myArray[ i ] )
      return false;
  return true;
}
//------------------------------------------------------------------------------
template<Dimension dim, typename Component>
inline
bool
DGtal::PointVector<dim, Component>::isUpper( const PointVector& p ) const
{
  for ( Dimension i = 0; i < myArray.size(); ++i )
    if ( p[ i ] > myArray[ i ] )
      return false;
  return true;
}
//------------------------------------------------------------------------------
template<Dimension dim, typename Component>
inline
double
DGtal::PointVector<dim, Component>::norm (const typename PointVector<dim, Component>::NormType aType ) const
{
  double tmp = 0.0;

  ASSERT ( dim > 0 );

  switch ( aType )
  {
    case L_2:
      for ( unsigned int i = 0; i < dimension(); i++ )
        tmp += IntegerTraits<Component>::castToDouble(at ( i )) *IntegerTraits<Component>::castToDouble(at ( i ));
      tmp = ( double ) sqrt ( tmp );
      break;
    case L_1:
      for ( unsigned int i = 0; i < dimension(); i++ )
        tmp += fabs (  IntegerTraits<Component>::castToDouble(at( i ) ));
      break;
    case L_infty:
      tmp = IntegerTraits<Component>::castToDouble( at( 0 ));
      for ( unsigned int i = 1; i < dimension(); i++ )
        if ( tmp < fabs ( IntegerTraits<Component>::castToDouble(at ( i ) ) ))
          tmp = fabs ( IntegerTraits<Component>::castToDouble(at ( i ) ));
      break;
  }
  return tmp;
}
//------------------------------------------------------------------------------
template<Dimension dim, typename Component>
inline
typename DGtal::PointVector<dim, Component>::UnsignedComponent
DGtal::PointVector<dim, Component>::norm1() const
{
  ASSERT ( dimension() > 0 );
  UnsignedComponent val( ( myArray[ 0 ] >= 0 ) ? myArray[ 0 ] : -myArray[ 0 ] );
  for ( unsigned int i = 1; i < dimension(); ++i )
    val += ( myArray[ i ] >= 0 ) ? myArray[ i ] : -myArray[ i ];
  return val;
}
//------------------------------------------------------------------------------
template<Dimension dim, typename Component>
inline
typename DGtal::PointVector<dim, Component>::UnsignedComponent
DGtal::PointVector<dim, Component>::normInfinity() const
{
  ASSERT ( dimension() > 0 );
  UnsignedComponent val( ( myArray[ 0 ] >= 0 ) ? myArray[ 0 ] : -myArray[ 0 ] );
  for ( unsigned int i = 1; i < dimension(); ++i )
  {
    UnsignedComponent tmp( ( myArray[ i ] >= 0 )
        ? myArray[ i ] : -myArray[ i ] );
    if ( tmp > val )
      val = tmp;
  }
  return val;
}
// ------------------------- Standard vectors ------------------------------
//------------------------------------------------------------------------------
template<Dimension dim, typename Component>
inline
DGtal::PointVector<dim,Component>
DGtal::PointVector<dim,Component>::diagonal( Component val )
{
  PointVector p;
  for ( Dimension i = 0; i < dim; ++i )
    p.myArray[ i ] = val;
  return p;
}
//------------------------------------------------------------------------------
template<Dimension dim,typename Component>
inline
DGtal::PointVector<dim,Component>
DGtal::PointVector<dim,Component>::base( Dimension k, Component val )
{
  PointVector p;
  p.myArray[ k ] = val;
  return p;
}
//------------------------------------------------------------------------------
template<Dimension dim,typename Component>
inline
void 
DGtal::PointVector<dim,Component>::selfDisplay( std::ostream & out ) const
{
  out << "[PointVector] {";
  for (unsigned int i = 0; i < dimension() ; ++i)
    out << at( i ) << (i == dimension() - 1 ? "" : ", ");
  out << "}";
}

// --------------- CDrawableWithDGtalBoard realization -------------------------
//------------------------------------------------------------------------------


template<Dimension dim, typename Component>
inline
DGtal::DrawableWithDGtalBoard*
DGtal::PointVector<dim, Component>::defaultStyle( std::string mode) const
{
  if ( ( mode == "" ) || ( mode == "Paving" ) ) 
    return new DefaultDrawStylePaving;
  else // mode == "Grid"
    return new DefaultDrawStyleGrid;
  
}



//------------------------------------------------------------------------------
template<Dimension dim, typename Component>
inline
std::string
DGtal::PointVector<dim, Component>::styleName() const
{
  return "PointVector";
}
//------------------------------------------------------------------------------

/**
 * Draw a pixel as a unit square on a LiBoard board
 * @param board the output board where the object is drawn.
 */


template<Dimension dim, typename Component>
inline
void
DGtal::PointVector<dim,Component>::selfDrawAsPaving( DGtalBoard & board ) const
{
  ASSERT(dim == 2);
  board.drawRectangle( (float) IntegerTraits<Component>::castToInt64_t(myArray[0]) - 0.5f, 
 		       (float) IntegerTraits<Component>::castToInt64_t(myArray[1]) + 0.5f, 1, 1 );     
}


/**
 * Draw a pixel as a point on a LiBoard board
 * @param board the output board where the object is drawn.
 */


template<Dimension dim, typename Component>
inline
void
DGtal::PointVector<dim,Component>::selfDrawAsGrid( DGtalBoard & board ) const
{
  ASSERT(dim == 2);
  board.setPenColor(LibBoard::Color::Black);
  board.fillCircle((float) IntegerTraits<Component>::castToInt64_t(myArray[0]), 
		   (float) IntegerTraits<Component>::castToInt64_t(myArray[1]),0.1);
}


/**
 * Draw the object on a LibBoard board.
 * @param board the output board where the object is drawn.
 */
template<Dimension dim, typename Component>
inline
void
DGtal::PointVector<dim,Component>::selfDraw( DGtalBoard & board ) const
{
  std::string mode = board.getMode( this->styleName() );
  if ( mode == "Paving" )
    selfDrawAsPaving( board );
  else if ( mode == "Grid" )
    selfDrawAsGrid( board );
  else if ( ( mode == "Both" ) || ( mode == "" ) )
    {
      selfDrawAsPaving( board );
      selfDrawAsGrid( board );
    }
  else
    ASSERT(false && ("DGtal::ArithmeticalDSS<TDSS>::selfDraw: Unknown mode "+mode)==""  );
}




//------------------------------------------------------------------------------
template<Dimension dim, typename Component>
inline
void
DGtal::PointVector<dim, Component>::selfDraw(DGtalBoard & board,const PointVector &apoint) const
{
  ASSERT(dim == 2);

  board.drawArrow((float)apoint[0], (float) apoint[1],
      (float) apoint[0] + myArray[0], (float)apoint[1] + myArray[1],
      true);

}
//------------------------------------------------------------------------------
template<Dimension dim, typename Component>
inline
std::ostream&
DGtal::operator<<( std::ostream & out, const PointVector<dim, Component> & object )
{
  object.selfDisplay( out );
  return out;
}
//------------------------------------------------------------------------------
template<Dimension dim, typename Component>
inline
bool
DGtal::PointVector<dim, Component>::isValid() const
{
  return true;
}
//------------------------------------------------------------------------------
