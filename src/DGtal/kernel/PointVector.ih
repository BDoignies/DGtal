/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/
//LICENSE-END
/**
 * @file PointVector.ih
 * @author David Coeurjolly (\c david.coeurjolly@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Syst√®mes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 *
 * @date 2010/05/14
 *
 * Implementation of inline methods defined in PointVector.h
 *
 * This file is part of the DGtal library.
 */

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
#include <cmath>
#include <DGtal/base/BasicFunctors.h>
//////////////////////////////////////////////////////////////////////////////
template<std::size_t N,typename T>
inline
DGtal::PointVector<N,T>::PointVector()
{  
  for ( std::size_t i = 0; i < N; ++i )
    myArray[ i ] = 0;
}
//------------------------------------------------------------------------------
template<std::size_t N,typename T>
template<typename Functor>
inline
DGtal::PointVector<N,T>::PointVector(const PointVector& apoint1, 
				     const PointVector& apoint2,
				     const Functor& f)
{  
  for ( std::size_t i = 0; i < N; ++i )
    myArray[ i ] = f.operator() (apoint1[i],apoint2[i]);
}
//------------------------------------------------------------------------------

template<std::size_t N,typename T>
inline
DGtal::PointVector<N,T>::~PointVector()
{}
//------------------------------------------------------------------------------
template<std::size_t N,typename T>
inline
DGtal::PointVector<N,T>::PointVector( const T * ptrValues )
{
  // The problem here is that we have no guaranty on the size of init !!
  for ( std::size_t i = 0; i < N; ++i )
    myArray[ i ] = ptrValues[ i ];
}
//------------------------------------------------------------------------------
template<std::size_t N,typename T>
inline
DGtal::PointVector<N,T>::PointVector( const T & x )
{
  ASSERT( N >= 1 );
  myArray[ 0 ] = x;
  for ( std::size_t i = 1; i < N; ++i )
    myArray[ i ] = 0;
}
//------------------------------------------------------------------------------
template<std::size_t N,typename T>
inline
DGtal::PointVector<N,T>::PointVector( const T & x, const T & y )
{
  ASSERT( N >= 2 );
  myArray[ 0 ] = x;
  myArray[ 1 ] = y;
  for ( std::size_t i = 2; i < N; ++i )
    myArray[ i ] = 0;
}
//------------------------------------------------------------------------------
template<std::size_t N,typename T>
inline
DGtal::PointVector<N,T>::PointVector( const T & x, const T & y, const T & z )
{
  ASSERT( N >= 3 );
  myArray[ 0 ] = x;
  myArray[ 1 ] = y;
  myArray[ 2 ] = z;
  for ( std::size_t i = 3; i < N; ++i )
    myArray[ i ] = 0;
}
//------------------------------------------------------------------------------
template<std::size_t N,typename T>
inline
DGtal::PointVector<N,T>::PointVector( const T & x, const T & y, 
				      const T & z, const T & t )
{
  ASSERT( N >= 4 );
  myArray[ 0 ] = x;
  myArray[ 1 ] = y;
  myArray[ 2 ] = z;
  myArray[ 3 ] = t;
  for ( std::size_t i = 4; i < N; ++i )
    myArray[ i ] = 0;
}
//------------------------------------------------------------------------------
#ifdef CPP0X_INITIALIZER_LIST
template<std::size_t N,typename T>
inline
DGtal::PointVector<N,T>::PointVector(std::initializer_list<T> init)
{ 
  unsigned int i=0;
  for (const T *p = init.begin (); p != init.end () && i<N; ++p, ++i)
    myArray[ i ] = *p;
  for ( ; i<N; ++i)
    myArray[i]=0;
}
#endif // CPP0X_INITIALIZER_LIST
//------------------------------------------------------------------------------
template<std::size_t N,typename T>
inline
DGtal::PointVector<N,T>::PointVector ( const PointVector<N,T> & other )
  : myArray( other.myArray )
{}
//------------------------------------------------------------------------------
template<std::size_t N,typename T>
inline
typename DGtal::PointVector<N,T>::Iterator 
DGtal::PointVector<N,T>::begin() 
{
  return myArray.begin();
}
//------------------------------------------------------------------------------
template<std::size_t N,typename T>
inline
typename DGtal::PointVector<N,T>::Iterator 
DGtal::PointVector<N,T>::end()
{
  return myArray.end();
}
//------------------------------------------------------------------------------
template<std::size_t N,typename T>
inline
typename DGtal::PointVector<N,T>::ConstIterator
DGtal::PointVector<N,T>::begin() const
{
  return myArray.begin();
}
//------------------------------------------------------------------------------
template<std::size_t N,typename T>
inline
typename DGtal::PointVector<N,T>::ConstIterator
DGtal::PointVector<N,T>::end() const
{
  return myArray.end();
}
//------------------------------------------------------------------------------
template<std::size_t N,typename T>
inline
std::size_t
DGtal::PointVector<N,T>::size()
{
  return N;
}
//------------------------------------------------------------------------------
template<std::size_t N,typename T>
inline
std::size_t
DGtal::PointVector<N,T>::dimension()
{
  return N;
}
//------------------------------------------------------------------------------
template<std::size_t N,typename T>
inline
const T&
DGtal::PointVector<N,T>::at ( std::size_t i ) const
{
  ASSERT ( i < N );
  return myArray.at( i );
}
//------------------------------------------------------------------------------
template<std::size_t N,typename T>
inline T& DGtal::PointVector<N,T>::at( std::size_t i )
{
  ASSERT ( i < N );
  return myArray.at( i );
}
//------------------------------------------------------------------------------
template<std::size_t N,typename T>
inline
const T&
DGtal::PointVector<N,T>::operator[]( std::size_t i ) const
{
  ASSERT ( i < N );
  return myArray[i];
}
//------------------------------------------------------------------------------
template<std::size_t N,typename T>
inline T& DGtal::PointVector<N,T>::operator[]( std::size_t i )
{
  ASSERT ( i < N );
  return myArray[i];
}
//------------------------------------------------------------------------------
template<std::size_t N,typename T>
DGtal::PointVector<N,T>&
DGtal::PointVector<N,T>::operator*= ( T coeff )
{
  for ( std::size_t i = 0; i < myArray.size(); ++i )
    myArray[ i ] *= coeff;
  return *this;
}
//------------------------------------------------------------------------------
template<std::size_t N,typename T>
DGtal::PointVector<N,T>
DGtal::PointVector<N,T>::operator* ( T coeff )
{
	PointVector v = *this;
	v *= coeff;
	return v;
}
//------------------------------------------------------------------------------
template<std::size_t N, typename T>
inline
DGtal::PointVector<N,T>&
DGtal::PointVector<N,T>::operator= ( const PointVector<N,T> & pv )
{
  myArray = pv.myArray;
  return *this;
}
//------------------------------------------------------------------------------
template<std::size_t N, typename T>
inline
bool
DGtal::PointVector<N,T>::operator== ( const PointVector<N,T> & pv ) const
{
  return (myArray == pv.myArray);
}
//------------------------------------------------------------------------------
template<std::size_t N, typename T>
inline
bool
DGtal::PointVector<N,T>::operator!= ( const PointVector<N,T> & pv ) const
{
  return (myArray != pv.myArray);
}
//------------------------------------------------------------------------------
template<std::size_t N, typename T>
inline
bool
DGtal::PointVector<N,T>::operator< ( const PointVector<N,T> & pv ) const
{
  return (myArray < pv.myArray);
}
//------------------------------------------------------------------------------
template<std::size_t N, typename T>
inline
bool
DGtal::PointVector<N,T>::operator<= ( const PointVector<N,T> & pv ) const
{
  return (myArray <= pv.myArray);
}
//------------------------------------------------------------------------------
template<std::size_t N, typename T>
inline
bool
DGtal::PointVector<N,T>::operator> ( const PointVector<N,T> & pv ) const
{
  return (myArray > pv.myArray);
}
//------------------------------------------------------------------------------
template<std::size_t N, typename T>
inline
bool
DGtal::PointVector<N,T>::operator>= ( const PointVector<N,T> & pv ) const
{
  return (myArray >= pv.myArray);
}
//------------------------------------------------------------------------------
template<std::size_t N,typename T>
inline 
DGtal::PointVector<N,T>&
DGtal::PointVector<N,T>::operator+= ( const PointVector<N,T>& v )
{
  for ( std::size_t i = 0; i < N; ++i )
    this->myArray[ i ] += v.at ( i );
  return *this;
}
//------------------------------------------------------------------------------
template<std::size_t N,typename T>
inline 
DGtal::PointVector<N,T>
DGtal::PointVector<N,T>::operator+ ( const PointVector<N,T>& v ) const
{ return PointVector(*this,v,std::plus<T>()); }
//------------------------------------------------------------------------------
template<std::size_t N,typename T>
inline 
DGtal::PointVector<N,T>&
DGtal::PointVector<N,T>::operator-= ( const PointVector<N,T>& v )
{
  for ( std::size_t i = 0; i < N; ++i )
    this->myArray[ i ] -= v.at ( i );
  return *this;
}
//------------------------------------------------------------------------------
template<std::size_t N,typename T>
inline 
DGtal::PointVector<N,T>
DGtal::PointVector<N,T>::operator- ( const PointVector<N,T>& v ) const
{ return PointVector(*this,v,MinusFunctor<T>()); }
//------------------------------------------------------------------------------
template<std::size_t N, typename T>
inline
void
DGtal::PointVector<N,T>::reset()
{
  for ( std::size_t i = 0; i < myArray.size(); ++i )
    myArray[ i ] = 0;
}
//------------------------------------------------------------------------------
template<std::size_t N, typename T>
inline
DGtal::PointVector<N,T> 
DGtal::PointVector<N,T>::inf( const PointVector& apoint ) const
{ return PointVector(*this,apoint,MinFunctor<T>()); }
//------------------------------------------------------------------------------
template<std::size_t N, typename T>
inline
DGtal::PointVector<N,T>
DGtal::PointVector<N,T>::sup( const PointVector& apoint ) const
{ return PointVector(*this,apoint,MaxFunctor<T>()); }
//------------------------------------------------------------------------------
template<std::size_t N, typename T>
inline
bool
DGtal::PointVector<N,T>::isLower( const PointVector& p ) const
{
  for ( std::size_t i = 0; i < myArray.size(); ++i )
    if ( p[ i ] < myArray[ i ] ) return false;
  return true;
}
//------------------------------------------------------------------------------
template<std::size_t N, typename T>
inline
bool
DGtal::PointVector<N,T>::isUpper( const PointVector& p ) const
{
  for ( std::size_t i = 0; i < myArray.size(); ++i )
    if ( p[ i ] > myArray[ i ] ) return false;
  return true;
}
//------------------------------------------------------------------------------
template<std::size_t N, typename T>
inline
double
DGtal::PointVector<N,T>::norm (const typename PointVector<N,T>::NormType aType ) const
{
  double tmp= 0.0;

  ASSERT ( dimension() > 0 );

  switch ( aType ) 
    {
    case L_2:
      for ( unsigned int i=0; i < dimension(); i++ )
	tmp += at ( i ) *at ( i );
      tmp = ( double ) sqrt ( tmp );
      break;
    case L_1:
      for ( unsigned int i=0; i < dimension(); i++ )
	tmp += fabs ( (double) at( i ) );
      break;
    case L_infty:
      tmp = at( 0 );
      for ( unsigned int i=1; i < dimension(); i++ )
	if ( tmp < fabs ( (double) at ( i ) ) )
	  tmp = fabs ( (double) at ( i ) );
      break;
    }
  return tmp;
}
//------------------------------------------------------------------------------
template<std::size_t N, typename T>
inline
typename DGtal::PointVector<N,T>::UnsignedComponent
DGtal::PointVector<N,T>::norm1() const
{
  ASSERT ( dimension() > 0 );
  UnsignedComponent val( ( myArray[ 0 ] >= 0 ) ? myArray[ 0 ] : -myArray[ 0 ] );
  for ( unsigned int i=1; i < dimension(); ++i )
    val += ( myArray[ i ] >= 0 ) ? myArray[ i ] : -myArray[ i ];
  return val;
}
//------------------------------------------------------------------------------
template<std::size_t N, typename T>
inline
typename DGtal::PointVector<N,T>::UnsignedComponent
DGtal::PointVector<N,T>::normInfinity() const
{
  ASSERT ( dimension() > 0 );
  UnsignedComponent val( ( myArray[ 0 ] >= 0 ) ? myArray[ 0 ] : -myArray[ 0 ] );
  for ( unsigned int i=1; i < dimension(); ++i )
    {
      UnsignedComponent tmp( ( myArray[ i ] >= 0 ) 
			     ? myArray[ i ] : -myArray[ i ] );
      if ( tmp > val ) val = tmp;
    }
  return val;
}
//------------------------------------------------------------------------------
template<std::size_t N,typename T>
inline
void 
DGtal::PointVector<N,T>::selfDisplay( std::ostream & out ) const
{
  out << "[PointVector] {";
  for(unsigned int i=0; i < dimension() ; ++i)
    out << at( i ) <<(i==dimension()-1?"":", ");
  out << "}";  
}

//------------------------------------------------------------------------------
template<std::size_t N,typename T>
template<typename Functor>
inline
void 
DGtal::PointVector<N,T>::selfDraw(LibBoard::Board & board) const
{
  ASSERT(N==2);
  Functor applystyle(board);
  board.drawDot((float) myArray[0], (float) myArray[1]);
  
}
//------------------------------------------------------------------------------
template<std::size_t N,typename T>
template<typename Functor>
inline
void 
DGtal::PointVector<N,T>::selfDraw(LibBoard::Board & board, 
				  const PointVector &apoint) const
{
  ASSERT(N==2); 
  Functor applystyle(board);

  board.drawArrow((float)apoint[0], (float) apoint[1], 
		  (float) apoint[0]+myArray[0],(float)apoint[1]+ myArray[1],
		  true);
     
}
//------------------------------------------------------------------------------
template<std::size_t N, typename T>
inline
std::ostream&
DGtal::operator<<( std::ostream & out, const PointVector<N,T> & object )
{
  object.selfDisplay( out );
  return out;
}
//------------------------------------------------------------------------------
template<std::size_t N,typename T>
inline
bool 
DGtal::PointVector<N,T>::isValid() const
{
  return true;
}
//------------------------------------------------------------------------------
