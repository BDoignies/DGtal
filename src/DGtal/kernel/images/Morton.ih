/**
 * @file Morton.ih
 * @author David Coeurjolly (\c david.coeurjolly@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Systèmes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 *
 * @date 2010/09/10
 *
 * Header file for module Morton.cpp
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
// Inclusions
#include <iostream>
#include "DGtal/base/Common.h"
#include "DGtal/kernel/PointVector.h"
#include "DGtal/utils/Bits.h"
//////////////////////////////////////////////////////////////////////////////

namespace DGtal
{

  template  <typename HashKey, typename Point >
  Morton<HashKey,Point>::Morton()
  {
    myDilateMasks[0] = 25;
  }


  template  <typename HashKey, typename Point >
  void Morton<HashKey,Point>:: interleaveBits(const Point  & aPoint, HashKey & output) const
  {
    //number of bits of the input integers (casted according to the hashkeysize)
    // max de ça avec sizeof(Coordinate)*8
    int coordSize = (sizeof(HashKey)<<3)/ Dimension;

    output = 0;
    for(unsigned i = 0; i < coordSize; ++i)
      for(unsigned n = 0; n < Dimension; ++n)
	{
	  if((aPoint[n]) & ( static_cast<Coordinate>(1) << i))
	    output |= static_cast<Coordinate>(1) << (i*Dimension)+n;
	}
  }
    

  template  <typename HashKey, typename Point >
  HashKey  Morton<HashKey,Point>::keyFromCoordinates(const std::size_t treeDepth, 
						     const Point & coordinates) const
  {
    HashKey result = 0;
    
    interleaveBits(coordinates, result);
    // by convention, the root node has the key 0..01
    // it makes it easy to determine the depth of a node by it's key (looking
    // at the position of the most significant bit that is equal to 1)
    result |= (static_cast<HashKey>(1) << Dimension*treeDepth); 

    return result;
  }



  template  <typename HashKey, typename Point >
  void Morton<HashKey,Point>::childrenKeys(const HashKey key, HashKey* result ) const
  {
    HashKey keycopy = key;

    keycopy <<= Dimension;
    //generate a mask of the form 1..111000 with Dimension "0"
    HashKey mask  = (static_cast<HashKey>(~0) << Dimension);
    for(std::size_t i = 0; 
	i < POW<2,Dimension>::VALUE;
	++i)
      {
	result[i] = (keycopy & mask)|i;
      }
  }
  
  template  <typename HashKey, typename Point >
  void Morton<HashKey,Point>::brotherKeys(const HashKey key, HashKey* result ) const
  {
    //generate a mask of the form 1..111000 with Dimension "0"
    HashKey mask  = (static_cast<HashKey>(~0) << Dimension);
    std::size_t j = 0;
    for(std::size_t i = 0; i < POW<2,Dimension>::VALUE; ++i)
      {
	HashKey key2 = (key & mask)|i;
	if(key2 != key)
	  {
	    result[j] = key2;
	    ++j;
	  }
      }
  }
    
  template  <typename HashKey, typename Point >
  void Morton<HashKey,Point>::coordinatesFromKey(const HashKey key, Point & coordinates) const
  {
    HashKey akey = key;
    //remove the first bit equal 1
    for(int i = (sizeof(HashKey)<<3)-1; i >= 0; --i)
      if(akey & Bits::mask<HashKey>(i))
	{
	  akey &= ~Bits::mask<HashKey>(i);
	  break;
	}
   
    //deinterleave the bits
    for(std::size_t i = 0; i < Dimension; ++i)
      {
	coordinates[i] = 0;
	for(std::size_t bitPos = 0; bitPos < (sizeof(HashKey)<<3)/Dimension; ++bitPos)
	  {
	    //cerr << "debug: i="<< i<< " bitPos="<< bitPos<<endl;
	    if(akey & Bits::mask<HashKey>(bitPos*Dimension+i))
	      {
		coordinates[i] |= Bits::mask<HashKey>(bitPos);
	      }
	  }
      }
  }
  
};
