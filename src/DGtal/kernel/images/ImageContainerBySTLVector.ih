/**
 * @file ImageContainerBySTLVector.ih
 * @author David Coeurjolly (\c david.coeurjolly@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Syst√®mes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 *
 * @date 2010/06/15
 *
 * Implementation of inline methods defined in ImageContainerBySTLVector.h
 *
 * This file is part of the DGtal library.
 */

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
//////////////////////////////////////////////////////////////////////////////

template <typename Domain, typename T>
inline
ImageContainerBySTLVector<Domain,T>::ImageContainerBySTLVector(const Point &aPointA,
        const Point &aPointB )
{
  if (aPointA < aPointB)
    {
      myLowerBound = aPointA;
      myUpperBound = aPointB;
    }
  else
    {
      myLowerBound = aPointB;
      myUpperBound = aPointA;
    }
 
  Point dec = myUpperBound - myLowerBound;
  size_t extent = 1;
  for(unsigned int k=0;k<  Domain::staticDimension; k++)
    extent *= dec[k]+1;
  this->resize(extent);
}

template <typename Domain, typename T>
inline
ImageContainerBySTLVector<Domain,T>::~ImageContainerBySTLVector( )
{
}


template <typename Domain, typename T>
inline
T
ImageContainerBySTLVector<Domain,T>::operator()(const Point &aPoint) const
{
    return this->at( linearized( aPoint ) );

}

template <typename Domain, typename T>
inline
void
ImageContainerBySTLVector<Domain,T>::setValue(const Point &aPoint, const T &V)
{
  this->at( linearized( aPoint ) ) = V;
}

template <typename Domain, typename T>
inline
typename ImageContainerBySTLVector<Domain,T>::Vector
ImageContainerBySTLVector<Domain,T>::extent() const
{
  Vector one;
  for(unsigned int i= 0; i < Domain::staticDimension; i++)
    one[i] = myUpperBound[i] - myLowerBound[i] + 1;

  return one;
}



///////////////////////////////////////////////////////////////////////////////
// Helper classes defined in the compilation unit (anonymous namespace)

namespace {

  /**
   * Class template for linearization of the coordinates of a Point.
   * This class template is to be specialized for efficiency for dimensions 1,
   * 2 and 3 to prevent the use of a loop in these cases.
   * 
   */
  template < typename Domain, int Dimension, typename SizeType >
  struct linearizer {

    typedef typename Domain::Point Point;

    /** 
     * Compute the linearized offset of a point in a vector container.
     * 
     * @param aPoint A point
     * @param lowerBound The lower bound of the image domain.
     * @param upperBound The upper bound of the image domain.
     * 
     * @return 
     */
    static SizeType apply( const Point & aPoint,
			   const Point & lowerBound,
			   const Point & upperBound ) {
      SizeType pos = aPoint[ 0 ] - lowerBound[ 0 ] ;
      SizeType multiplier = 1;
      for (unsigned int k = 1 ; k < Point::Dimension ; ++k)
	{
	  multiplier *= 1 + ( upperBound[ k-1  ] - lowerBound[ k-1 ] );
	  pos += multiplier * ( aPoint[ k ] - lowerBound[ k ] );
	} 
      return pos;
    }
  };

  /**
   * Specialization of the linearizer class for dimension 1.
   * 
   */
  template < typename Domain, typename SizeType >
  struct linearizer< Domain, 1, SizeType > {
    typedef typename Domain::Point Point;

    static SizeType apply( const Point & aPoint,
			   const Point & lowerBound,
			   const Point & upperBound ) {
      return aPoint[ 0 ] - lowerBound[ 0 ];
    }
  };

  /**
   * Specialization of the linearizer class for dimension 2.
   * 
   */
  template < typename Domain, typename SizeType >
  struct linearizer< Domain, 2, SizeType > {
    typedef typename Domain::Point Point;

    static SizeType apply( const Point & aPoint,
			   const Point & lowerBound,
			   const Point & upperBound ) {
      SizeType multiplier = 1 + upperBound[ 0 ] - lowerBound[ 0 ];    
      return ( aPoint[ 0 ] - lowerBound[ 0 ] ) + multiplier * (aPoint[ 1 ] - lowerBound[ 1 ] ); 
    }
  };

  /**
   * Specialization of the linearizer class for dimension 3.
   * 
   */
  template < typename Domain, typename SizeType >
  struct linearizer< Domain, 3, SizeType > {
    typedef typename Domain::Point Point;

    static SizeType apply( const Point & aPoint,
			   const Point & lowerBound,
			   const Point & upperBound ) {
      SizeType res = aPoint[ 0 ] - lowerBound[ 0 ];
      SizeType multiplier = 1 + upperBound[ 0 ] - lowerBound[ 0 ];
      res += multiplier * ( aPoint[ 1 ] - lowerBound[ 1 ] );  
      multiplier *= 1 + upperBound[ 1 ] - lowerBound[ 1 ];
      res += multiplier * ( aPoint[ 2 ] - lowerBound[ 2 ] );
      return res;
    }
  };
}



///////////////////////////////////////////////////////////////////////////////
// Internals - private :
template<typename Domain, typename T>
inline
typename ImageContainerBySTLVector<Domain,T>::SizeType
ImageContainerBySTLVector<Domain,T>::linearized(const Point &aPoint) const
{
  return linearizer<Domain, Point::Dimension, SizeType >::apply( aPoint, myLowerBound, myUpperBound );
}


/**
 * Writes/Displays the object on an output stream.
 * @param out the output stream where the object is written.
 */
template <typename TDomain, typename V>
inline
void
ImageContainerBySTLVector<TDomain,V>::selfDisplay ( std::ostream & out ) const
{
  out << "[Image - STLVector] size="<<this->size();
}

