/**
 * @file moduleBigImages.dox
 * @author Martial Tola (\c martial.tola@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et SystÃ¨mes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 *
 * @date 2013/03/12
 * 
 * @brief Documentation file about big images in DGtal
 *
 * This file is part of the DGtal library.
 */
namespace DGtal {

//----------------------------------------
/*!


@page moduleBigImages Handle large images in DGtal
@authors Martial Tola
@date 2013/03/12

[TOC]

\section dgtalBigImagesAbstract Overview

Large images like tiled images, HDF5 images, ... can be handled in DGtal.

For this, we provide two important mechanisms: an image factory mechanism and an image cache mechanism with read and write policies.

The image factory is necessary to keep control on the created images. As its responsability is to create images according to a domain,
it is obvious that the factory can update (flush) the image on disk and also can free the image from memory.
It is thanks to that that we can work with specific image formats like for example HDF5.
This mechanism is a DGtal concept called CImageFactory which is detailed just after.

As we want to take also into account the large images effectively we also need a cache mechanism to access subparts of tiled images.
The cache has the responsability to store tiles and giving us read and write access to them. The reading, writing and updating mechanisms of the cache
are controlled with two policies: the read and the write policies.
These policies are DGtal concepts called respectively CImageCacheReadPolicy and CImageCacheWritePolicy which are detailed just below.

The cache mechanism is rather simple. It consists of three important functions that are detailed here:

 - the `read` function return true and get the value of an image from cache at a given position given by a point only if that point belongs to an image from cache, else return false.

 - the `write` function return true and set the value of an image from cache at a given position given by a point only if that point belongs to an image from cache, else return false.

 - the `update` function update the cache according to the read policy.

\section dgtalBigImagesConcepts Concepts

\subsection dgtalBigImagesFactoryConcepts CImageFactory

Any model of the concept CImageFactory must have this nested type:
 
  - OutputImage, which specifies the type of the images created by the factory.

Moreover, it must have the following methods:

  - `requestImage`, which takes a domain as input parameter
and returns an OutputImage pointer on the created image.

  - `flushImage`, which takes an OutputImage pointer as input parameter
in order to flush/synchronize it on disk.

  - `detachImage`, which takes an OutputImage pointer as input parameter
in order to delete/release it.

\subsection dgtalBigImagesCachePoliciesConcepts Cache policies concepts

Cache policies concepts are divided in two concepts: read and write policies.

\subsubsection dgtalBigImagesCacheReadPolicyConcepts CImageCacheReadPolicy

Any model of the concept CImageCacheReadPolicy must have this nested type:
 
  - ImageContainer, which specifies the type of the images stored in the cache.

Moreover, it must have the following methods:

  - `getPage`, which takes a point as input parameter
and returns an ImageContainer pointer on the image that contains the point or NULL if no image in the cache contains that point.

  - `getPageToDetach`, which returns an ImageContainer pointer on the image that we have to detach or NULL if no image have to be detached.

  - `updateCache`, which takes a domain as input parameter
in order to update the cache according to the defined cache policy.

\subsubsection dgtalBigImagesCacheWritePolicyConcepts CImageCacheWritePolicy

Any model of the concept CImageCacheWritePolicy must have this nested type:
 
  - ImageContainer, which specifies the type of the images stored in the cache.

Moreover, it must have the following methods:

  - `writeInPage`, which takes an ImageContainer pointer, a point and a value for that point as input parameters
in order to set the value on the image at the position given by the point.

  - `flushPage`, which takes an ImageContainer pointer as input parameter
in order to flush the image on disk according to the defined cache policy.

\section dgtalBigImagesModels Models

\subsection dgtalBigImagesFactoryModels ImageFactoryFromImage

The ImageFactoryFromImage model is a rather simple one. It implements a factory to produce images from a "bigger/original" one according to a given domain.

\subsection dgtalBigImagesCachePoliciesModels Cache policies models

Cache policies models are like concepts also divided in two models: read and write policies.

\subsubsection dgtalBigImagesCacheReadPolicyLASTModel ImageCacheReadPolicyLAST

The ImageCacheReadPolicyLAST model is a rather simple one. It implements a 'LAST' read policy cache.

The cache keeps only one page in memory, the last one.
When the page needs to be replaced, the new page replaces the old one.

\subsubsection dgtalBigImagesCacheReadPolicyFIFOModel ImageCacheReadPolicyFIFO

The ImageCacheReadPolicyFIFO model is a rather simple one. It implements a 'FIFO' read policy cache.

The cache keeps track of all the pages in memory in a queue, with the most recent arrival at the back, and the earliest arrival in front. 
When a page needs to be replaced, the page at the front of the queue (the oldest page) is selected.

\subsubsection dgtalBigImagesCacheWritePolicyWTModel ImageCacheWritePolicyWT

The ImageCacheWritePolicyWT model is a rather simple one. It implements a 'WT (Write-through)' write policy cache.

Write is done synchronously both to the cache and to the disk.

\subsubsection dgtalBigImagesCacheWritePolicyWBModel ImageCacheWritePolicyWB

The ImageCacheWritePolicyWB model is a rather simple one. It implements a 'WB (Write-back or Write-behind)' write policy cache.

Initially, writing is done only to the cache. The write to the disk is postponed 
until the cache blocks containing the data are about to be modified/replaced by new content.

\section dgtalBigImagesSamples Sample classes

\subsection dgtalBigImagesTiledImageFromImageSample TiledImageFromImage

The TiledImageFromImage is a simple class that implements a tiled image from a "bigger/original" one.

The tiled image is create from an existing image and with two parameters (nX and nY) in order to create the list of subdomains which describe all the tiles.
The last parameter is the size of the cache (in that case, a FIFO cache).

Concerning the cache mechanism explained at the top of this document, the accessor `operator()` (i.e. the getter) and the setter `setValue` are therefore really simple to write
for the TiledImageFromImage class.

For the proof, here a the code of the two functions (in this code snippets, `findSubDomain` is just a function that get the first domain containing a point).

\code
Value operator()(const Point & aPoint) const
{
  ASSERT(myImagePtr->domain().isInside(aPoint));

  typename OutputImage::Value aValue;
    
  if (myImageCache->read(aPoint, aValue))
    return aValue;
  else
    {
      myImageCache->update(findSubDomain(aPoint));
      myImageCache->read(aPoint, aValue);
      return aValue;
    }
}
\endcode

\code
void setValue(const Point &aPoint, const Value &aValue)
{
    ASSERT(myImagePtr->domain().isInside(aPoint));
      
    if (myImageCache->write(aPoint, aValue))
      return;
    else
    {
      myImageCache->update(findSubDomain(aPoint));
      myImageCache->write(aPoint, aValue);
    }
}
\endcode

Here is the result (todo, explain):

\image html testTiledImage-image.png " (1) source image." 
\image latex testTiledImage-image.png " (1) source image."  width=5cm </TD>

\image html testTiledImage-8domains.png " (2) 8 domains." 
\image latex testTiledImage-8domains.png " (2) 8 domains."  width=5cm </TD>

\image html testTiledImage-01-read.png " (3) read: not in cache, so, update. Cache: (domain1,empty). Read: domain1." 
\image latex testTiledImage-01-read.png " (3) read: not in cache, so, update. Cache: (domain1,empty). Read: domain1."  width=5cm </TD>

\image html testTiledImage-03-read.png " (4) read: not in cache, so, update. Cache: (domain1,domain7). Read: domain7." 
\image latex testTiledImage-03-read.png " (4) read: not in cache, so, update. Cache: (domain1,domain7). Read: domain7."  width=5cm </TD>

\image html testTiledImage-05-write.png " (5) write: in cache. Cache: (domain1,domain7). Write: domain7." 
\image latex testTiledImage-05-write.png " (5) write: in cache. Cache: (domain1,domain7). Write: domain7."  width=5cm </TD>

\image html testTiledImage-07-read.png " (6) read: in cache. Cache: (domain1,domain7). Read: domain1." 
\image latex testTiledImage-07-read.png " (6) read: in cache. Cache: (domain1,domain7). Read: domain1."  width=5cm </TD>

\image html testTiledImage-09-read.png " (7) read: not in cache, so, update. Cache: (domain7,domain4). Read: domain4." 
\image latex testTiledImage-09-read.png " (7) read: not in cache, so, update. Cache: (domain7,domain4). Read: domain4."  width=5cm </TD>

\image html testTiledImage-11-write.png " (8) write: in cache. Cache: (domain7,domain4). Write: domain4" 
\image latex testTiledImage-11-write.png " (8) write: in cache. Cache: (domain7,domain4). Write: domain4"  width=5cm </TD>

\image html testTiledImage-image2.png " (9) result image." 
\image latex testTiledImage-image2.png " (9) result image."  width=5cm </TD>

\subsection dgtalBigImagesHDF5ImageSample HDF5Image

Forthcoming...

*/

}



