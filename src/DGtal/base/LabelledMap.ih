/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file LabelledMap.ih
 * @author Jacques-Olivier Lachaud (\c jacques-olivier.lachaud@univ-savoie.fr )
 * Laboratory of Mathematics (CNRS, UMR 5127), University of Savoie, France
 *
 * @date 2012/07/05
 *
 * Implementation of inline methods defined in LabelledMap.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------

///////////////////////////////////////////////////////////////////////////////
// class LabelledMap::BlockIterator
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
DGtal::LabelledMap<TData, L, TWord, N, M>::BlockIterator::
~BlockIterator()
{}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
DGtal::LabelledMap<TData, L, TWord, N, M>::BlockIterator::
BlockIterator()
  : myIdx( 0 ), myDatas( 0 )
{}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
DGtal::LabelledMap<TData, L, TWord, N, M>::BlockIterator::
BlockIterator( const Self & other)
  : myIdx( other.myIdx ), myNbDatas( other.myNbDatas ), 
    myDatas( other.myDatas ), myNext( other.myNext )
{}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
DGtal::LabelledMap<TData, L, TWord, N, M>::BlockIterator::
BlockIterator( FirstBlock & block, unsigned int idx, unsigned int size )
{
  ASSERT( idx <= size );
  if ( size <= N+1 )
    {
      if ( idx <= N )
	{
	  myIdx = idx;
	  myNbDatas = N + 1;
	  myDatas = block.datas;
	  myNext = 0;
	}
      else
	{ // end iterator.
	  myIdx = 0;
	  myNbDatas = 0;
	  myDatas = 0;
	  myNext = 0;
	}
    }
  else
    {
      ASSERT( block.data.nextBlock != 0 );
      myNext = block.data.nextBlock;
      if ( idx < N )
	{
	  myIdx = idx;
	  myNbDatas = N;
	  myDatas = block.datas;
	}
      else
	{
	  idx -= N;
	  while ( idx >= M )
	    {
	      idx -= M;
	      myNext = ( myNext != 0 ) ? myNext->next : 0;
	    }
	  if ( myNext == 0 )
	    {
	      myIdx = 0;
	      myNbDatas = 0;
	      myDatas = 0;
	    }
	  else
	    {
	      myIdx = idx;
	      myNbDatas = M;
	      myDatas = myNext->datas;
	    }
	}
    }
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
typename DGtal::LabelledMap<TData, L, TWord, N, M>::BlockIterator::Self &
DGtal::LabelledMap<TData, L, TWord, N, M>::BlockIterator::
operator=( const Self & other )
{
  if ( this != &other )
    {
      myIdx = other.myIdx; 
      myNbDatas = other.myNbDatas; 
      myDatas = other.myDatas;
      myNext = other.myNext;
    }
  return *this;
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
typename DGtal::LabelledMap<TData, L, TWord, N, M>::BlockIterator::Reference
DGtal::LabelledMap<TData, L, TWord, N, M>::BlockIterator::
operator*() const
{
  ASSERT( myDatas != 0 );
  return myDatas[ myIdx ];
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
typename DGtal::LabelledMap<TData, L, TWord, N, M>::BlockIterator::Pointer 
DGtal::LabelledMap<TData, L, TWord, N, M>::BlockIterator::
operator->() const
{
  ASSERT( myDatas != 0 );
  return myDatas + myIdx;
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
typename DGtal::LabelledMap<TData, L, TWord, N, M>::BlockIterator::Self &
DGtal::LabelledMap<TData, L, TWord, N, M>::BlockIterator::
operator++()
{
  return this->operator+=( 1 );
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
typename DGtal::LabelledMap<TData, L, TWord, N, M>::BlockIterator::Self
DGtal::LabelledMap<TData, L, TWord, N, M>::BlockIterator::
operator++( int )
{
  Self tmp( *this );
  this->operator++();
  return tmp;
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
bool
DGtal::LabelledMap<TData, L, TWord, N, M>::BlockIterator::
operator==( const Self & other ) const
{
  return ( myDatas == other.myDatas ) && ( myIdx == other.myIdx );
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
bool
DGtal::LabelledMap<TData, L, TWord, N, M>::BlockIterator::
operator!=( const Self & other ) const
{
  return ( myDatas != other.myDatas ) || ( myIdx != other.myIdx );
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
typename DGtal::LabelledMap<TData, L, TWord, N, M>::BlockIterator::Self &
DGtal::LabelledMap<TData, L, TWord, N, M>::BlockIterator::
operator+=( DifferenceType n ) 
{
  myIdx += n;
  while ( myIdx >= myNbDatas )
    {
      if ( myNext == 0 )
	{
	  myDatas = 0;
	  myIdx = 0;
	  break;
	}
      myIdx -= myNbDatas;
      myDatas = myNext->datas;
      myNbDatas = M;
      myNext = myNext->next;
    }
  return *this;  
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
typename DGtal::LabelledMap<TData, L, TWord, N, M>::BlockIterator::Reference
DGtal::LabelledMap<TData, L, TWord, N, M>::BlockIterator::
operator[]( DifferenceType n ) const
{
  Self tmp( *this );
  tmp += n;
  return *tmp;
}

///////////////////////////////////////////////////////////////////////////////
// class LabelledMap::BlockConstIterator
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
DGtal::LabelledMap<TData, L, TWord, N, M>::BlockConstIterator::
~BlockConstIterator()
{}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
DGtal::LabelledMap<TData, L, TWord, N, M>::BlockConstIterator::
BlockConstIterator()
  : myIdx( 0 ), myDatas( 0 )
{}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
DGtal::LabelledMap<TData, L, TWord, N, M>::BlockConstIterator::
BlockConstIterator( const Self & other)
  : myIdx( other.myIdx ), myNbDatas( other.myNbDatas ), 
    myDatas( other.myDatas ), myNext( other.myNext )
{}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
DGtal::LabelledMap<TData, L, TWord, N, M>::BlockConstIterator::
BlockConstIterator( const FirstBlock & block, unsigned int idx, unsigned int size )
{
  ASSERT( idx <= size );
  if ( size <= N+1 )
    {
      if ( idx <= N )
	{
	  myIdx = idx;
	  myNbDatas = N + 1;
	  myDatas = block.datas;
	  myNext = 0;
	}
      else
	{ // end iterator.
	  myIdx = 0;
	  myNbDatas = 0;
	  myDatas = 0;
	  myNext = 0;
	}
    }
  else
    {
      ASSERT( block.data.nextBlock != 0 );
      myNext = block.data.nextBlock;
      if ( idx < N )
	{
	  myIdx = idx;
	  myNbDatas = N;
	  myDatas = block.datas;
	}
      else
	{
	  idx -= N;
	  while ( idx >= M )
	    {
	      idx -= M;
	      myNext = ( myNext != 0 ) ? myNext->next : 0;
	    }
	  if ( myNext == 0 )
	    {
	      myIdx = 0;
	      myNbDatas = 0;
	      myDatas = 0;
	    }
	  else
	    {
	      myIdx = idx;
	      myNbDatas = M;
	      myDatas = myNext->datas;
	    }
	}
    }
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
typename DGtal::LabelledMap<TData, L, TWord, N, M>::BlockConstIterator::Self &
DGtal::LabelledMap<TData, L, TWord, N, M>::BlockConstIterator::
operator=( const Self & other )
{
  if ( this != &other )
    {
      myIdx = other.myIdx; 
      myNbDatas = other.myNbDatas; 
      myDatas = other.myDatas;
      myNext = other.myNext;
    }
  return *this;
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
typename DGtal::LabelledMap<TData, L, TWord, N, M>::BlockConstIterator::Reference
DGtal::LabelledMap<TData, L, TWord, N, M>::BlockConstIterator::
operator*() const
{
  ASSERT( myDatas != 0 );
  return myDatas[ myIdx ];
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
typename DGtal::LabelledMap<TData, L, TWord, N, M>::BlockConstIterator::Pointer 
DGtal::LabelledMap<TData, L, TWord, N, M>::BlockConstIterator::
operator->() const
{
  ASSERT( myDatas != 0 );
  return myDatas + myIdx;
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
typename DGtal::LabelledMap<TData, L, TWord, N, M>::BlockConstIterator::Self &
DGtal::LabelledMap<TData, L, TWord, N, M>::BlockConstIterator::
operator++()
{
  return this->operator+=( 1 );
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
typename DGtal::LabelledMap<TData, L, TWord, N, M>::BlockConstIterator::Self
DGtal::LabelledMap<TData, L, TWord, N, M>::BlockConstIterator::
operator++( int )
{
  Self tmp( *this );
  this->operator++();
  return tmp;
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
bool
DGtal::LabelledMap<TData, L, TWord, N, M>::BlockConstIterator::
operator==( const Self & other ) const
{
  return ( myDatas == other.myDatas ) && ( myIdx == other.myIdx );
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
bool
DGtal::LabelledMap<TData, L, TWord, N, M>::BlockConstIterator::
operator!=( const Self & other ) const
{
  return ( myDatas != other.myDatas ) || ( myIdx != other.myIdx );
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
typename DGtal::LabelledMap<TData, L, TWord, N, M>::BlockConstIterator::Self &
DGtal::LabelledMap<TData, L, TWord, N, M>::BlockConstIterator::
operator+=( DifferenceType n ) 
{
  myIdx += n;
  while ( myIdx >= myNbDatas )
    {
      if ( myNext == 0 )
	{
	  myDatas = 0;
	  myIdx = 0;
	  break;
	}
      myIdx -= myNbDatas;
      myDatas = myNext->datas;
      myNbDatas = M;
      myNext = myNext->next;
    }
  return *this;  
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
typename DGtal::LabelledMap<TData, L, TWord, N, M>::BlockConstIterator::Reference
DGtal::LabelledMap<TData, L, TWord, N, M>::BlockConstIterator::
operator[]( DifferenceType n ) const
{
  Self tmp( *this );
  tmp += n;
  return *tmp;
}
      

///////////////////////////////////////////////////////////////////////////////
// class LabelledMap::Iterator
//-----------------------------------------------------------------------------
// template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
// inline
// DGtal::LabelledMap<TData, L, TWord, N, M>::Iterator::
// Iterator( LabelsConstIterator lIt, BlockIterator bIt )
//   : myLabelsIt( lIt ), myBlockIt( bIt ), myValue( 0, *bIt )
// {}
// //-----------------------------------------------------------------------------
// template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
// inline
// DGtal::LabelledMap<TData, L, TWord, N, M>::Iterator::
// ~Iterator()
// {}
// //-----------------------------------------------------------------------------
// template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
// inline
// DGtal::LabelledMap<TData, L, TWord, N, M>::Iterator::
// Iterator()
// {}
// //-----------------------------------------------------------------------------
// template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
// inline
// DGtal::LabelledMap<TData, L, TWord, N, M>::Iterator::
// Iterator( const Iterator & other )
//   : myLabelsIt( other.myLabelsIt ), myBlockIt( other.myBlockIt )
// {}
// //-----------------------------------------------------------------------------
// template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
// inline
// typename DGtal::LabelledMap<TData, L, TWord, N, M>::Iterator::Self &
// DGtal::LabelledMap<TData, L, TWord, N, M>::Iterator::
// operator= ( const Self & other )
// {
//   if ( this != &other )
//     {
//       myLabelsIt = other.myLabelsIt;
//       myBlockIt = other.myBlockIt;
//     }
//   return *this;
// }
// //-----------------------------------------------------------------------------
// template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
// inline
// typename DGtal::LabelledMap<TData, L, TWord, N, M>::Iterator::Reference
// DGtal::LabelledMap<TData, L, TWord, N, M>::Iterator::
// operator*() const
// {
//   //return std::make_pair( *myLabelsIt, *myBlockIt );
//   new ( &myValue ) Value( *myLabelsIt, *myBlockIt );
//   return myValue;
// }
// //-----------------------------------------------------------------------------
// template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
// inline
// typename DGtal::LabelledMap<TData, L, TWord, N, M>::Iterator::Pointer
// DGtal::LabelledMap<TData, L, TWord, N, M>::Iterator::
// operator->() const
// {
//   this->operator*();
//   return &myValue;
// }
// //-----------------------------------------------------------------------------
// template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
// inline
// typename DGtal::LabelledMap<TData, L, TWord, N, M>::Iterator::Self&
// DGtal::LabelledMap<TData, L, TWord, N, M>::Iterator::
// operator++()
// {
//   ++myLabelsIt;
//   ++myBlockIt;
//   return *this;
// }
// //-----------------------------------------------------------------------------
// template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
// inline
// typename DGtal::LabelledMap<TData, L, TWord, N, M>::Iterator::Self
// DGtal::LabelledMap<TData, L, TWord, N, M>::Iterator::
// operator++( int )
// {
//   Self tmp( *this );
//   this->operator++();
//   return tmp;
// }
// //-----------------------------------------------------------------------------
// template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
// inline
// bool
// DGtal::LabelledMap<TData, L, TWord, N, M>::Iterator::
// operator==( const Self & other ) const
// {
//   ASSERT( myBlockIt == other.myBlockIt );
//   return myLabelsIt == other.myLabelsIt;
// }
// //-----------------------------------------------------------------------------
// template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
// inline
// bool
// DGtal::LabelledMap<TData, L, TWord, N, M>::Iterator::
// operator!=( const Self & other ) const
// {
//   ASSERT( myBlockIt != other.myBlockIt );
//   return myLabelsIt != other.myLabelsIt;
// }

///////////////////////////////////////////////////////////////////////////////
// class LabelledMap::ConstIterator
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
DGtal::LabelledMap<TData, L, TWord, N, M>::ConstIterator::
ConstIterator( LabelsConstIterator lIt, BlockConstIterator bIt )
  : myLabelsIt( lIt ), myBlockIt( bIt )
{}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
DGtal::LabelledMap<TData, L, TWord, N, M>::ConstIterator::
~ConstIterator()
{}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
DGtal::LabelledMap<TData, L, TWord, N, M>::ConstIterator::
ConstIterator()
{}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
DGtal::LabelledMap<TData, L, TWord, N, M>::ConstIterator::
ConstIterator( const ConstIterator & other )
  : myLabelsIt( other.myLabelsIt ), myBlockIt( other.myBlockIt )
{}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
typename DGtal::LabelledMap<TData, L, TWord, N, M>::ConstIterator::Self &
DGtal::LabelledMap<TData, L, TWord, N, M>::ConstIterator::
operator= ( const Self & other )
{
  if ( this != &other )
    {
      myLabelsIt = other.myLabelsIt;
      myBlockIt = other.myBlockIt;
    }
  return *this;
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
typename DGtal::LabelledMap<TData, L, TWord, N, M>::ConstIterator::Reference
DGtal::LabelledMap<TData, L, TWord, N, M>::ConstIterator::
operator*() const
{
  return std::make_pair( *myLabelsIt, *myBlockIt );
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
typename DGtal::LabelledMap<TData, L, TWord, N, M>::ConstIterator::Pointer
DGtal::LabelledMap<TData, L, TWord, N, M>::ConstIterator::
operator->() const
{
  // Warning: not thread-safe.
  static Value __static_tmp;
  __static_tmp = this->operator*();
  return &__static_tmp;
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
typename DGtal::LabelledMap<TData, L, TWord, N, M>::ConstIterator::Self&
DGtal::LabelledMap<TData, L, TWord, N, M>::ConstIterator::
operator++()
{
  ++myLabelsIt;
  ++myBlockIt;
  return *this;
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
typename DGtal::LabelledMap<TData, L, TWord, N, M>::ConstIterator::Self
DGtal::LabelledMap<TData, L, TWord, N, M>::ConstIterator::
operator++( int )
{
  Self tmp( *this );
  this->operator++();
  return tmp;
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
bool
DGtal::LabelledMap<TData, L, TWord, N, M>::ConstIterator::
operator==( const Self & other ) const
{
  return myLabelsIt == other.myLabelsIt;
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
bool
DGtal::LabelledMap<TData, L, TWord, N, M>::ConstIterator::
operator!=( const Self & other ) const
{
  return myLabelsIt != other.myLabelsIt;
}

///////////////////////////////////////////////////////////////////////////////
// class LabelledMap
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
DGtal::LabelledMap<TData, L, TWord, N, M>::
LabelledMap()
{ // default constructor of myFirstBlock is automatically called.
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
DGtal::LabelledMap<TData, L, TWord, N, M>::
~LabelledMap()
{
  clear();
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
DGtal::LabelledMap<TData, L, TWord, N, M>::
LabelledMap( const LabelledMap & other )
  : myFirstBlock( other.myFirstBlock )
{
  unsigned int s = N + 1; // there is one more stored data in the last block.
  const AnyBlock* nextBlock = other.myFirstBlock.data.nextBlock;
  AnyBlock** currentPointer = & myFirstBlock.data.nextBlock;
  myLabels = other.myLabels;
  while ( s < size() )
    {
      *currentPointer = new AnyBlock( *nextBlock );
      s += M;
      currentPointer = & ( currentPointer->data.nextBlock );
    }
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
DGtal::LabelledMap<TData, L, TWord, N, M> &
DGtal::LabelledMap<TData, L, TWord, N, M>::
operator=( const LabelledMap & other )
{
  if ( this != &other )
    {
      clear();
      myFirstBlock = other.myFirstBlock;
      // there is one more stored data in the last block.
      unsigned int s = N + 1; 
      const AnyBlock* nextBlock = other.myFirstBlock.data.nextBlock;
      AnyBlock** currentPointer = & myFirstBlock.data.nextBlock;
      while ( s < myFirstBlock.size  )
        {
          *currentPointer = new AnyBlock( *nextBlock );
          s += M;
          currentPointer = & ( (*currentPointer)->next );
        }
      myLabels = other.myLabels;
    }
  return *this;
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
void
DGtal::LabelledMap<TData, L, TWord, N, M>::
clear()
{
  AnyBlock* nextBlock = myFirstBlock.data.nextBlock;
  while ( nextBlock != 0 )
    {
      AnyBlock* ptr = nextBlock;
      nextBlock = nextBlock->next;
      delete ptr;
    }
  myLabels.reset();
  myFirstBlock.data.nextBlock = 0;
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
typename DGtal::LabelledMap<TData, L, TWord, N, M>::SizeType
DGtal::LabelledMap<TData, L, TWord, N, M>::
size() const
{
  return myLabels.count();
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
bool
DGtal::LabelledMap<TData, L, TWord, N, M>::
empty() const
{
  return size() == 0;
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
typename DGtal::LabelledMap<TData, L, TWord, N, M>::SizeType
DGtal::LabelledMap<TData, L, TWord, N, M>::
max_size() const
{
  return L; //SizeType( -1 ) / (2*sizeof( Data ));
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
typename DGtal::LabelledMap<TData, L, TWord, N, M>::SizeType
DGtal::LabelledMap<TData, L, TWord, N, M>::
capacity() const
{
  return ( size() <= (N+1) )
    ? N+1
    : ( 1 + ( size() - 1 - N ) / M ) * M + N;
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
const typename DGtal::LabelledMap<TData, L, TWord, N, M>::Data &
DGtal::LabelledMap<TData, L, TWord, N, M>::
blockAt( unsigned int idx ) const
{
  ASSERT( idx < size() );
  if ( ( idx < N ) || ( ( idx == N ) && ( size() == N+1 ) ) )
    // Note here that we use contiguity between datas and data.lastData.
    return myFirstBlock.datas[ idx ];
  const AnyBlock* ptr = myFirstBlock.data.nextBlock;
  idx -= N;
  while ( idx > M )
    {
      idx -= M;
      ptr = ptr->next;
    }
  return ptr->datas[ idx ];
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
typename DGtal::LabelledMap<TData, L, TWord, N, M>::Data &
DGtal::LabelledMap<TData, L, TWord, N, M>::
blockAt( unsigned int idx )
{
  ASSERT( idx < size() );
  if ( ( idx < N ) || ( ( idx == N ) && ( size() == N+1 ) ) )
    // Note here that we use contiguity between datas and data.lastData.
    return myFirstBlock.datas[ idx ];
  AnyBlock* ptr = myFirstBlock.data.nextBlock;
  idx -= N;
  while ( idx > M )
    {
      idx -= M;
      ptr = ptr->next;
    }
  return ptr->datas[ idx ];
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
void
DGtal::LabelledMap<TData, L, TWord, N, M>::
insert( const Value & val )
{
  ASSERT( val.first < L ); 
  bool exists = myLabels.test( val.first );
  if ( ! exists ) 
    {
      SizeType block_size = size();
      myLabels.set( val.first );
      myFirstBlock.insert( myLabels.index( val.first ), block_size,
                           val.second );
    }
  else
    {
      blockAt( myLabels.index( val.first ) ) = val.second;
    }
}

//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
void
DGtal::LabelledMap<TData, L, TWord, N, M>::
blockInsert( unsigned int idx, const Data & data )
{
  ASSERT( idx <= size() ); // end is ok.
  myFirstBlock.insert( idx, data );
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
void
DGtal::LabelledMap<TData, L, TWord, N, M>::
blockErase( unsigned int idx )
{
  ASSERT( idx < size() ); // end is not ok.
  myFirstBlock.erase( idx );
}
// //-----------------------------------------------------------------------------
// template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
// inline
// typename DGtal::LabelledMap<TData, L, TWord, N, M>::Iterator
// DGtal::LabelledMap<TData, L, TWord, N, M>::
// begin()
// {
//   return Iterator( myLabels.begin(), blockBegin() );
// }
// //-----------------------------------------------------------------------------
// template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
// inline
// typename DGtal::LabelledMap<TData, L, TWord, N, M>::Iterator
// DGtal::LabelledMap<TData, L, TWord, N, M>::
// end()
// {
//   return Iterator( myLabels.end(), blockEnd() );
// }
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
typename DGtal::LabelledMap<TData, L, TWord, N, M>::ConstIterator
DGtal::LabelledMap<TData, L, TWord, N, M>::
begin() const
{
  return ConstIterator( myLabels.begin(), blockBegin() );
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
typename DGtal::LabelledMap<TData, L, TWord, N, M>::ConstIterator
DGtal::LabelledMap<TData, L, TWord, N, M>::
end() const
{
  return ConstIterator( myLabels.end(), blockEnd() );
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
typename DGtal::LabelledMap<TData, L, TWord, N, M>::BlockIterator
DGtal::LabelledMap<TData, L, TWord, N, M>::
blockBegin()
{
  return BlockIterator( myFirstBlock, 0, size() );
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
typename DGtal::LabelledMap<TData, L, TWord, N, M>::BlockIterator
DGtal::LabelledMap<TData, L, TWord, N, M>::
blockEnd()
{
  SizeType s = size();
  return BlockIterator( myFirstBlock, s, s );
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
typename DGtal::LabelledMap<TData, L, TWord, N, M>::BlockConstIterator
DGtal::LabelledMap<TData, L, TWord, N, M>::
blockBegin() const
{
  return BlockConstIterator( myFirstBlock, 0, size() );
}
//-----------------------------------------------------------------------------
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
typename DGtal::LabelledMap<TData, L, TWord, N, M>::BlockConstIterator
DGtal::LabelledMap<TData, L, TWord, N, M>::
blockEnd() const
{
  SizeType s = size();
  return BlockConstIterator( myFirstBlock, s, s );
}

///////////////////////////////////////////////////////////////////////////////
// Interface - public :

/**
 * Writes/Displays the object on an output stream.
 * @param out the output stream where the object is written.
 */
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
void
DGtal::LabelledMap<TData, L, TWord, N, M>::
selfDisplay( std::ostream & out ) const
{
  if ( size() == 0 ) out << "()";
  else
    {
      ConstIterator it = begin();
      ConstIterator it_end = end();
      out << "( ";
      out << "(" << (*it).first << "," << (*it).second << ")";
      ++it;
      for ( ; it != it_end; ++it )
	{
          out << ",(" << (*it).first << "," << (*it).second << ")";
	}
      out << " )";
    }
    // {
    //   BlockConstIterator it = blockBegin();
    //   BlockConstIterator it_end = blockEnd();
    //   BlockConstIterator it_last = it;
    //   out << "(";
    //   out << *it;
    //   ++it;
    //   for ( ; it != it_end; ++it )
    //     {
    //       out << ( ( it_last.myDatas == it.myDatas ) ? ',' : ';' );
    //       out << *it;
    //       it_last = it;
    //     }
    //   out << ")";
    // }
}

/**
 * Checks the validity/consistency of the object.
 * @return 'true' if the object is valid, 'false' otherwise.
 */
template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
bool
DGtal::LabelledMap<TData, L, TWord, N, M>::isValid() const
{
    return true;
}



///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions                                        //

template <typename TData, unsigned int L, typename TWord, unsigned int N, unsigned int M>
inline
std::ostream&
DGtal::operator<< ( std::ostream & out, 
		    const LabelledMap<TData, L, TWord, N, M> & object )
{
  object.selfDisplay( out );
  return out;
}

//                                                                           //
///////////////////////////////////////////////////////////////////////////////


