#pragma once

#include "NewDisplay3D.h"

template <typename>
struct is_vector : std::false_type {};
template <typename T, typename A>
struct is_vector<std::vector<T, A>> : std::true_type {};

template<typename Space, typename KSpace>
template<typename TIndices>
template<typename VType>
inline void DGtal::NewDisplay3D<Space, KSpace>::DisplayData<TIndices>::Append(
    std::span<VType> v, 
    std::span<TIndices> i,
    std::span<double> s
)
{
    const size_t N = vertices.size();

    vertices.resize(vertices.size() + v.size());
    for (size_t i = 0; i < v.size(); i++)
    {
        size_t d = 0;
        for (auto it = std::begin(v[i]); it != std::end(v[i]); ++it)
            vertices[N + i][d++] = *it;
    }

    // Try to automatically fill indices
    if (i.size() != 0)
    {
       indices.insert(indices.end(), i.begin(), i.end());
    }
    else
    {
        // For std::vector we need to resize first
        TIndices container;
        if constexpr (is_vector<TIndices>::value)
            container.resize(v.size());

        for (size_t i = 0; i < v.size(); i++)
            container[i] = N + i; 

        indices.push_back(std::move(container));
    }

    scalars.insert(scalars.end(), s.begin(), s.end());
}

template<typename Space, typename KSpace>
template<typename TData>
inline DGtal::NewDisplay3D<Space, KSpace>::DataGroup<TData>::DataGroup(
    const std::string& prefix, 
    const std::string& defaultGroup) : 
    prefix(prefix), defaultGroup(defaultGroup)
{ }

template<typename Space, typename KSpace>
template<typename TData>
inline void DGtal::NewDisplay3D<Space, KSpace>::DataGroup<TData>::NewGroup(
    const std::string& newGroup)
{
    const std::string* newPrefix = &prefix;
    
    std::string newGroupName = newGroup;
    bool shouldCreateWithPrefix = false;
    
    if (newGroupName.empty())
    {
        shouldCreateWithPrefix = true;
    }
    else if (groups.find(newGroupName) != groups.end())
    {
        shouldCreateWithPrefix = true;
        newPrefix = &newGroup;
    }

    if (shouldCreateWithPrefix)
    {
        uint32_t count = groups.size();
        
        // Safe guard if the user adds a group that would collide with existing name
        do
        {
            newGroupName = *newPrefix + std::to_string(count++);
        } while(groups.find(newGroupName) != groups.end());
    }
  
    SetCurrentGroup(newGroupName);
}
 
template<typename Space, typename KSpace>
template<typename TData>
inline void DGtal::NewDisplay3D<Space, KSpace>::DataGroup<TData>::SetDefaultGroup()
{
    SetCurrentGroup(defaultGroup);
}

template<typename Space, typename KSpace>
template<typename TData>
inline void DGtal::NewDisplay3D<Space, KSpace>::DataGroup<TData>::SetCurrentGroup(
    const std::string& group
)
{
    currentGroup = group;
}

template<typename Space, typename KSpace>
template<typename TData>
inline bool DGtal::NewDisplay3D<Space, KSpace>::DataGroup<TData>::IsDefaultGroupSelected() const
{
    if (currentGroup == defaultGroup)
        return true;
    return false;
}

template<typename Space, typename KSpace>
template<typename TData>
inline TData& DGtal::NewDisplay3D<Space, KSpace>::DataGroup<TData>::GetInsertData() 
{
    if (IsDefaultGroupSelected())
    {
        noGroup.push_back(TData{});
        return noGroup.back();
    }
    return groups[currentGroup];
}

template<typename Space, typename KSpace>
inline void DGtal::NewDisplay3D<Space, KSpace>::addClippingPlane(
    double a, double b, double c, double d
)
{
    double norm = std::sqrt(a * a + b * b + c * c);
    RealPoint n = {a / norm, b / norm, c / norm};
    RealPoint p = {0, 0, 0};
    if      (a != 0) p[0] = -d / a;
    else if (b != 0) p[1] = -d / b;
    else if (c != 0) p[2] = -d / c;
    
    planes.push_back({n, p, currentStyle});
}

template<typename Space, typename KSpace>
inline void DGtal::NewDisplay3D<Space, KSpace>::createNewGroup(
    const std::string& of, const std::string& s
)
{
         if (of == "lines")         lines.NewGroup(s);
    else if (of == "quads")         quads.NewGroup(s);
    else if (of == "prisms")       prisms.NewGroup(s);
    else if (of == "images")       images.NewGroup(s);
    else if (of == "points")       points.NewGroup(s);
    else if (of == "voxels")       voxels.NewGroup(s);
    else if (of == "polygons")   polygons.NewGroup(s);
    else if (of == "triangles") triangles.NewGroup(s); 
    else { trace.warning() << "Unknown type of group"; };
}

template<typename Space, typename KSpace>
inline void DGtal::NewDisplay3D<Space, KSpace>::endGroup(
    const std::string& of
)
{
         if (of == "lines")         lines.SetDefaultGroup();
    else if (of == "quads")         quads.SetDefaultGroup();
    else if (of == "prisms")       prisms.SetDefaultGroup();
    else if (of == "images")       images.SetDefaultGroup();
    else if (of == "points")       points.SetDefaultGroup();
    else if (of == "voxels")       voxels.SetDefaultGroup();
    else if (of == "polygons")   polygons.SetDefaultGroup();
    else if (of == "triangles") triangles.SetDefaultGroup();
    else { trace.warning() << "Unknown type of group"; };
}

template<typename Space, typename KSpace>
inline void DGtal::NewDisplay3D<Space, KSpace>::addQuad(
    const RealPoint& p1, const RealPoint& p2, 
    const RealPoint& p3, const RealPoint& p4
)
{
    RealPoint u = p2 - p1;
    RealPoint v = p3 - p2;
    RealPoint n = crossProduct(u, v);

    addQuadWithNormal(p1, p2, p3, p4, n);
}

template<typename Space, typename KSpace>
inline void DGtal::NewDisplay3D<Space, KSpace>::addQuadWithNormal(
    const RealPoint& p1, const RealPoint& p2, 
    const RealPoint& p3, const RealPoint& p4,
    const RealPoint& n
)
{
    RealPoint u = p2 - p1;
    RealPoint v = p3 - p2;
    RealPoint cn = DGtal::crossProduct(u, v);

    if (DGtal::dotProduct(n, cn) < 0)
        std::swap(p2, p4);
    
    auto& q = quads.GetInsertData();
    q.Append({ p1, p2, p3, p4 });
    if (quads.IsDefaultGroupSelected())
    {
        q.transform = Eigen::Affine3d::Identity();
        q.style = currentStyle;
    }
}

template<typename Space, typename KSpace>
inline void DGtal::NewDisplay3D<Space, KSpace>::addQuadFromSurfelCenter(
    const RealPoint &baseQuadCenter, 
    bool xSurfel, bool ySurfel, bool zSurfel
)
{  
    double x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4;

    if(zSurfel)
    {
        x1= baseQuadCenter[0]-0.5; y1= baseQuadCenter[1]-0.5; z1= baseQuadCenter[2]-0.5;
        x2= baseQuadCenter[0]+0.5; y2= baseQuadCenter[1]-0.5; z2= baseQuadCenter[2]-0.5;
        x3= baseQuadCenter[0]+0.5; y3= baseQuadCenter[1]+0.5; z3= baseQuadCenter[2]-0.5;
        x4= baseQuadCenter[0]-0.5; y4= baseQuadCenter[1]+0.5; z4= baseQuadCenter[2]-0.5;
    }
    else if(ySurfel)
    {
        x1= baseQuadCenter[0]-0.5; y1= baseQuadCenter[1]-0.5; z1= baseQuadCenter[2]-0.5;
        x2= baseQuadCenter[0]-0.5; y2= baseQuadCenter[1]-0.5; z2= baseQuadCenter[2]+0.5;
        x3= baseQuadCenter[0]+0.5; y3= baseQuadCenter[1]-0.5; z3= baseQuadCenter[2]+0.5;
        x4= baseQuadCenter[0]+0.5; y4= baseQuadCenter[1]-0.5; z4= baseQuadCenter[2]-0.5;
    }
    else
    {
        x1= baseQuadCenter[0]-0.5; y1= baseQuadCenter[1]-0.5; z1= baseQuadCenter[2]-0.5;
        x2= baseQuadCenter[0]-0.5; y2= baseQuadCenter[1]+0.5; z2= baseQuadCenter[2]-0.5;
        x3= baseQuadCenter[0]-0.5; y3= baseQuadCenter[1]+0.5; z3= baseQuadCenter[2]+0.5;
        x4= baseQuadCenter[0]-0.5; y4= baseQuadCenter[1]-0.5; z4= baseQuadCenter[2]+0.5;
    }

    addQuad(RealPoint(x1, y1, z1), RealPoint(x2 ,y2, z2),
            RealPoint(x3, y3, z3), RealPoint(x4, y4, z4));
}

template<typename Space, typename KSpace>
inline void DGtal::NewDisplay3D<Space, KSpace>::addQuadFromSurfelCenterWithNormal(
    const RealPoint &baseQuadCenter, bool xSurfel, bool ySurfel, bool zSurfel,
    const RealVector &aNormal,
    const bool enableReorientation,
    const bool sign,
    const bool enableDoubleFace
)
{    
    double x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4;

    if(zSurfel)
    {
        x1= baseQuadCenter[0]-0.5; y1= baseQuadCenter[1]-0.5; z1= baseQuadCenter[2]-0.5;
        x2= baseQuadCenter[0]+0.5; y2= baseQuadCenter[1]-0.5; z2= baseQuadCenter[2]-0.5;
        x3= baseQuadCenter[0]+0.5; y3= baseQuadCenter[1]+0.5; z3= baseQuadCenter[2]-0.5;
        x4= baseQuadCenter[0]-0.5; y4= baseQuadCenter[1]+0.5; z4= baseQuadCenter[2]-0.5;
    }
    else if(ySurfel)
    {
        x1= baseQuadCenter[0]-0.5; y1= baseQuadCenter[1]-0.5; z1= baseQuadCenter[2]-0.5;
        x2= baseQuadCenter[0]-0.5; y2= baseQuadCenter[1]-0.5; z2= baseQuadCenter[2]+0.5;
        x3= baseQuadCenter[0]+0.5; y3= baseQuadCenter[1]-0.5; z3= baseQuadCenter[2]+0.5;
        x4= baseQuadCenter[0]+0.5; y4= baseQuadCenter[1]-0.5; z4= baseQuadCenter[2]-0.5;
    }
    else
    {
        x1= baseQuadCenter[0]-0.5; y1= baseQuadCenter[1]-0.5; z1= baseQuadCenter[2]-0.5;
        x2= baseQuadCenter[0]-0.5; y2= baseQuadCenter[1]+0.5; z2= baseQuadCenter[2]-0.5;
        x3= baseQuadCenter[0]-0.5; y3= baseQuadCenter[1]+0.5; z3= baseQuadCenter[2]+0.5;
        x4= baseQuadCenter[0]-0.5; y4= baseQuadCenter[1]-0.5; z4= baseQuadCenter[2]+0.5;
    }

    addQuadWithNormal(RealPoint(x1, y1, z1), RealPoint(x2 ,y2, z2),
                      RealPoint(x3, y3, z3), RealPoint(x4, y4, z4), aNormal);

}

template<typename Space, typename KSpace>
inline void DGtal::NewDisplay3D<Space, KSpace>::addTriangle(
    const RealPoint &p1, 
    const RealPoint &p2, 
    const RealPoint &p3
)
{
    auto& t = triangles.GetInsertData();
    t.Append({ p1, p2, p3 });
    
    if (triangles.IsDefaultGroupSelected())
    {
        t.transform = Eigen::Affine3d::Identity();
        t.style = currentStyle;
    }
}

template<typename Space, typename KSpace>
inline void DGtal::NewDisplay3D<Space, KSpace>::addPolygon(const std::vector<RealPoint> &vertices)
{
    auto& p = polygons.GetInsertData();
    p.Append(vertices);
    
    if (polygons.IsDefaultGroupSelected())
    {
        p.transform = Eigen::Affine3d::Identity();
        p.style = currentStyle;
    }
}

template<typename Space, typename KSpace>
inline void DGtal::NewDisplay3D<Space, KSpace>::addLine(
    const RealPoint &p1, 
    const RealPoint &p2, 
    const double width
)
{
    auto& l = lines.GetInsertData();
    l.Append({ p1, p2 });
    
    if (lines.IsDefaultGroupSelected())
    {
        l.transform = Eigen::Affine3d::Identity();
        l.style = currentStyle;
    }
}

template<typename Space, typename KSpace>
inline void DGtal::NewDisplay3D<Space, KSpace>::addCube(const RealPoint &center, double width)
{
    static const RealPoint cubePositions[8] = {
        {-1, -1, -1}, 
        { 1, -1, -1},
        { 1,  1, -1},
        {-1,  1, -1},
        {-1, -1,  1}, 
        { 1, -1,  1},
        { 1,  1,  1},
        {-1,  1,  1}
    };

    const std::array<RealPoint, 8> points = {
        center + 0.5 * width * cubePositions[0], 
        center + 0.5 * width * cubePositions[1], 
        center + 0.5 * width * cubePositions[2], 
        center + 0.5 * width * cubePositions[3], 
        center + 0.5 * width * cubePositions[4], 
        center + 0.5 * width * cubePositions[5], 
        center + 0.5 * width * cubePositions[6], 
        center + 0.5 * width * cubePositions[7] 
    };

    auto& v = voxels.GetInsertData();

    // Template substitution fails if directly used
    v.template Append<const RealPoint>(points);
    
    if (voxels.IsDefaultGroupSelected())
    {
        v.transform = Eigen::Affine3d::Identity();
        v.style = currentStyle;
    }
}

template<typename Space, typename KSpace>
inline void DGtal::NewDisplay3D<Space, KSpace>::addBall(
    const RealPoint &center ,
    const double radius,
    const unsigned int resolution)
{
    auto& p = points.GetInsertData();
    p.Append({ center });
    
    if (center.IsDefaultGroupSelected())
    {
        p.transform = Eigen::Affine3d::Identity();
        p.style = currentStyle;
    }
}

template<typename Space, typename KSpace>
inline void DGtal::NewDisplay3D<Space, KSpace>::addPrism(
    const RealPoint &baseQuadCenter,
    bool xSurfel, bool ySurfel, bool zSurfel, double sizeShiftFactor,
    double sizeFactor, bool isSigned, bool aSign
)
{ 
    const double myCurrentfShiftVisuPrisms = 1.;
    updateBoundingBox(baseQuadCenter);
    double retract = 0.05*(sizeShiftFactor+myCurrentfShiftVisuPrisms);
    double width   = 0.03*(sizeShiftFactor+myCurrentfShiftVisuPrisms);


    double x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4;
    double x5, y5, z5, x6, y6, z6, x7, y7, z7, x8, y8, z8;
    double dx, dy, dz;


    ASSERT( xSurfel || ySurfel || zSurfel );
    boost::ignore_unused_variable_warning( xSurfel );

    if(zSurfel)
    {
        x1= baseQuadCenter[0]-(0.5*sizeFactor); y1= baseQuadCenter[1]-(0.5*sizeFactor); z1= baseQuadCenter[2]-0.5;
        x2= baseQuadCenter[0]+(0.5*sizeFactor); y2= baseQuadCenter[1]-(0.5*sizeFactor); z2= baseQuadCenter[2]-0.5;
        x3= baseQuadCenter[0]+(0.5*sizeFactor); y3= baseQuadCenter[1]+(0.5*sizeFactor); z3= baseQuadCenter[2]-0.5;
        x4= baseQuadCenter[0]-(0.5*sizeFactor); y4= baseQuadCenter[1]+(0.5*sizeFactor); z4= baseQuadCenter[2]-0.5;
        y1+=retract; y2+=retract; y3-=retract; y4-=retract;
        x1+=retract; x2-=retract; x3-=retract; x4+=retract;
        dx=0.0; dy=0.0; dz=width;
    }
    else if(ySurfel)
    {
        x1= baseQuadCenter[0]-(0.5*sizeFactor); y1= baseQuadCenter[1]-0.5; z1= baseQuadCenter[2]-(0.5*sizeFactor);
        x2= baseQuadCenter[0]-(0.5*sizeFactor); y2= baseQuadCenter[1]-0.5; z2= baseQuadCenter[2]+(0.5*sizeFactor);
        x3= baseQuadCenter[0]+(0.5*sizeFactor); y3= baseQuadCenter[1]-0.5; z3= baseQuadCenter[2]+(0.5*sizeFactor);
        x4= baseQuadCenter[0]+(0.5*sizeFactor); y4= baseQuadCenter[1]-0.5; z4= baseQuadCenter[2]-(0.5*sizeFactor);
        x1+=retract; x2+=retract; x3-=retract; x4-=retract;
        z1+=retract; z2-=retract; z3-=retract; z4+=retract;
        dx=0.0; dy=width; dz=0.0;
    }
    else
    {
        x1= baseQuadCenter[0]-0.5; y1= baseQuadCenter[1]-(0.5*sizeFactor); z1= baseQuadCenter[2]-(0.5*sizeFactor);
        x2= baseQuadCenter[0]-0.5; y2= baseQuadCenter[1]+(0.5*sizeFactor); z2= baseQuadCenter[2]-(0.5*sizeFactor);
        x3= baseQuadCenter[0]-0.5; y3= baseQuadCenter[1]+(0.5*sizeFactor); z3= baseQuadCenter[2]+(0.5*sizeFactor);
        x4= baseQuadCenter[0]-0.5; y4= baseQuadCenter[1]-(0.5*sizeFactor); z4= baseQuadCenter[2]+(0.5*sizeFactor);
        y1+=retract; y2-=retract; y3-=retract; y4+=retract;
        z1+=retract; z2+=retract; z3-=retract; z4-=retract;
        dx=width; dy=0.0; dz=0.0;
    }

    double xcenter= (x1+x2+x3+x4)/4.0;
    double ycenter= (y1+y2+y3+y4)/4.0;
    double zcenter= (z1+z2+z3+z4)/4.0;

    x5=x1-dx; y5=y1-dy; z5= z1-dz;
    x6=x2-dx; y6=y2-dy; z6= z2-dz;
    x7=x3-dx; y7=y3-dy; z7= z3-dz;
    x8=x4-dx; y8=y4-dy; z8= z4-dz;

    x1=x1+dx; y1=y1+dy; z1= z1+dz;
    x2=x2+dx; y2=y2+dy; z2= z2+dz;
    x3=x3+dx; y3=y3+dy; z3= z3+dz;
    x4=x4+dx; y4=y4+dy; z4= z4+dz;

    //if cell is oriented positively we retrac the upper face:
    if(isSigned && aSign)
    {
        x1= 0.6*x1+0.4*xcenter; x2= 0.6*x2+0.4*xcenter; x3= 0.6*x3+0.4*xcenter; x4= 0.6*x4+0.4*xcenter;
        y1= 0.6*y1+0.4*ycenter; y2= 0.6*y2+0.4*ycenter; y3= 0.6*y3+0.4*ycenter; y4= 0.6*y4+0.4*ycenter;
        z1= 0.6*z1+0.4*zcenter; z2= 0.6*z2+0.4*zcenter; z3= 0.6*z3+0.4*zcenter; z4= 0.6*z4+0.4*zcenter;
    }
    else if (isSigned)
    {
        x5= 0.6*x5+0.4*xcenter; x6= 0.6*x6+0.4*xcenter; x7= 0.6*x7+0.4*xcenter; x8= 0.6*x8+0.4*xcenter;
        y5= 0.6*y5+0.4*ycenter; y6= 0.6*y6+0.4*ycenter; y7= 0.6*y7+0.4*ycenter; y8= 0.6*y8+0.4*ycenter;
        z5= 0.6*z5+0.4*zcenter; z6= 0.6*z6+0.4*zcenter; z7= 0.6*z7+0.4*zcenter; z8= 0.6*z8+0.4*zcenter;
    }

    const std::array<std::array<RealPoint, 4>, 6> vertices = {
        { 
            RealPoint{ x1, y1, z1 }, 
            RealPoint{ x2, y2, z2 },
            RealPoint{ x3, y3, z3 }, 
            RealPoint{ x4, y4, z4 }
        },
        { 
            RealPoint{ x5, y5, z5 }, 
            RealPoint{ x8, y8, z8 },
            RealPoint{ x7, y7, z7 }, 
            RealPoint{ x6, y6, z6 }
        },
        { 
            RealPoint{ x1, y1, z1 }, 
            RealPoint{ x5, y5, z5 }, 
            RealPoint{ x6, y6, z6 },
            RealPoint{ x2, y2, z2 }
        },
        { 
            RealPoint{ x2, y2, z2 },
            RealPoint{ x6, y6, z6 },
            RealPoint{ x7, y7, z7 }, 
            RealPoint{ x3, y3, z3 }
        },
        { 
            RealPoint{ x3, y3, z3 }, 
            RealPoint{ x7, y7, z7 }, 
            RealPoint{ x8, y8, z8 },
            RealPoint{ x4, y4, z4 }
        }, 
        { 
            RealPoint{ x4, y4, z4 },
            RealPoint{ x8, y8, z8 },
            RealPoint{ x5, y5, z5 }, 
            RealPoint{ x1, y1, z1 }
        } 
    };
   
    createNewGroup("prisms", "Prism");
    auto& prism = prisms.GetInsertData();
    for (const auto& face : vertices)
        prism.append(face);

    if (prisms.IsDefaultSelected())
    {
        prism.transform = Eigen::Affine3d::Identity();
        prism.style = currentStyle;
    }

}

template<typename Space, typename KSpace>
inline void DGtal::NewDisplay3D<Space, KSpace>::addBasicSurfel(
    const RealPoint &baseQuadCenter,
    bool xSurfel, bool ySurfel, bool zSurfel
)
{
    ASSERT( xSurfel || ySurfel || zSurfel );
    boost::ignore_unused_variable_warning( xSurfel );

    double x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4;

    if(zSurfel)
    {
        x1= baseQuadCenter[0]-0.5; y1= baseQuadCenter[1]-0.5; z1= baseQuadCenter[2]-0.5;
        x2= baseQuadCenter[0]+0.5; y2= baseQuadCenter[1]-0.5; z2= baseQuadCenter[2]-0.5;
        x3= baseQuadCenter[0]+0.5; y3= baseQuadCenter[1]+0.5; z3= baseQuadCenter[2]-0.5;
        x4= baseQuadCenter[0]-0.5; y4= baseQuadCenter[1]+0.5; z4= baseQuadCenter[2]-0.5;
    }
    else if(ySurfel)
    {
        x1= baseQuadCenter[0]-0.5; y1= baseQuadCenter[1]-0.5; z1= baseQuadCenter[2]-0.5;
        x2= baseQuadCenter[0]-0.5; y2= baseQuadCenter[1]-0.5; z2= baseQuadCenter[2]+0.5;
        x3= baseQuadCenter[0]+0.5; y3= baseQuadCenter[1]-0.5; z3= baseQuadCenter[2]+0.5;
        x4= baseQuadCenter[0]+0.5; y4= baseQuadCenter[1]-0.5; z4= baseQuadCenter[2]-0.5;
    }
    else
    {
        x1= baseQuadCenter[0]-0.5; y1= baseQuadCenter[1]-0.5; z1= baseQuadCenter[2]-0.5;
        x2= baseQuadCenter[0]-0.5; y2= baseQuadCenter[1]+0.5; z2= baseQuadCenter[2]-0.5;
        x3= baseQuadCenter[0]-0.5; y3= baseQuadCenter[1]+0.5; z3= baseQuadCenter[2]+0.5;
        x4= baseQuadCenter[0]-0.5; y4= baseQuadCenter[1]-0.5; z4= baseQuadCenter[2]+0.5;
    }

    addQuad(RealPoint(x1, y1, z1), RealPoint(x2 ,y2, z2),
            RealPoint(x3, y3, z3), RealPoint(x4, y4, z4));
}

template<typename Space, typename KSpace>
inline void DGtal::NewDisplay3D<Space, KSpace>::addCone(
    const RealPoint &p1, const RealPoint &p2,
    double width
)
{
    int nbPoints = 6; //the number of point on the base of the cone
    double degree = 360 / nbPoints; // the angle between two points
    double radian = degree * M_PI/180.0;
    double norm; // norm of the vectors

    // A(x1,y1,z1) and B(x2,y2,z2) vector AB
    double xab, yab, zab;

    xab = p2[0]-p1[0];
    yab = p2[1]-p1[1];
    zab = p2[2]-p1[2];

    norm = sqrt( xab*xab + yab*yab + zab*zab);
    if (norm == 0) return;
    xab /= norm;
    yab /= norm;
    zab /= norm;

    //take a third point M different from A and B
    double xm = 0;
    double ym = 0;
    double zm = 0;

    while (p1[0] == xm || p2[0] ==xm) xm++;
    while (p1[1] == ym || p2[1] ==ym) ym++;
    while (p1[2] == zm || p2[2] ==zm) zm++;

    //vector AM
    double xam, yam, zam;
    //normal vector n = AB^AM
    double xn, yn, zn;

    // ensure that M is not collinear to AB
    while (true)
    {
        xam = xm-p1[0];
        yam = ym-p1[1];
        zam = zm-p1[2];

        norm = sqrt( xam*xam + yam*yam + zam*zam);
        ASSERT( norm > 0 );
        xam /= norm;
        yam /= norm;
        zam /= norm;

        xn = yab*zam - yam*zab;
        yn = xam*zab - xab*zam;
        zn = xab*yam - xam*yab;

        //divide n by its norm
        norm = sqrt( xn*xn + yn*yn + zn*zn);
        if (norm > 0) break;
        xm += .1;
        ym -= M_PI;
    }

    ASSERT( norm > 0 );
    xn /= norm;
    yn /= norm;
    zn /= norm;

    //the first point of the base
    double xf, yf, zf;

    xf = p2[0] + width * xn;
    yf = p2[1] + width * yn;
    zf = p2[2] + width * zn;

    //two following points of the base
    double xb1 = xf;
    double yb1 = yf;
    double zb1 = zf;
    double xb2,yb2, zb2;

    //r = AB^n for the future rotation
    double xr, yr, zr;

    createNewGroup("triangles", "Cone");
    for (int i =0; i < nbPoints-1; i ++)
    {
        // r = AB^n
        xr = yab*zn - yn*zab;
        yr = xn*zab - xab*zn;
        zr = xab*yn - xn*yab;

        //rotate n by degree
        xn = cos(radian)*xn + sin(radian)*xr;
        yn = cos(radian)*yn + sin(radian)*yr;
        zn = cos(radian)*zn + sin(radian)*zr;

        //divide n by its norm
        norm = sqrt( xn*xn + yn*yn + zn*zn);
        if (norm > 0)
        {
            xn = xn / norm;
            yn = yn / norm;
            zn = zn / norm;
        }

        // calculate one point with the normal vector at a distance width
        xb2 = p2[0] + width * xn;
        yb2 = p2[1] + width * yn;
        zb2 = p2[2] + width * zn;

        //adding the triangles associated with this point
        addTriangle(p1,
                  RealPoint(xb1, yb1, zb1),
                  RealPoint(xb2, yb2, zb2));
        addTriangle(p2,
                  RealPoint(xb1, yb1, zb1),
                  RealPoint(xb2, yb2, zb2));

        xb1 = xb2;
        yb1 = yb2;
        zb1 = zb2;
    }

    //Last part to close the cone
    addTriangle(p1,
          RealPoint(xb1, yb1,zb1),
          RealPoint(xf, yf, zf));
    addTriangle(p2,
          RealPoint(xb1, yb1, zb1),
          RealPoint(xf, yf, zf));
}

template<typename Space, typename KSpace>
inline void DGtal::NewDisplay3D<Space, KSpace>::addCylinder(
    const RealPoint  &p1, const RealPoint &p2,
    const double width
)
{
    int nbPoints = 6; //the number of point on the base of the cone
    double degree = 360 / nbPoints; // the angle between two points
    double radian = degree * M_PI/180.0;
    double norm; // norm of the vectors

    // A(p1[0],p1[1],p1[2]) and B(p2[0],p2[1],p2[2]) vector AB
    double xab, yab, zab;

    xab = p2[0]-p1[0];
    yab = p2[1]-p1[1];
    zab = p2[2]-p1[2];

    norm = sqrt( xab*xab + yab*yab + zab*zab);
    assert (norm > 0);
    xab = xab / norm;
    yab = yab / norm;
    zab = zab / norm;

    //take a third point M different from A and B
    double xm = 0;
    double ym = 0;
    double zm = 0;

    while (p1[0] == xm || p2[0] ==xm) xm++;
    while (p1[1] == ym || p2[1] ==ym) ym++;
    while (p1[2] == zm || p2[2] ==zm) zm++;

    //vector AM
    double xam, yam, zam;

    xam = xm-p1[0];
    yam = ym-p1[1];
    zam = zm-p1[2];

    norm = sqrt( xam*xam + yam*yam + zam*zam);
    assert (norm > 0);
    xam = xam / norm;
    yam = yam / norm;
    zam = zam / norm;

    //normal vector n = AB^AM
    double xn, yn, zn;

    xn = yab*zam - yam*zab;
    yn = xam*zab - xab*zam;
    zn = xab*yam - xam*yab;

    //divide n by its norm
    norm = sqrt( xn*xn + yn*yn + zn*zn);
    assert (norm > 0);
    xn = xn / norm;
    yn = yn / norm;
    zn = zn / norm;


    //the first point of the bases
    double xbf, ybf, zbf;
    double xaf, yaf, zaf;

    xbf = p2[0] + width * xn;
    ybf = p2[1] + width * yn;
    zbf = p2[2] + width * zn;

    xaf = p1[0] + width * xn;
    yaf = p1[1] + width * yn;
    zaf = p1[2] + width * zn;

    //two following points of the bases
    double xb1 = xbf;
    double yb1 = ybf;
    double zb1 = zbf;
    double xb2,yb2, zb2;

    double xa1 = xaf;
    double ya1 = yaf;
    double za1 = zaf;
    double xa2,ya2, za2;

    //r = AB^n for the future rotation
    double xr, yr, zr;

    createNewGroup("triangles", "Cylinder");
    //createNewQuadList("Cylinder");
    for (int i =0; i < nbPoints-1; i ++)
    {
        // r = AB^n
        xr = yab*zn - yn*zab;
        yr = xn*zab - xab*zn;
        zr = xab*yn - xn*yab;

        //rotate n by degree
        xn = cos(radian)*xn + sin(radian)*xr;
        yn = cos(radian)*yn + sin(radian)*yr;
        zn = cos(radian)*zn + sin(radian)*zr;

        //divide n by its norm (used when a bug appear)
        norm = sqrt( xn*xn + yn*yn + zn*zn);
        assert (norm > 0);
        xn = xn / norm;
        yn = yn / norm;
        zn = zn / norm;

        // calculate one point with the normal vector at a distance width
        xb2 = p2[0] + width * xn;
        yb2 = p2[1] + width * yn;
        zb2 = p2[2] + width * zn;

        xa2 = p1[0] + width * xn;
        ya2 = p1[1] + width * yn;
        za2 = p1[2] + width * zn;

        //adding the triangles and the quad associated with those poins
        addTriangle(p1,
                  RealPoint(xa1, ya1, za1),
                  RealPoint(xa2, ya2, za2));
        addTriangle(p2,
                  RealPoint(xb1, yb1, zb1),
                  RealPoint(xb2, yb2, zb2));
        addTriangle(
            RealPoint(xb1, yb1, zb1),     
            RealPoint(xb2, yb2, zb2),
            RealPoint(xa2, ya2, za2)
        );
        addTriangle(
            RealPoint(xa2, ya2, za2),
            RealPoint(xb1, yb1, zb1),     
            RealPoint(xa1, ya1, za1)
        );

        xb1 = xb2;
        yb1 = yb2;
        zb1 = zb2;

        xa1 = xa2;
        ya1 = ya2;
        za1 = za2;
    }

    //Last part to close the cylinder
    addTriangle(p1,
              RealPoint(xa1, ya1, za1),
              RealPoint(xaf, yaf, zaf));
    addTriangle(p2,
              RealPoint(xb1, yb1, zb1),
              RealPoint(xbf, ybf, zbf));
    addTriangle(
        RealPoint(xb1, yb1, zb1),
        RealPoint(xbf, ybf, zbf),
        RealPoint(xaf, yaf, zaf));
    addTriangle(
        RealPoint(xaf, yaf, zaf), 
        RealPoint(xb1, yb1, zb1),
        RealPoint(xa1, ya1, za1));
}

template < typename Space ,typename KSpace >
inline
typename DGtal::NewDisplay3D< Space ,KSpace >::RealPoint
DGtal::NewDisplay3D< Space ,KSpace >::embed( const typename Space::Point & dp ) const
{
  ASSERT( myEmbedder->isValid());
  return myEmbedder->embed(dp);
}

template < typename Space ,typename KSpace >
inline
typename DGtal::NewDisplay3D< Space ,KSpace >::RealPoint
DGtal::NewDisplay3D< Space ,KSpace >::embedKS( const typename KSpace::SCell & scell ) const
{
  ASSERT( mySCellEmbedder->isValid());
  return mySCellEmbedder->embed(scell);
}

template < typename Space ,typename KSpace >
inline
typename DGtal::NewDisplay3D< Space ,KSpace >::RealPoint
DGtal::NewDisplay3D< Space ,KSpace >::embedKS( const TransformedPrism & aTrans ) const
{
  ASSERT( mySCellEmbedder->isValid());
  return mySCellEmbedder->embed(aTrans.mySurfel);
}

template < typename Space ,typename KSpace >
inline
typename DGtal::NewDisplay3D< Space ,KSpace >::RealPoint
DGtal::NewDisplay3D< Space ,KSpace >::embedK( const typename KSpace::Cell & cell ) const
{
  ASSERT( myCellEmbedder->isValid());
  return myCellEmbedder->embed(cell);
}

