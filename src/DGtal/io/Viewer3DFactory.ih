
/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file   Viewer3DFactory.ih
 * @author Aline Martin <aline.martin@insa-lyon.fr>
 * @date   mardi 2 juillet 2013
 *
 * @brief
 *
 * Implementation of inline methods defined in Viewer3DFactory.h
 *
 * This file is part of the DGtal library.
 */


#include "DGtal/helpers/StdDefs.h"
#include "DGtal/images/ImageHelper.h"
#include "DGtal/io/Display3DFactory.h"


///////////////////////////////////////////////////////////////////////////////
// Implementation of inline methods                                          //


///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions and external operators                 //


inline
void DGtal::Viewer3DFactory::draw( Viewer3D & viewer,
                                    const DGtal::CameraPosition & cp )
{
  viewer.setCameraPosition(cp.eyex, cp.eyey, cp.eyez);
}

inline
void DGtal::Viewer3DFactory::draw( Viewer3D & viewer,
                                    const DGtal::CameraDirection & cd )
{
  viewer.setCameraDirection(cd.dirx, cd.diry, cd.dirz);
}

inline
void DGtal::Viewer3DFactory::draw( Viewer3D & viewer, const DGtal::CameraUpVector & cuv )
{

  viewer.setCameraUpVector(cuv.upx, cuv.upy, cuv.upz);
}

inline
void DGtal::Viewer3DFactory::draw( Viewer3D & viewer,
                                    const DGtal::CameraZNearFar & cz )
{
  viewer.setNearFar(cz.ZNear, cz.ZFar);
}


//----------------------------------------------------------------------------------------------
// heritage of methods


// SphericalAccumulator
/**
   * Display an spherical accumulator in 3D. Bin values are mapped
   * using a default HueShadeColorMap.
   *
   * @param viewer current viewer
   * @param accumulator the accumulator to viewer
   * @param shift translate vector for viewer purposes (default:
   * zero vector)
   * @param radius scale factor for the unit sphere radius (default:1)
   * @tparam TVector a vector model
   */
template <typename TVector>
inline
void
DGtal::Viewer3DFactory::draw( Viewer3D & viewer, const  DGtal::SphericalAccumulator<TVector> & accumulator,
                  const typename DGtal::SphericalAccumulator<TVector>::RealVector & shift,
                  const double radius)
{
  DGtal::Display3DFactory::draw ( viewer, accumulator, shift, radius);
}

// SphericalAccumulator

// Mesh
template <typename TPoint>
inline
void
DGtal::Viewer3DFactory::drawAsFaces( Viewer3D & viewer,  const DGtal::Mesh<TPoint> & aMesh )
{
  DGtal::Display3DFactory::drawAsFaces( viewer, aMesh);
}

template <typename TPoint>
inline
void
DGtal::Viewer3DFactory::draw( Viewer3D & viewer, const  DGtal::Mesh<TPoint> & aMesh )
{
  DGtal::Display3DFactory::draw (viewer, aMesh);
}

// Mesh

// ArithmeticalDSS3d
/**
   * Default DGtal::Viewer3DFactory::drawing style object.
   * @return the dyn. alloc. default style for this object.
   */
template <typename TIterator, typename TInteger, int connectivity>
inline
DGtal::DrawableWithViewer3D *
DGtal::Viewer3DFactory::defaultStyle( std::string str, const DGtal::ArithmeticalDSS3d<TIterator,TInteger,connectivity> & arithm )
{
  return DGtal::Display3DFactory::defaultStyle(str, arithm);
}

template <typename TIterator, typename TInteger, int connectivity>
inline
void
DGtal::Viewer3DFactory::drawAsBalls( Viewer3D & viewer, const DGtal::ArithmeticalDSS3d<TIterator,TInteger,connectivity> & arithm )
{
  DGtal::Display3DFactory::drawAsBalls(viewer, arithm);
}

template <typename TIterator, typename TInteger, int connectivity>
inline
void
DGtal::Viewer3DFactory::drawAsBoundingBox( Viewer3D & viewer, const DGtal::ArithmeticalDSS3d<TIterator,TInteger,connectivity> & arithm )
{
  DGtal::Display3DFactory::drawAsBoundingBox(viewer, arithm);
}

template <typename TIterator, typename TInteger, int connectivity>
inline
void
DGtal::Viewer3DFactory::draw( Viewer3D & viewer, const DGtal::ArithmeticalDSS3d<TIterator,TInteger,connectivity> & arithm )
{
  DGtal::Display3DFactory::draw(viewer , arithm);
}

// ArithmeticalDSS3d


// DigitalSetBySTLSet
/**
   * Default DGtal::Viewer3DFactory::drawing style object.
   * @return the dyn. alloc. default style for this object.
   */
template<typename Domain>
inline
DGtal::DrawableWithViewer3D *
DGtal::Viewer3DFactory::defaultStyle( std::string str, const DGtal::DigitalSetBySTLSet<Domain> & aSet )
{
  return DGtal::Display3DFactory::defaultStyle(str, aSet);
}

template<typename Domain>
inline
void
DGtal::Viewer3DFactory::drawAsPavingTransparent( Viewer3D & viewer, const DGtal::DigitalSetBySTLSet<Domain> & aSet )
{
  DGtal::Display3DFactory::drawAsPavingTransparent(viewer, aSet);
}

template<typename Domain>
inline
void
DGtal::Viewer3DFactory::drawAsPaving( Viewer3D & viewer, const DGtal::DigitalSetBySTLSet<Domain> & aSet )
{
  DGtal::Display3DFactory::drawAsPaving( viewer, aSet);
}

//TODO here
template<typename Domain>
inline
void
DGtal::Viewer3DFactory::drawAsGrid( Viewer3D & viewer, const DGtal::DigitalSetBySTLSet<Domain> & aSet )
{
  DGtal::Display3DFactory::drawAsGrid(viewer, aSet);
}

template<typename Domain>
inline
void
DGtal::Viewer3DFactory::draw( Viewer3D & viewer, const DGtal::DigitalSetBySTLSet<Domain> & aSet )
{
  DGtal::Display3DFactory::draw( viewer, aSet);
}

// DigitalSetBySTLSet


// DigitalSetBySTLVector
/**
   * Default DGtal::Viewer3DFactory::drawing style object.
   * @return the dyn. alloc. default style for this object.
   */
template<typename Domain>
inline
DGtal::DrawableWithViewer3D *
DGtal::Viewer3DFactory::defaultStyle( std::string str, const DGtal::DigitalSetBySTLVector<Domain> & aSet )
{
  DGtal::Display3DFactory::defaultStyle(str, aSet);
}

template<typename Domain>
inline
void
DGtal::Viewer3DFactory::drawAsPavingTransparent( Viewer3D & viewer, const DGtal::DigitalSetBySTLVector<Domain> & aSet )
{
  DGtal::Display3DFactory::drawAsPavingTransparent( viewer, aSet);
}

template<typename Domain>
inline
void
DGtal::Viewer3DFactory::drawAsPaving( Viewer3D & viewer, const DGtal::DigitalSetBySTLVector<Domain> & aSet )
{
  DGtal::Display3DFactory::drawAsPaving( viewer, aSet);
}

template<typename Domain>
inline
void
DGtal::Viewer3DFactory::drawAsGrid( Viewer3D & viewer, const DGtal::DigitalSetBySTLVector<Domain> & aSet )
{
  DGtal::Display3DFactory::drawAsGrid(viewer, aSet);
}

template<typename Domain>
inline
void
DGtal::Viewer3DFactory::draw( Viewer3D & viewer, const DGtal::DigitalSetBySTLVector<Domain> & aSet )
{
  DGtal::Display3DFactory::draw( viewer, aSet);
}

// DigitalSetBySTLVector


// HyperRectDomain
/**
   * Default DGtal::Viewer3DFactory::drawing style object.
   * @return the dyn. alloc. default style for this object.
   */
template<typename TSpace>
inline
DGtal::DrawableWithViewer3D *
DGtal::Viewer3DFactory::defaultStyle( std::string str, const DGtal::HyperRectDomain<TSpace> & aDomain )
{
  DGtal::Display3DFactory::defaultStyle( str, aDomain);
}

template<typename TSpace>
inline
void
DGtal::Viewer3DFactory::drawAsBoundingBox( Viewer3D & viewer, const DGtal::HyperRectDomain<TSpace> & aDomain )
{
  DGtal::Display3DFactory::drawAsBoundingBox( viewer, aDomain);
}

template<typename TSpace>
inline
void
DGtal::Viewer3DFactory::drawAsGrid( Viewer3D & viewer, const DGtal::HyperRectDomain<TSpace> & aDomain )
{
  DGtal::Display3DFactory::drawAsGrid( viewer, aDomain);
}

template<typename TSpace>
inline
void
DGtal::Viewer3DFactory::drawAsPavingBalls( Viewer3D & viewer, const DGtal::HyperRectDomain<TSpace> & aDomain )
{
  DGtal::Display3DFactory::drawAsPavingBalls( viewer, aDomain);
}

template<typename TSpace>
inline
void
DGtal::Viewer3DFactory::drawAsPaving( Viewer3D & viewer, const DGtal::HyperRectDomain<TSpace> & aDomain )
{
  DGtal::Display3DFactory::drawAsPaving( viewer, aDomain);
}

template<typename TSpace>
inline
void
DGtal::Viewer3DFactory::draw( Viewer3D & viewer, const DGtal::HyperRectDomain<TSpace> & aDomain )
{
  DGtal::Display3DFactory::draw( viewer, aDomain);
}

// HyperRectDomain


// KhalimskyCell
/**
   * Default DGtal::Viewer3DFactory::drawing style object.
   * @return the dyn. alloc. default style for this object.
   */
template < DGtal::Dimension dim, typename TInteger >
inline
DGtal::DrawableWithViewer3D *
DGtal::Viewer3DFactory::defaultStyle( std::string str, const DGtal::KhalimskyCell<dim, TInteger> & aCell )
{
  DGtal::Display3DFactory::defaultStyle(str, aCell);
}

template < DGtal::Dimension dim, typename TInteger >
inline
void
DGtal::Viewer3DFactory::draw( Viewer3D & viewer, const DGtal::KhalimskyCell<dim, TInteger> & aCell )
{
  DGtal::Display3DFactory::draw( viewer, aCell);
}

// KhalimskyCell


// Object
template <typename TDigitalTopology, typename TDigitalSet>
inline
DGtal::DrawableWithViewer3D *
DGtal::Viewer3DFactory::defaultStyle( std::string str, const DGtal::Object<TDigitalTopology, TDigitalSet> & anObject )
{
  DGtal::Display3DFactory::defaultStyle( str, anObject);
}

template <typename TDigitalTopology, typename TDigitalSet>
inline
void
DGtal::Viewer3DFactory::drawWithAdjacencies( Viewer3D & viewer, const DGtal::Object<TDigitalTopology, TDigitalSet> & anObject )
{
  DGtal::Display3DFactory::drawWithAdjacencies( viewer, anObject);
}

template <typename TDigitalTopology, typename TDigitalSet>
inline
void
DGtal::Viewer3DFactory::draw( Viewer3D & viewer, const DGtal::Object<TDigitalTopology, TDigitalSet> & anObject )
{
  DGtal::Display3DFactory::draw( viewer, anObject);
}

// Object


// PointVector
/**
   * Default DGtal::Viewer3DFactory::drawing style object.
   * @return the dyn. alloc. default style for this object.
   */
template< DGtal::Dimension dim, typename TComponent>
inline
DGtal::DrawableWithViewer3D *
DGtal::Viewer3DFactory::defaultStyle( std::string str, const DGtal::PointVector<dim,TComponent> & aPoint )
{
  DGtal::Display3DFactory::defaultStyle( str, aPoint);
}

template< DGtal::Dimension dim, typename TComponent>
inline
void
DGtal::Viewer3DFactory::drawAsGrid( Viewer3D & viewer, const DGtal::PointVector<dim,TComponent> & aPoint )
{
  DGtal::Display3DFactory::drawAsGrid( viewer, aPoint);
}

template< DGtal::Dimension dim, typename TComponent>
inline
void
DGtal::Viewer3DFactory::drawAsPaving( Viewer3D & viewer, const DGtal::PointVector<dim,TComponent> & aPoint )
{
  DGtal::Display3DFactory::drawAsPaving( viewer, aPoint);
}

template< DGtal::Dimension dim, typename TComponent>
inline
void
DGtal::Viewer3DFactory::drawAsPavingWired( Viewer3D & viewer, const DGtal::PointVector<dim,TComponent> & aPoint )
{
  DGtal::Display3DFactory::drawAsPavingWired( viewer, aPoint);
}

template< DGtal::Dimension dim, typename TComponent>
inline
void
DGtal::Viewer3DFactory::draw( Viewer3D & viewer, const DGtal::PointVector<dim,TComponent> & aPoint )
{
  DGtal::Display3DFactory::draw( viewer, aPoint);
}

template< DGtal::Dimension dim, typename TComponent>
inline
void
DGtal::Viewer3DFactory::draw( Viewer3D & viewer, const DGtal::PointVector<dim,TComponent> & aPoint, const DGtal::PointVector<dim,TComponent> & aPoint2 )
{
  DGtal::Display3DFactory::draw( viewer, aPoint, aPoint2);
}

// PointVector


// SignedKhalimskyCell
/**
   * Default DGtal::Viewer3DFactory::drawing style object.
   * @return the dyn. alloc. default style for this object.
   */
template< DGtal::Dimension dim, typename TInteger >
inline
DGtal::DrawableWithViewer3D *
DGtal::Viewer3DFactory::defaultStyle( std::string str, const DGtal::SignedKhalimskyCell<dim, TInteger> & aSCell )
{
  DGtal::Display3DFactory::defaultStyle( str, aSCell);
}

template< DGtal::Dimension dim, typename TInteger >
inline
void
DGtal::Viewer3DFactory::draw( Viewer3D & viewer, const DGtal::SignedKhalimskyCell<dim, TInteger> & aSCell )
{
  DGtal::Display3DFactory::draw( viewer, aSCell);
}

// SignedKhalimskyCell

// GridCurve
template< typename TKSpace >
inline
void
DGtal::Viewer3DFactory::draw( Viewer3D & viewer, const DGtal::GridCurve<TKSpace> & aGrid )
{
  DGtal::Display3DFactory::draw( viewer, aGrid);
}

// GridCurve

// SCellsRange
template < typename TIterator, typename TSCell >
inline
void
DGtal::Viewer3DFactory::draw( DGtal::Viewer3D & viewer,
                  const DGtal::ConstRangeAdapter<TIterator, DGtal::DefaultFunctor, TSCell> & aRangeAdapter )
{
  DGtal::Display3DFactory::draw( viewer, aRangeAdapter);
}

// SCellsRange

// PointsRange
template <typename TIterator, typename TKSpace>
inline
void
DGtal::Viewer3DFactory::draw( Viewer3D & viewer,
                  const DGtal::ConstRangeAdapter<TIterator, SCellToPoint<TKSpace>, typename TKSpace::Point> & aRangeAdapter )
{
  DGtal::Display3DFactory::draw( viewer, aRangeAdapter);
}

// PointsRange

// MidPointsRange
template <typename TIterator, typename TKSpace>
inline
void
DGtal::Viewer3DFactory::draw( Viewer3D & viewer,
                  const DGtal::ConstRangeAdapter<TIterator, SCellToMidPoint<TKSpace>, typename TKSpace::Space::RealPoint> & aRangeAdapter )
{
  DGtal::Display3DFactory::draw( viewer, aRangeAdapter);
}

// MidPointsRange

// ArrowsRange
template <typename TIterator, typename TKSpace>
inline
void
DGtal::Viewer3DFactory::draw( Viewer3D & viewer,
                  const DGtal::ConstRangeAdapter<TIterator, SCellToArrow<TKSpace>, std::pair<typename TKSpace::Point, typename TKSpace::Vector > > & aRangeAdapter )
{
  DGtal::Display3DFactory::draw( viewer, aRangeAdapter);
}

// ArrowsRange

// InnerPointsRange
template <typename TIterator, typename TKSpace>
inline
void
DGtal::Viewer3DFactory::draw( Viewer3D & viewer,
                  const DGtal::ConstRangeAdapter<TIterator, SCellToInnerPoint<TKSpace>, typename TKSpace::Point> & aRangeAdapter )
{
  DGtal::Display3DFactory::draw( viewer, aRangeAdapter);
}

// InnerPointsRange

// OuterPointsRange
template <typename TIterator, typename TKSpace>
inline
void
DGtal::Viewer3DFactory::draw( Viewer3D & viewer,
                  const DGtal::ConstRangeAdapter<TIterator, SCellToOuterPoint<TKSpace>, typename TKSpace::Point> & aRangeAdapter )
{
  DGtal::Display3DFactory::draw( viewer, aRangeAdapter);
}

// OuterPointsRange

// IncidentPointsRange
template <typename TIterator, typename TKSpace>
inline
void
DGtal::Viewer3DFactory::draw( Viewer3D & viewer,
                  const DGtal::ConstRangeAdapter<TIterator, SCellToIncidentPoints<TKSpace>,std::pair<typename TKSpace::Point, typename TKSpace::Point > > & aRangeAdapter )
{
  DGtal::Display3DFactory::draw( viewer, aRangeAdapter);
}

// IncidentPointsRange


// ImageContainerBySTLVector  (2D)
template <typename TValue>
inline
void
DGtal::Viewer3DFactory::draw( Viewer3D & viewer, const  ImageContainerBySTLVector<DGtal::Z2i::Domain, TValue>  & anImage )
{
  DGtal::Display3DFactory::draw( viewer, anImage);
}

// ImageContainerBySTLVector  (2D)

// ImageContainerBySTLMap  (2D)
template <typename TValue>
inline
void
DGtal::Viewer3DFactory::draw( Viewer3D & viewer, const  ImageContainerBySTLMap<DGtal::Z2i::Domain, TValue>  & anImage )
{
  DGtal::Display3DFactory::draw( viewer, anImage);
}

// ImageContainerBySTLMap  (2D)

// ConstImageAdapter  (2D)
template <typename TImageContainer, typename TFunctorD, typename TNewValue, typename TFunctorValue>
inline
void
DGtal::Viewer3DFactory::draw( Viewer3D & viewer, const  ConstImageAdapter<TImageContainer, DGtal::Z2i::Domain, TFunctorD, TNewValue, TFunctorValue>  & anImage )
{
  DGtal::Display3DFactory::draw( viewer, anImage);
}

// ConstImageAdapter  (2D)

// ImageAdapter  (2D)
template <typename TImageContainer, typename TFunctorD, typename TNewValue, typename TFunctorValue, typename TFunctorValueVm1>
inline
void
DGtal::Viewer3DFactory::draw( Viewer3D & viewer, const  ImageAdapter<TImageContainer, DGtal::Z2i::Domain, TFunctorD, TNewValue, TFunctorValue, TFunctorValueVm1>  & anImage )
{
  DGtal::Display3DFactory::draw( viewer, anImage);
}

// ImageAdapter  (2D)


// ImageContainerBySTLVector  (3D)
template <typename TValue  >
inline
void
DGtal::Viewer3DFactory::draw( Viewer3D & viewer, const ImageContainerBySTLVector<DGtal::Z3i::Domain, TValue>  & anImage )
{
  DGtal::Display3DFactory::draw( viewer, anImage);
}

// ImageContainerBySTLVector (3D)


// ImageContainerBySTLMap  (3D)
template <typename TValue  >
inline
void
DGtal::Viewer3DFactory::draw( Viewer3D & viewer, const ImageContainerBySTLMap<DGtal::Z3i::Domain, TValue>  & anImage )
{
  DGtal::Display3DFactory::draw( viewer, anImage);
}

// ImageContainerBySTLMap  (3D)

// ConstImageAdapter  (3D)
template <typename TImageContainer, typename TFunctorD, typename TNewValue, typename TFunctorValue>
inline
void
DGtal::Viewer3DFactory::draw( Viewer3D & viewer, const  ConstImageAdapter<TImageContainer, DGtal::Z3i::Domain, TFunctorD,
                  TNewValue, TFunctorValue>  & anImage )
{
  DGtal::Display3DFactory::draw( viewer, anImage);
}

// ConstImageAdapter  (3D)

// ImageAdapter  (3D)
template <typename TImageContainer, typename TFunctorD, typename TNewValue, typename TFunctorValue, typename TFunctorValueVm1>
inline
void
DGtal::Viewer3DFactory::draw( Viewer3D & viewer, const  ImageAdapter<TImageContainer, DGtal::Z3i::Domain, TFunctorD,
                  TNewValue, TFunctorValue, TFunctorValueVm1>  & anImage )
{
  DGtal::Display3DFactory::draw( viewer, anImage);
}

// ImageAdapter  (3D)


template < typename TImageType2D, typename TFunctor >
inline
void
DGtal::Viewer3DFactory::drawImage2D( Viewer3D & viewer, const TImageType2D & anImage, const TFunctor & aFunctor,
             Display3D::TextureMode aTextureMode )
{
  DGtal::Display3DFactory::drawImage2D( viewer, anImage, aFunctor, aTextureMode);
}


template < typename TImageType3D, typename TFunctor >
inline
void
DGtal::Viewer3DFactory::drawImage3D( Viewer3D & viewer, const TImageType3D & anImage3D, const TFunctor & aFunctor,
             Display3D::TextureMode aTextureMode)
{
  DGtal::Display3DFactory::drawImage3D( viewer, anImage3D, aFunctor, aTextureMode);
}

inline
void
DGtal::Viewer3DFactory::draw( Viewer3D & viewer, const DGtal::SetMode3D & aMode)
{
  DGtal::Display3DFactory::draw( viewer, aMode);
}

inline
void
DGtal::Viewer3DFactory::draw( Viewer3D & viewer, const DGtal::CustomStyle3D & aStyle)
{
  DGtal::Display3DFactory::draw( viewer, aStyle);
}

inline
void
DGtal::Viewer3DFactory::draw( Viewer3D & viewer, const DGtal::CustomColors3D & aColor)
{
  DGtal::Display3DFactory::draw( viewer, aColor);
}

inline
void
DGtal::Viewer3DFactory::draw( Viewer3D & viewer, const DGtal::ClippingPlane & aClipping)
{
  DGtal::Display3DFactory::draw( viewer, aClipping);
}


// AddTextureImage3DWithFunctor
template<typename TImageType, typename TFunctor>

void
DGtal::Viewer3DFactory::draw( Viewer3D & viewer, const DGtal::AddTextureImage3DWithFunctor<TImageType, TFunctor> & aFunctor )
{
  DGtal::Display3DFactory::draw( viewer, aFunctor);
}

// AddTextureImage3DWithFunctor

// AddTextureImage2DWithFunctor
template<typename TImageType, typename TFunctor>
void
DGtal::Viewer3DFactory::draw( Viewer3D & viewer, const DGtal::AddTextureImage2DWithFunctor<TImageType, TFunctor> & aFunctor )
{
  DGtal::Display3DFactory::draw ( viewer, aFunctor);
}
// AddTextureImage2DWithFunctor

inline
void
DGtal::Viewer3DFactory::draw( Viewer3D & viewer, const DGtal::UpdateImagePosition & anUpdate)
{
  DGtal::Display3DFactory::draw( viewer, anUpdate);
}

inline
void
DGtal::Viewer3DFactory::draw( Viewer3D & viewer, const DGtal::UpdateLastImagePosition & anUpdate )
{
  DGtal::Display3DFactory::draw( viewer, anUpdate);
}

inline
void
DGtal::Viewer3DFactory::draw( Viewer3D &viewer, const DGtal::Update2DDomainPosition & anUpdate)
{
  DGtal::Display3DFactory::draw( viewer, anUpdate);
}

inline
void
DGtal::Viewer3DFactory::draw( Viewer3D &viewer, const DGtal::Translate2DDomain & anTranslation)
{
  DGtal::Display3DFactory::draw( viewer, anTranslation);
}

template<typename TImageType, typename TFunctor>
void
DGtal::Viewer3DFactory::draw( Viewer3D & viewer, const DGtal::UpdateImageData<TImageType, TFunctor> & anUpdate)
{
  DGtal::Display3DFactory::draw( viewer, anUpdate);
}

inline
void
DGtal::Viewer3DFactory::draw( Viewer3D & viewer, const DGtal::TransformedSurfelPrism & aTransformedSurfelPrism)
{
  DGtal::Display3DFactory::draw( viewer, aTransformedSurfelPrism);
}


// end heritage
//----------------------------------------------------------------------------------------------




/*

template<typename TImageType, typename TFunctor>
inline
void
DGtal::Viewer3DFactory::draw( Viewer3D & viewer,  const DGtal::UpdateImageData<TImageType, TFunctor> & anUpdate )
{
  viewer.updateTextureImage(anUpdate.myIndex, *(anUpdate.myImage),  anUpdate.myFunctor, anUpdate.myTranslateX,
                            anUpdate.myTranslateY, anUpdate.myTranslateZ);

}


void
inline
DGtal::Viewer3DFactory::draw( Viewer3D & viewer,  const DGtal::UpdateImagePosition & anUpdate )
{
  viewer.updateOrientationTextureImage(anUpdate.myIndex, anUpdate.myPosXBottomLeft, anUpdate.myPosYBottomLeft,
                                       anUpdate.myPosZBottomLeft, anUpdate.myNewDirection);
}

void
inline
DGtal::Viewer3DFactory::draw( Viewer3D & viewer,  const DGtal::UpdateLastImagePosition & anUpdate )
{
  unsigned int index = viewer.getCurrentGLImageNumber()-1;
  viewer.updateOrientationTextureImage(index, anUpdate.myPosXBottomLeft, anUpdate.myPosYBottomLeft,
                                       anUpdate.myPosZBottomLeft, anUpdate.myNewDirection);
}


inline
void
DGtal::Viewer3DFactory::draw(Viewer3D &viewer, const DGtal::Update2DDomainPosition &anUpdate)
{
  viewer.updateAn2DDomainOrientation(anUpdate.myIndex, anUpdate.myPosXBottomLeft, anUpdate.myPosYBottomLeft,
                                     anUpdate.myPosZBottomLeft, anUpdate.myNewDirection);
}

inline
void
DGtal::Viewer3DFactory::draw(Viewer3D &viewer, const DGtal::Translate2DDomain &anTranslation){
  viewer.translateAn2DDomain(anTranslation.myIndex, anTranslation.myTranslateX, anTranslation.myTranslateY,
                             anTranslation.myTranslateZ);
}


inline
void  DGtal::Viewer3DFactory::draw( Viewer3D & viewer, const DGtal::TransformedSurfelPrism & aTransformedSurfelPrism)
{

  DGtal::Color fillColorSave = viewer.getFillColor();
  std::string mode = viewer.getMode( aTransformedSurfelPrism.mySurfel.className() );
  ASSERT((mode=="" || mode=="Highlighted" || mode=="Transparent" || mode=="Basic" || mode=="Illustration")||
         ("DGtal::Viewer3DFactory::draw( Viewer3D & viewer, const DGtal::ShiftedKSSurfel & aTransformedSurfelPrism ): Unknown mode "+mode)=="");
  // used to viewer surfels located at a same position.
  double factorVolSurfel=1.0;
  bool basicMode=false;
  if(mode=="Highlighted"){
    factorVolSurfel = 1.2;
    viewer.setFillColor(DGtal::Color(255, 50, 50, 255));
  }else if(mode=="Transparent"){
    viewer.setFillColor(DGtal::Color(180, 180, 250, 25));
  }else if(mode=="Basic"){
    basicMode=true;
  }
  //TODO remove x y z
  DGtal::Z3i::RealPoint rp ;// = viewer.embed(aTransformedSurfelPrism.mySurfel );

  float x =  NumberTraits<DGtal::int32_t>::castToDouble( aTransformedSurfelPrism.mySurfel.myCoordinates[0]  >> 1) ;
  float y =  NumberTraits<DGtal::int32_t>::castToDouble( aTransformedSurfelPrism.mySurfel.myCoordinates[1]  >> 1 );
  float z =  NumberTraits<DGtal::int32_t>::castToDouble( aTransformedSurfelPrism.mySurfel.myCoordinates[2]  >> 1 );

  rp[0] = x;
  rp[1] = y;
  rp[2] = z;
  bool xodd = ( aTransformedSurfelPrism.mySurfel.myCoordinates[ 0 ] & 1 );
  bool yodd = ( aTransformedSurfelPrism.mySurfel.myCoordinates[ 1 ] & 1 );
  bool zodd = ( aTransformedSurfelPrism.mySurfel.myCoordinates[ 2 ] & 1 );

  unsigned int spaceDim= (xodd ? 1:0) + (yodd ? 1:0) + (zodd ? 1:0);
  ASSERT(spaceDim==2);
  if (basicMode)
  {
    //TODO viewer quad
    viewer.addQuad(rp[0], rp[1], rp[2],! xodd, !yodd, !zodd, factorVolSurfel,
        aTransformedSurfelPrism.mySizeFactor,
        true, aTransformedSurfelPrism.mySurfel.myPositive);
  }
  else
  {
    viewer.addSurfelPrism(rp[0], rp[1], rp[2],! xodd, !yodd, !zodd, factorVolSurfel,
        aTransformedSurfelPrism.mySizeFactor,
        true, aTransformedSurfelPrism.mySurfel.myPositive);
  }

  viewer.setFillColor(fillColorSave);

}

*/
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
