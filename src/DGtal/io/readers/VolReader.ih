/**
 * @file VolReader.ih
 * @author David Coeurjolly (\c david.coeurjolly@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Syst√®mes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 *
 * @date 2010/07/25
 *
 * Implementation of inline methods defined in VolReader.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// ----------------------- Standard services ------------------------------

/**
 * Destructor.
 */
template <typename T>
inline
DGtal::VolReader<T>::VolReader()
{
}

/**
 * Destructor.
 */
template <typename T>
inline
DGtal::VolReader<T>::~VolReader()
{
}


///////////////////////////////////////////////////////////////////////////////
// Interface - public :

/**
 * Writes/Displays the object on an output stream.
 * @param out the output stream where the object is written.
 */
template <typename T>
inline
T &
DGtal::VolReader<T>::importVol (const std::string & filename )
{
  FILE * fin;
  int errcode;
  T  *image;

  fin = fopen( filename.c_str() , "r" );

  if (fin == NULL) 
      trace.error() << "VolReader : can't open "<< filename<<endl;
  
  image = readVolData( fin );
  fclose( fin );
 
  return (*image);
}

///////////////////////////////////////////////////////////////////////////////
// Interface - Private :


template <typename T>
T *
DGtal::VolReader<T>::readVolData( FILE *fin ) 
{
  // Read header
  // Buf for a line 
  char buf[128];
  int linecount = 1;
  int fieldcount = 0;
	
  // Read the file line by line until ".\n" is found
  for (	char *line = fgets( buf, 128, fin );
	line && strcmp( line, ".\n" ) != 0 ; 
	line = fgets( line, 128, fin ), ++linecount
	) 
    {
      
      if (line[strlen(line) - 1] != '\n') 
	{
	  trace.error() << "VolReader: Line "<< linecount << " too long" << std::endl;
	  return NULL;
	}
    
      int i;
      for (i = 0; line[i] && line[i] != ':'; ++i);

      if (i == 0 || i >= 126 || line[i] != ':') 
	{
	  trace.error() << "VolReader: Invalid header read at line "<< linecount << std::endl;
	  return NULL;
	} 
      else 
	{
		
	  if (fieldcount == MAX_HEADERNUMLINES) {
	    trace.warning() << "VolReader: Too many lines in HEADER, ignoring\n";
	    continue;
	  }
	  if (fieldcount > MAX_HEADERNUMLINES)
	    continue;
	  
	  // Remove \n from end of line
	  if (line[ strlen(line) - 1 ] == '\n')
	    line[ strlen(line) - 1 ] = 0;
	  
	  // hack : split line in two str ...
	  line[i] = 0;
	  header[ fieldcount++ ] = HeaderField( line, line + i + 2 ); 
	  // +2 cause we skip the space
	  // following the colon
	}     
    }

  // Check required headers
  for (int i = 0; requiredHeaders[i]; ++i) 
    {
      if (getHeaderValue( "Version" ) != NULL && 
	  (strcmp( requiredHeaders[i], "Int-Endian" ) == 0 || 
	   strcmp( requiredHeaders[i], "Voxel-Endian" ) == 0)) 
	{
	  continue;
	}
      if (getHeaderField( requiredHeaders[i] ) == -1) {
	trace.error() << "VolReader: Required Header Field missing: "
		      << requiredHeaders[i] <<std::endl;
	return NULL;
      }
    }
  
  int sx,sy,sz;

  getHeaderValueAsInt("X", &sx);
  getHeaderValueAsInt("Y", &sy);
  getHeaderValueAsInt("Z", &sz);
  
  if (getHeaderValue( "Version" ) != NULL ) 
    { 
      // Field Version appeared only in v2
      return readV2RawData( fin, true, sx, sy, sz );
    }
  return readV1RawData( fin, true );
}


template <typename T>
T *
DGtal::VolReader<T>::readV1RawData( FILE *fin, bool headerInited ) {

  int count = 0;
  int rawsx, rawsy, rawsz;
  int sx,sy,sz;

  // Size of the volume
  count += fread( &rawsx, sizeof(int), 1, fin );
  count += fread( &rawsy, sizeof(int), 1, fin );
  count += fread( &rawsz, sizeof(int), 1, fin );

  if (count != 3) 
    {
      trace.error() << "VolReader: can't read file (raw header)\n";
      return NULL;
    }

  if (headerInited) 
    {		
      // The raw header contains the volume size too	
      getHeaderValueAsInt("X", &sx);
      getHeaderValueAsInt("Y", &sy);
      getHeaderValueAsInt("Z", &sz);

      if (sx != rawsx || sy != rawsy || sz != rawsz) 
	{
	  trace.warning() << "VolReader: Warning : Incoherent vol header with raw header !\n";
	}
	
      int voxsize;
      if (getHeaderValueAsInt( "Voxel-Size", &voxsize ) == 0 && voxsize != sizeof(voxel)) 
	{
	  trace.error() << "VolReader: This file was generated with a voxel-size that we do not support.\n";
	  return NULL;
	}
    
    }
	
  // We should have a useless \n in the file at this point
  char tmp;
  count = fread( &tmp, sizeof(char), 1, fin );

  if (count != 1 || tmp != '\n') 
    {
      trace.error()<< "VolReader: I thouhgt I would have read a \\n !\n";
      return NULL;
    }

  return readV2RawData( fin, headerInited, sx, sy, sz );
}

template <typename T>
T *
DGtal::VolReader<T>::readV2RawData( FILE *fin, bool headerInited, 
				    int sizeX, int sizeY, int sizeZ)
{
  long count = 0;
  T *image;
  int sx,sy,sz;
	
  // now read the raw data
  sx = sizeX;
  sy = sizeY;
  sz = sizeZ;
	
  typename T::Point firstPoint;
  typename T::Point lastPoint;
      
  firstPoint = T::Point::zero;
  lastPoint[0] = sx-1;      
  lastPoint[1] = sy-1;
  lastPoint[2] = sz-1;
  typename T::Domain domain(firstPoint,lastPoint);

  try 
    {
      image = new T(firstPoint,lastPoint);
    }
  catch (...) 
    {
      trace.error()<< "VolReader: not enough memory\n" ;
      return NULL;
    }
	
  count = 0;
  unsigned char val;
  typename T::Domain::ConstIterator it = domain.begin();
  long int total = sx*sy*sz;
  
  while ((count < total) && (fin))
    {
      val = getc(fin);  
      image->setValue( (*it),val);
      it++;
      count++;
    }
  
  if (count != total) 
    {
      trace.error()<< "VolReader: can't read file (raw data) !\n";
      return NULL;
    }

  return image;
}

template <typename T>
const char *DGtal::VolReader<T>::requiredHeaders[] = {
  "X", "Y", "Z", "Voxel-Size", "Int-Endian", "Voxel-Endian", "Alpha-Color", NULL
};




template<typename T>
int 
DGtal::VolReader<T>::getHeaderField( const char *type ) const
{

  ASSERT( myStateOk );

  for (int i = 0; i < MAX_HEADERNUMLINES; ++i) {
    if (header[i].type != NULL && strcmp( header[i].type, type ) == 0 ) {
      return i;
    }
  }
  return -1;
}


template<typename T>
const char *
DGtal::VolReader<T>::getHeaderValue( const char *type ) const
{

  int i = getHeaderField( type );
  if (i == -1)
    return NULL;
  return header[i].value;

}


template<typename T>
int 
DGtal::VolReader<T>::getHeaderValueAsInt( const char *type, int *dest ) const
{

  ASSERT( myStateOk );

  int i = getHeaderField( type );
  if (i == -1)
    return 1;

  return sscanf( header[i].value, "%d", dest ) != 0;
}

