/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file VolReader.ih
 * @author David Coeurjolly (\c david.coeurjolly@liris.cnrs.fr )
 * Laboratoire d'InfoRmatique en Image et Syst√®mes d'information - LIRIS (CNRS, UMR 5205), CNRS, France
 *
 * @date 2010/07/25
 *
 * Implementation of inline methods defined in VolReader.h
 *
 * This file is part of the DGtal library.
 */


//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>

#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wall"
#pragma GCC diagnostic ignored "-Wextra"
#pragma GCC diagnostic ignored "-Wpedantic"
#pragma GCC diagnostic ignored "-Wshadow"
#pragma GCC diagnostic ignored "-Wtype-limits"
#pragma GCC diagnostic ignored "-Wtautological-compare"
#endif
#include <boost/iostreams/filtering_streambuf.hpp>
#include <boost/iostreams/copy.hpp>
#include <boost/iostreams/filter/zlib.hpp>
#if defined(__GNUC__) || defined(__clang__)
#pragma GCC diagnostic pop
#endif


//////////////////////////////////////////////////////////////////////////////
// Interface - public : VolHeader
bool DGtal::VolHeader::parse(std::istream& in) {
  std::string line;

  while (std::getline(in, line)) {
    if (!line.empty() && line.back() == '.')
      return true;

    auto split = line.find(':');
    if (split == std::string::npos) {
      // Throw here for unknown line ?
      trace.warning() << "VolReader: unrecognized line \"" << line << "\"" << std::endl;
      continue;
    }

    std::string key = line.substr(0, split);
    std::string val = line.substr(split + 1);

    // Trim value
    auto start = val.find_first_not_of(" \t\r");
    auto end   = val.find_last_not_of(" \t\r");
    if (start == std::string::npos) {
      // Invalid value (all spaces)
      trace.error() << "VolReader : invalid (empty) value for line \"" << line << "\"" << std::endl;
      throw DGtal::IOException{};
    }
    myFields[key] = val.substr(start, end - start + 1);
  }

  return false;
}

bool DGtal::VolHeader::validate() const {
  for (unsigned int i = 0; i < requiredFieldsCount; ++i) {
    if (!exists(requiredFields[i])) 
      return false;
  }
  return true;
}

template<typename T>
T DGtal::VolHeader::getAs(const std::string& name) const {
  auto it = myFields.find(name);
  if (it == myFields.end()) {
    // Field does not exist
    trace.error() << "VolReader: No such field \"" << name << "\"" << std::endl;
    throw DGtal::IOException{};
  }

  if constexpr (std::is_same_v<T, std::string>) {
    return it->second;
  } else {
    std::istringstream iss(it->second);

    T result;
    iss >> result;

    if (iss.fail() || !iss.eof()) {
      // Invalid type / value
      trace.error() << "VolReader: Can't convert \"" << name << "\" to desired type" << std::endl;
      throw DGtal::IOException{};
    }

    return result;
  }
}

bool DGtal::VolHeader::exists(const std::string& field) const {
  return myFields.find(field) != myFields.end();
}

///////////////////////////////////////////////////////////////////////////////
// Interface - public :
//

template <typename T, typename TFunctor>
inline
T
DGtal::VolReader<T, TFunctor>::importVol( const std::string & filename,
                                         const Functor & aFunctor)
{
  DGtal::IOException dgtalexception;
  std::ifstream file(filename.c_str(), std::ios_base::binary);

  if (!file.is_open()) 
  {
    trace.error() << "VolReader : can't open " << filename << std::endl;
    throw dgtalexception;
  }

  VolHeader header;
  header.parse(file);

  if (!header.validate()) 
  {
    trace.error() << "VolReader : Invalid header " << filename << std::endl;
    throw dgtalexception;
  }

  typename T::Point firstPoint( 0, 0, 0 );
  typename T::Point lastPoint( 0, 0, 0 );

  int sx = header.getAs<int>("X");
  int sy = header.getAs<int>("Y");
  int sz = header.getAs<int>("Z");
  int version = header.getAs<int>("Version");

  if (! ((version == 2) || (version == 3)))
  {
    trace.error() << "VolReader: invalid Version header (must be either 2 or 3)\n";
    throw dgtalexception;
  }

  if (header.exists("Center-X")) 
  {
    int cx = header.getAs<int>("Center-X");
    int cy = header.getAs<int>("Center-Y");
    int cz = header.getAs<int>("Center-Z");

    firstPoint[0] = cx - (sx - 1)/2;
    firstPoint[1] = cy - (sy - 1)/2;
    firstPoint[2] = cz - (sz - 1)/2;
    lastPoint[0] = cx + sx/2;
    lastPoint[1] = cy + sy/2;
    lastPoint[2] = cz + sz/2;
  }
  else
  {
    firstPoint = T::Point::zero;
    lastPoint[0] = sx - 1;
    lastPoint[1] = sy - 1;
    lastPoint[2] = sz - 1;
  }

  typename T::Domain domain( firstPoint, lastPoint );

  try
  {
    T image( domain );

    typename T::Domain::ConstIterator it = domain.begin();
    size_t total = sx * sy * sz;

    //Uncompress if needed
    if(version == 3)
    {
      std::stringstream uncompressed;
      boost::iostreams::filtering_streambuf<boost::iostreams::input> in;
      in.push(boost::iostreams::zlib_decompressor());
      in.push(file);
      boost::iostreams::copy(in, uncompressed);
      //Apply to the image structure
      for(size_t i=0; i < total; ++i)
      {
        image.setValue(( *it ), aFunctor(uncompressed.get()) );
        it++;
      }
    }
    else
    {
      //Apply to the image structure
      for(size_t i=0; i < total; ++i)
      {
        image.setValue(( *it ), aFunctor(file.get()) );
        it++;
      }
    }
    return image;
  }
  catch ( ... )
  {
    trace.error() << "VolReader: not enough memory\n" ;
    throw dgtalexception;
  }
}

template <typename Space, typename Functor>
inline
DGtal::DigitalSetByOctree<Space>
DGtal::VolReader<DGtal::DigitalSetByOctree<Space>, Functor>::importVol( 
    const std::string & filename,
    const Functor & unused
) 
{
  using Octree = DGtal::DigitalSetByOctree<Space>;
  using Point = typename Space::Point;

  DGtal::IOException dgtalexception;
  std::ifstream file(filename.c_str(), std::ios_base::binary);

  if (!file.is_open()) 
  {
    trace.error() << "VolReader : can't open " << filename << std::endl;
    throw dgtalexception;
  }

  VolHeader header;
  header.parse(file);

  if (!header.validate()) 
  {
    trace.error() << "VolReader : Invalid header " << filename << std::endl;
    throw dgtalexception;
  }

  Point firstPoint( 0, 0, 0 );
  Point lastPoint( 0, 0, 0 );

  int sx = header.getAs<int>("X");
  int sy = header.getAs<int>("Y");
  int sz = header.getAs<int>("Z");
  int version = header.getAs<int>("Version");

  if (! ((version == 2) || (version == 3)))
  {
    trace.error() << "VolReader: invalid Version header (must be either 2 or 3)\n";
    throw dgtalexception;
  }

  if (header.exists("Center-X")) 
  {
    int cx = header.getAs<int>("Center-X");
    int cy = header.getAs<int>("Center-Y");
    int cz = header.getAs<int>("Center-Z");

    firstPoint[0] = cx - (sx - 1)/2;
    firstPoint[1] = cy - (sy - 1)/2;
    firstPoint[2] = cz - (sz - 1)/2;
    lastPoint[0] = cx + sx/2;
    lastPoint[1] = cy + sy/2;
    lastPoint[2] = cz + sz/2;
  }
  else
  {
    firstPoint = Point::zero;
    lastPoint[0] = sx - 1;
    lastPoint[1] = sy - 1;
    lastPoint[2] = sz - 1;
  }

  typename Octree::Domain domain( firstPoint, lastPoint );
  
  try
  {
    Octree octree( domain );
    std::stringstream uncompressed;
    std::istream* input = &file;

    //Uncompress if needed
    if(version == 3)
    {
      boost::iostreams::filtering_streambuf<boost::iostreams::input> in;
      in.push(boost::iostreams::zlib_decompressor());
      in.push(file);
      boost::iostreams::copy(in, uncompressed);
      
      input = &uncompressed;
    }

    int state;
    input->read(reinterpret_cast<char*>(&state), sizeof(int));
    octree.myState = static_cast<Octree::State>(state);

    size_t size;
    input->read(reinterpret_cast<char*>(&size), sizeof(size_t));

    size_t depth;
    input->read(reinterpret_cast<char*>(&depth), sizeof(size_t));

    if (depth != octree.myNodes.size()) {
      trace.error() << "VolReader: integrity error, saved depth does not match domain" << std::endl;
      throw dgtalexception;
    }

    for (unsigned int i = 0; i < depth; ++i) {
      size_t count; 
      input->read(reinterpret_cast<char*>(&count), sizeof(size_t));
      octree.myNodes[i].resize(count);
    }

    using Int = typename Octree::CellIndex;
    for (unsigned int i = 0; i < depth; ++i) {
      for (unsigned int j = 0; j < octree.myNodes[i].size(); ++j) {
        for (unsigned int k = 0; k < octree.CELL_COUNT; ++k) {
          Int child;
          input->read(reinterpret_cast<char*>(&child), sizeof(Int));
          octree.myNodes[i][j].children[k] = child;
        }
      }
    }
    return octree;
  }
  catch ( ... )
  {
    trace.error() << "VolReader: not enough memory\n" ;
    throw dgtalexception;
  }
}
