/**
 * This program is free software: you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file Display3D.ih
 * @author Bertrand Kerautret (\c kerautre@loria.fr )
 * LORIA (CNRS, UMR 7503), University of Nancy, France
 *
 * @date 2011/08/08
 *
 * Implementation of inline methods defined in Display3D.h
 *
 * This file is part of the DGtal library.
 */

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
#include <cmath>
#include "DGtal/io/CDrawableWithDisplay3D.h"
#include "DGtal/io/Display3DFactory.h"
#include "DGtal/io/writers/MeshWriter.h"


//tmp
#include <iostream>

//////////////////////////////////////////////////////////////////////////////


#define PI 3.14159265

///////////////////////////////////////////////////////////////////////////////
// Implementation of inline methods //


// //
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions and external operators //


template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::setFillColor(DGtal::Color aColor)
{
  myCurrentFillColor=aColor;
}

template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::setFillTransparency(unsigned char alpha)
{
  myCurrentFillColor.alpha(alpha);
}

template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::setLineColor(DGtal::Color aColor)
{
  myCurrentLineColor=aColor;
}

template < typename Space ,typename KSpace >
inline
DGtal::Color
DGtal::Display3D< Space ,KSpace >::getLineColor()
{
  return myCurrentLineColor;
}

template < typename Space ,typename KSpace >
inline
DGtal::Color
DGtal::Display3D< Space ,KSpace >::getFillColor()
{
  return myCurrentFillColor;
}

template < typename Space ,typename KSpace >
inline
std::string
DGtal::Display3D< Space ,KSpace >::getMode( const std::string & objectName ) const
{
  ModeMapping::const_iterator itm = myModes.find( objectName );
  return itm == myModes.end() ? "" : itm->second;
}


template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::createNewCubeList( std::string str)
{
  std::vector< CubeD3D > v;
  myCubeSetList.push_back(v);
  myCubeSetNameList.push_back(str);
}


template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::createNewBallList(std::string str)
{
  std::vector< BallD3D > v;
  myBallSetList.push_back(v);
  myBallSetNameList.push_back(str);
}

template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::createNewLineList(std::string str)
{
  std::vector< LineD3D > v;
  myLineSetList.push_back(v);
  myLineSetNameList.push_back(str);
}

template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::createNewQuadList(std::string str)
{
  std::vector< QuadD3D > v;
  myQuadSetList.push_back(v);
  myQuadSetNameList.push_back(str);
}

template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::createNewTriangleList(std::string str)
{
  std::vector< TriangleD3D > v;
  myTriangleSetList.push_back(v);
  myTriangleSetNameList.push_back(str);
}

template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::createNewPolygonList(std::string str)
{
  std::vector< PolygonD3D > v;
  myPolygonSetList.push_back(v);
  myPolygonSetNameList.push_back(str);
}


template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::addCube(double x, double y, double z, double width)
{
  //because the width in the cube parameters is actually the distance between the center and the faces
  width = width/2;
  DGtal::Color aColor = getFillColor();

  updateBoundingBox((double)x, (double)y, (double)z);
  CubeD3D v;
  v.x=x;
  v.y=y;
  v.z=z;
  v.R=aColor.red();
  v.G=aColor.green();
  v.B=aColor.blue();
  v.T=aColor.alpha();
  v.width=width;

  if (myCubeSetList.size() ==0)
    createNewCubeList("Cube Root");

  (myCubeSetList.at(myCubeSetList.size()-1)).push_back(v);
}


template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::addBall(double x, double y, double z, double size)
{
  updateBoundingBox(x, y, z);
  DGtal::Color aColor = getFillColor();
  BallD3D p;
  p.x=x;
  p.y=y;
  p.z=z;


  p.R=aColor.red();
  p.G=aColor.green();
  p.B=aColor.blue();
  p.T=aColor.alpha();
  p.isSigned=false;
  p.signPos=false;
  p.size=size;

  if (myBallSetList.size()== 0)
    createNewBallList("Ball Root");

  (myBallSetList.at(myBallSetList.size()-1)).push_back(p);
}



template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::addLine(double x1, double y1, double z1, double x2, double y2, double z2, double width)
{
  updateBoundingBox(x1, y1, z1);
  updateBoundingBox(x2, y2, z2);
  DGtal::Color aColor = getLineColor();
  LineD3D l;
  l.x1=x1;
  l.y1=y1;
  l.z1=z1;

  l.x2=x2;
  l.y2=y2;
  l.z2=z2;

  l.R=aColor.red();
  l.G=aColor.green();
  l.B=aColor.blue();
  l.T=aColor.alpha();
  l.width=width;
  l.isSigned=false;
  l.signPos=false;

  if (myLineSetList.size()== 0)
    createNewLineList("Line Root");

  (myLineSetList.at(myLineSetList.size()-1)).push_back(l);
}

template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::addQuad(double x1, double y1, double z1,
                                           double x2, double y2, double z2,
                                           double x3, double y3, double z3,
                                           double x4, double y4, double z4)
{
  DGtal::Color aColor = getFillColor();
  if(myQuadSetList.size() == 0 )
  {
    createNewQuadList("quad");
  }

  QuadD3D aQuad;
  updateBoundingBox(x1, y1, z1);
  updateBoundingBox(x2, y2, z2);
  updateBoundingBox(x3, y3, z3);
  updateBoundingBox(x4, y4, z4);
  double u[3]; double v [3]; double n [3];
  u[0]=x2-x1; u[1]=y2-y1; u[2]=z2-z1;
  v[0]=x3-x1; v[1]=y3-y1; v[2]=z3-z1;
  cross(n, u, v );
  normalize(n);

  if(u[0]==0.0 && u[1]==0.0 && u[2]==0.0)
  {
    trace.error()<< "Warning quad not added due to identical vertex... "<<std::endl;
    return;
  }

  aQuad.x1=x1; aQuad.y1=y1; aQuad.z1=z1;
  aQuad.x2=x2; aQuad.y2=y2; aQuad.z2=z2;
  aQuad.x3=x3; aQuad.y3=y3; aQuad.z3=z3;
  aQuad.x4=x4; aQuad.y4=y4; aQuad.z4=z4;
  aQuad.nx= n[0];
  aQuad.ny= n[1];
  aQuad.nz= n[2];

  aQuad.R=aColor.red();
  aQuad.G=aColor.green();
  aQuad.B=aColor.blue();
  aQuad.T=aColor.alpha();

 if (myQuadSetList.size()== 0)
    createNewQuadList("Quad Root");

  (myQuadSetList.at(myQuadSetList.size()-1)).push_back(aQuad);
}


template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::addTriangle(double x1, double y1, double z1, double x2,
                                               double y2, double z2,
                                               double x3, double y3, double z3)
{
  DGtal::Color aColor = getFillColor();
  updateBoundingBox(x1, y1, z1);
  updateBoundingBox(x2, y2, z2);
  updateBoundingBox(x3, y3, z3);

  TriangleD3D aTriangle;
  double u[3]; double v [3]; double n [3];
  u[0]=x2-x1; u[1]=y2-y1; u[2]=z2-z1;
  v[0]=x3-x1; v[1]=y3-y1; v[2]=z3-z1;
  cross(n, u, v );
  cross(n, u, v );
  normalize(n);

  if(u[0]==0.0 && u[1]==0.0 && u[2]==0.0)
  {
    trace.error()<< "Warning triangle not added due to identical vertex... "<<std::endl;
    return;
  }

  aTriangle.x1=x1; aTriangle.y1=y1; aTriangle.z1=z1;
  aTriangle.x2=x2; aTriangle.y2=y2; aTriangle.z2=z2;
  aTriangle.x3=x3; aTriangle.y3=y3; aTriangle.z3=z3;

  aTriangle.nx= n[0];
  aTriangle.ny= n[1];
  aTriangle.nz= n[2];

  aTriangle.R=aColor.red();
  aTriangle.G=aColor.green();
  aTriangle.B=aColor.blue();
  aTriangle.T=aColor.alpha();

 if (myTriangleSetList.size()== 0)
    createNewTriangleList("Triangle Root");

  (myTriangleSetList.at(myTriangleSetList.size()-1)).push_back(aTriangle);
}


template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::addPolygon(const std::vector<RealPoint> &vertices)
{

  VERIFY_MSG(vertices.size()>2, "Polygon must have at least two vertices");

  DGtal::Color aColor = getFillColor();
  PolygonD3D polygon;
  for(unsigned int i=0; i< vertices.size();i++)
  {
    polygon.vertices.push_back(vertices[i]);
    updateBoundingBox(vertices[i][0], vertices[i][1], vertices[i][2]);
  }

  double x1= vertices[0][0];
  double y1= vertices[0][1];
  double z1= vertices[0][2];

  double x2= vertices[1][0];
  double y2= vertices[1][1];
  double z2= vertices[1][2];

  double x3= vertices[2][0];
  double y3= vertices[2][1];
  double z3= vertices[2][2];

  double u[3]; double v [3]; double n [3];
  u[0]=x2-x1; u[1]=y2-y1; u[2]=z2-z1;
  v[0]=x3-x1; v[1]=y3-y1; v[2]=z3-z1;
  cross(n, u, v );
  normalize(n);

  if(u[0]==0.0 && u[1]==0.0 && u[2]==0.0)
  {
    trace.error()<< "Warning polygio not added due to identical vertex... "<<std::endl;
    return;
  }

  polygon.nx= n[0];
  polygon.ny= n[1];
  polygon.nz= n[2];

  polygon.R=aColor.red();
  polygon.G=aColor.green();
  polygon.B=aColor.blue();
  polygon.T=aColor.alpha();

 if (myPolygonSetList.size()== 0)
    createNewPolygonList("Polygon Root");

 //@fixme we force the list creation
 createNewPolygonList("tmp");

  (myPolygonSetList.at(myPolygonSetList.size()-1)).push_back(polygon);
}


template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::addSurfelPrism(double x, double y, double z,
                                                  bool xSurfel, bool ySurfel, bool zSurfel,
                                                  double sizeShiftFactor,
                                                  double sizeFactor, bool isSigned, bool aSign)
{
  updateBoundingBox(x, y, z);
  double retract= 0.05*(sizeShiftFactor+myCurrentfShiftVisuSurfelPrisms);
  double width= 0.03*(sizeShiftFactor+myCurrentfShiftVisuSurfelPrisms);


  double x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4;
  double x5, y5, z5, x6, y6, z6, x7, y7, z7, x8, y8, z8;
  double dx, dy, dz;


  ASSERT( xSurfel || ySurfel || zSurfel );

  if(zSurfel)
  {
    x1= x-(0.5*sizeFactor); y1= y-(0.5*sizeFactor); z1= z-0.5;
    x2= x+(0.5*sizeFactor); y2= y-(0.5*sizeFactor); z2= z-0.5;
    x3= x+(0.5*sizeFactor); y3= y+(0.5*sizeFactor); z3= z-0.5;
    x4= x-(0.5*sizeFactor); y4= y+(0.5*sizeFactor); z4= z-0.5;
    y1+=retract; y2+=retract; y3-=retract; y4-=retract;
    x1+=retract; x2-=retract; x3-=retract; x4+=retract;
    dx=0.0; dy=0.0; dz=width;
  }
  else if(ySurfel)
  {
    x1= x-(0.5*sizeFactor); y1= y-0.5; z1= z-(0.5*sizeFactor);
    x2= x-(0.5*sizeFactor); y2= y-0.5; z2= z+(0.5*sizeFactor);
    x3= x+(0.5*sizeFactor); y3= y-0.5; z3= z+(0.5*sizeFactor);
    x4= x+(0.5*sizeFactor); y4= y-0.5; z4= z-(0.5*sizeFactor);
    x1+=retract; x2+=retract; x3-=retract; x4-=retract;
    z1+=retract; z2-=retract; z3-=retract; z4+=retract;
    dx=0.0; dy=width; dz=0.0;
  }
  else
  {
    x1= x-0.5; y1= y-(0.5*sizeFactor); z1= z-(0.5*sizeFactor);
    x2= x-0.5; y2= y+(0.5*sizeFactor); z2= z-(0.5*sizeFactor);
    x3= x-0.5; y3= y+(0.5*sizeFactor); z3= z+(0.5*sizeFactor);
    x4= x-0.5; y4= y-(0.5*sizeFactor); z4= z+(0.5*sizeFactor);
    y1+=retract; y2-=retract; y3-=retract; y4+=retract;
    z1+=retract; z2+=retract; z3-=retract; z4-=retract;
    dx=width; dy=0.0; dz=0.0;
  }

  double xcenter= (x1+x2+x3+x4)/4.0;
  double ycenter= (y1+y2+y3+y4)/4.0;
  double zcenter= (z1+z2+z3+z4)/4.0;

  x5=x1-dx; y5=y1-dy; z5= z1-dz;
  x6=x2-dx; y6=y2-dy; z6= z2-dz;
  x7=x3-dx; y7=y3-dy; z7= z3-dz;
  x8=x4-dx; y8=y4-dy; z8= z4-dz;

  x1=x1+dx; y1=y1+dy; z1= z1+dz;
  x2=x2+dx; y2=y2+dy; z2= z2+dz;
  x3=x3+dx; y3=y3+dy; z3= z3+dz;
  x4=x4+dx; y4=y4+dy; z4= z4+dz;

  //if cell is oriented positively we retrac the upper face:
  if(isSigned && aSign)
  {
    x1= 0.6*x1+0.4*xcenter; x2= 0.6*x2+0.4*xcenter; x3= 0.6*x3+0.4*xcenter; x4= 0.6*x4+0.4*xcenter;
    y1= 0.6*y1+0.4*ycenter; y2= 0.6*y2+0.4*ycenter; y3= 0.6*y3+0.4*ycenter; y4= 0.6*y4+0.4*ycenter;
    z1= 0.6*z1+0.4*zcenter; z2= 0.6*z2+0.4*zcenter; z3= 0.6*z3+0.4*zcenter; z4= 0.6*z4+0.4*zcenter;
  }else if (isSigned)
  {
    x5= 0.6*x5+0.4*xcenter; x6= 0.6*x6+0.4*xcenter; x7= 0.6*x7+0.4*xcenter; x8= 0.6*x8+0.4*xcenter;
    y5= 0.6*y5+0.4*ycenter; y6= 0.6*y6+0.4*ycenter; y7= 0.6*y7+0.4*ycenter; y8= 0.6*y8+0.4*ycenter;
    z5= 0.6*z5+0.4*zcenter; z6= 0.6*z6+0.4*zcenter; z7= 0.6*z7+0.4*zcenter; z8= 0.6*z8+0.4*zcenter;
  }

  //main up face
  QuadD3D qFaceUp;
  double normaleUp [3];
  normaleUp[0] = dx!=0.0? 1.0:0.0;
  normaleUp[1] = dy!=0.0 ? 1.0:0.0;
  normaleUp[2] = dz!=0.0? 1.0:0.0;
  qFaceUp.nx= normaleUp[0];
  qFaceUp.ny= normaleUp[1];
  qFaceUp.nz= normaleUp[2];

  qFaceUp.x1=x1; qFaceUp.y1=y1; qFaceUp.z1= z1;
  qFaceUp.x2=x2; qFaceUp.y2=y2; qFaceUp.z2= z2;
  qFaceUp.x3=x3; qFaceUp.y3=y3; qFaceUp.z3= z3;
  qFaceUp.x4=x4; qFaceUp.y4=y4; qFaceUp.z4= z4;

  qFaceUp.R=myCurrentFillColor.red();qFaceUp.G=myCurrentFillColor.green(); qFaceUp.B=myCurrentFillColor.blue();
  qFaceUp.T=myCurrentFillColor.alpha();
  mySurfelPrismList.push_back(qFaceUp);
  //main down face
  QuadD3D qFaceDown;
  qFaceDown.nx= -normaleUp[0];
  qFaceDown.ny= -normaleUp[1];
  qFaceDown.nz= -normaleUp[2];
  qFaceDown.x1=x5; qFaceDown.y1=y5; qFaceDown.z1= z5;
  qFaceDown.x2=x8; qFaceDown.y2=y8; qFaceDown.z2= z8;
  qFaceDown.x3=x7; qFaceDown.y3=y7; qFaceDown.z3= z7;
  qFaceDown.x4=x6; qFaceDown.y4=y6; qFaceDown.z4= z6;
  qFaceDown.R=myCurrentFillColor.red();qFaceDown.G=myCurrentFillColor.green(); qFaceDown.B=myCurrentFillColor.blue();
  qFaceDown.T=myCurrentFillColor.alpha();
  mySurfelPrismList.push_back(qFaceDown);

  //small face 1
  QuadD3D qFace1;
  double vF1[3]; double v1 [3]; double n1 [3];
  vF1[0] = x2-x1; vF1[1] = y2-y1; vF1[2] = z2-z1;
  v1[0] = x5-x1; v1[1] = y5-y1; v1[2] = z5-z1;

  cross(n1, v1,vF1);
  normalize(n1);
  qFace1.nx=n1[0]; qFace1.ny=n1[1]; qFace1.nz=n1[2];
  qFace1.x1= x1; qFace1.y1 =y1; qFace1.z1=z1;
  qFace1.x2= x5; qFace1.y2 =y5; qFace1.z2=z5;
  qFace1.x3= x6; qFace1.y3 =y6; qFace1.z3=z6;
  qFace1.x4= x2; qFace1.y4 =y2; qFace1.z4=z2;
  qFace1.R=myCurrentFillColor.red();qFace1.G=myCurrentFillColor.green(); qFace1.B=myCurrentFillColor.blue();
  qFace1.T=myCurrentFillColor.alpha();
  mySurfelPrismList.push_back(qFace1);

  //small face 2
  QuadD3D qFace2;
  double vF2[3]; double v2 [3]; double n2[3];
  vF2[0]= x3-x2; vF2[1]=y3-y2; vF2[2]= z3-z2;
  v2[0]= x6-x2; v2[1]= y6-y2; v2[2]=z6-z2;
  cross(n2, v2, vF2);
  normalize(n2);

  qFace2.nx=n2[0]; qFace2.ny=n2[1]; qFace2.nz=n2[2];
  qFace2.x1= x2; qFace2.y1 =y2; qFace2.z1=z2;
  qFace2.x2= x6; qFace2.y2 =y6; qFace2.z2=z6;
  qFace2.x3= x7; qFace2.y3 =y7; qFace2.z3=z7;
  qFace2.x4= x3; qFace2.y4 =y3; qFace2.z4=z3;
  qFace2.R=myCurrentFillColor.red();qFace2.G=myCurrentFillColor.green(); qFace2.B=myCurrentFillColor.blue();
  qFace2.T=myCurrentFillColor.alpha();
  mySurfelPrismList.push_back(qFace2);

  //small face 3
  QuadD3D qFace3;
  double vF3[3]; double v3 [3]; double n3[3];
  vF3[0]= x4-x3; vF3[1]=y4-y3; vF3[2]= z4-z3;
  v3[0]= x7-x3; v3[1]= y7-y3; v3[2]=z7-z3;
  cross(n3, v3, vF3);
  normalize(n3);
  qFace3.nx=n3[0]; qFace3.ny=n3[1]; qFace3.nz=n3[2];
  qFace3.x1= x3; qFace3.y1 =y3; qFace3.z1=z3;
  qFace3.x2= x7; qFace3.y2 =y7; qFace3.z2=z7;
  qFace3.x3= x8; qFace3.y3 =y8; qFace3.z3=z8;
  qFace3.x4= x4; qFace3.y4 =y4; qFace3.z4=z4;
  qFace3.R=myCurrentFillColor.red();qFace3.G=myCurrentFillColor.green(); qFace3.B=myCurrentFillColor.blue();
  qFace3.T=myCurrentFillColor.alpha();
  mySurfelPrismList.push_back(qFace3);

  //small face 4
  QuadD3D qFace4;
  double vF4[3]; double v4 [3]; double n4[3];
  vF4[0]= x1-x4; vF4[1]=y1-y4; vF4[2]= z1-z4;
  v4[0]= x8-x4; v4[1]= y8-y4; v4[2]=z8-z4;
  cross(n4, v4, vF4);
  normalize(n4);
  qFace4.nx=n4[0]; qFace4.ny=n4[1]; qFace4.nz=n4[2];
  qFace4.x1= x4; qFace4.y1 =y4; qFace4.z1=z4;
  qFace4.x2= x8; qFace4.y2 =y8; qFace4.z2=z8;
  qFace4.x3= x5; qFace4.y3 =y5; qFace4.z3=z5;
  qFace4.x4= x1; qFace4.y4 =y1; qFace4.z4=z1;
  qFace4.R=myCurrentFillColor.red();qFace4.G=myCurrentFillColor.green(); qFace4.B=myCurrentFillColor.blue();
  qFace4.T=myCurrentFillColor.alpha();
  mySurfelPrismList.push_back(qFace4);
}

template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::addQuad(double x, double y, double z,
                                           bool xSurfel, bool ySurfel, bool zSurfel, double sizeShiftFactor,
                                           double sizeFactor, bool isSigned, bool aSign)
{
  double retract= 0.05*(sizeShiftFactor+myCurrentfShiftVisuSurfelPrisms);
  double x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4;

  ASSERT( xSurfel || ySurfel || zSurfel );

  if(zSurfel)
  {
    x1= x-(0.5*sizeFactor); y1= y-(0.5*sizeFactor); z1= z-0.5;
    x2= x+(0.5*sizeFactor); y2= y-(0.5*sizeFactor); z2= z-0.5;
    x3= x+(0.5*sizeFactor); y3= y+(0.5*sizeFactor); z3= z-0.5;
    x4= x-(0.5*sizeFactor); y4= y+(0.5*sizeFactor); z4= z-0.5;
    y1+=retract; y2+=retract; y3-=retract; y4-=retract;
    x1+=retract; x2-=retract; x3-=retract; x4+=retract;
  }
  else if(ySurfel)
  {
    x1= x-(0.5*sizeFactor); y1= y-0.5; z1= z-(0.5*sizeFactor);
    x2= x-(0.5*sizeFactor); y2= y-0.5; z2= z+(0.5*sizeFactor);
    x3= x+(0.5*sizeFactor); y3= y-0.5; z3= z+(0.5*sizeFactor);
    x4= x+(0.5*sizeFactor); y4= y-0.5; z4= z-(0.5*sizeFactor);
    x1+=retract; x2+=retract; x3-=retract; x4-=retract;
    z1+=retract; z2-=retract; z3-=retract; z4+=retract;
  }
  else
  {
    x1= x-0.5; y1= y-(0.5*sizeFactor); z1= z-(0.5*sizeFactor);
    x2= x-0.5; y2= y+(0.5*sizeFactor); z2= z-(0.5*sizeFactor);
    x3= x-0.5; y3= y+(0.5*sizeFactor); z3= z+(0.5*sizeFactor);
    x4= x-0.5; y4= y-(0.5*sizeFactor); z4= z+(0.5*sizeFactor);
    y1+=retract; y2-=retract; y3-=retract; y4+=retract;
    z1+=retract; z2+=retract; z3-=retract; z4-=retract;
  }

  if(isSigned && ! aSign)
    this->addQuad(x1,y1,z1,x2,y2,z2, x3,y3,z3, x4,y4,z4 );
  else
    this->addQuad(x4,y4,z4,x3,y3,z3, x2,y2,z2, x1,y1,z1 );
}


// add multiple triangular faces which form a hexagonal-based pyramid
template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::addCone(double x1, double y1, double z1,
                                           double x2, double y2, double z2,
                                           double width)
{
  updateBoundingBox(x1, y1, z1);
  updateBoundingBox(x2, y2, z2);

  int nbPoints = 6; //the number of point on the base of the cone
  double degree = 360 / nbPoints; // the angle between two points
  double radian = degree * PI/180;
  DGtal::Color color = getFillColor();
  double norm; // norm of the vectors

  // A(x1,y1,z1) and B(x2,y2,z2) vector AB
  double xab, yab, zab;

  xab = x2-x1;
  yab = y2-y1;
  zab = z2-z1;

  norm = sqrt( xab*xab + yab*yab + zab*zab);
  assert (norm > 0);
  xab = xab / norm;
  yab = yab / norm;
  zab = zab / norm;

  //take a third point M different from A and B
  double xm = 0;
  double ym = 0;
  double zm = 0;

  while (x1 == xm || x2 ==xm) xm++;
  while (y1 == ym || y2 ==ym) ym++;
  while (z1 == zm || z2 ==zm) zm++;

  //vector AM
  double xam, yam, zam;

  xam = xm-x1;
  yam = ym-y1;
  zam = zm-z1;

  norm = sqrt( xam*xam + yam*yam + zam*zam);
  assert (norm > 0);
  xam = xam / norm;
  yam = yam / norm;
  zam = zam / norm;

  //normal vector n = AB^AM
  double xn, yn, zn;

  xn = yab*zam - yam*zab;
  yn = xam*zab - xab*zam;
  zn = xab*yam - xam*yab;

  //divide n by its norm
  norm = sqrt( xn*xn + yn*yn + zn*zn);
  assert (norm > 0);
  xn = xn / norm;
  yn = yn / norm;
  zn = zn / norm;

  //the first point of the base
  double xf, yf, zf;

  xf = x2 + width * xn;
  yf = y2 + width * yn;
  zf = z2 + width * zn;

  //two following points of the base
  double xb1 = xf;
  double yb1 = yf;
  double zb1 = zf;
  double xb2,yb2, zb2;

  //r = AB^n for the future rotation
  double xr, yr, zr;

  createNewTriangleList("Cone");
  for (int i =0; i < nbPoints-1; i ++)
  {
    // r = AB^n
    xr = yab*zn - yn*zab;
    yr = xn*zab - xab*zn;
    zr = xab*yn - xn*yab;

    //rotate n by degree
    xn = cos(radian)*xn + sin(radian)*xr;
    yn = cos(radian)*yn + sin(radian)*yr;
    zn = cos(radian)*zn + sin(radian)*zr;

    //divide n by its norm
    norm = sqrt( xn*xn + yn*yn + zn*zn);
    assert (norm > 0);
    xn = xn / norm;
    yn = yn / norm;
    zn = zn / norm;

    // calculate one point with the normal vector at a distance width
    xb2 = x2 + width * xn;
    yb2 = y2 + width * yn;
    zb2 = z2 + width * zn;

    //adding the triangles associated with this point
    addTriangle(x1, y1, z1,
                xb1, yb1, zb1,
                xb2, yb2, zb2);
    addTriangle(x2, y2, z2,
                xb1, yb1, zb1,
                xb2, yb2, zb2);

    xb1 = xb2;
    yb1 = yb2;
    zb1 = zb2;
  }

  //Last part to close the cone
  addTriangle(x1, y1, z1,
              xb1, yb1,zb1,
              xf, yf, zf);
  addTriangle(x2, y2, z2,
              xb1, yb1, zb1,
              xf, yf, zf);
}

// add multiple triangular faces which form a hexagonal-based cylinder
template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::addCylinder(const double x1, const double y1, const double z1,
                                               const double x2, const double y2, const double z2,
                                               const double width)
{
  updateBoundingBox(x1, y1, z1);
  updateBoundingBox(x2, y2, z2);

  int nbPoints = 6; //the number of point on the base of the cone
  double degree = 360 / nbPoints; // the angle between two points
  double radian = degree * PI/180;
  DGtal::Color color = getFillColor();
  double norm; // norm of the vectors

  // A(x1,y1,z1) and B(x2,y2,z2) vector AB
  double xab, yab, zab;

  xab = x2-x1;
  yab = y2-y1;
  zab = z2-z1;

  norm = sqrt( xab*xab + yab*yab + zab*zab);
  assert (norm > 0);
  xab = xab / norm;
  yab = yab / norm;
  zab = zab / norm;

  //take a third point M different from A and B
  double xm = 0;
  double ym = 0;
  double zm = 0;

  while (x1 == xm || x2 ==xm) xm++;
  while (y1 == ym || y2 ==ym) ym++;
  while (z1 == zm || z2 ==zm) zm++;

  //vector AM
  double xam, yam, zam;

  xam = xm-x1;
  yam = ym-y1;
  zam = zm-z1;

  norm = sqrt( xam*xam + yam*yam + zam*zam);
  assert (norm > 0);
  xam = xam / norm;
  yam = yam / norm;
  zam = zam / norm;

  //normal vector n = AB^AM
  double xn, yn, zn;

  xn = yab*zam - yam*zab;
  yn = xam*zab - xab*zam;
  zn = xab*yam - xam*yab;

  //divide n by its norm
  norm = sqrt( xn*xn + yn*yn + zn*zn);
  assert (norm > 0);
  xn = xn / norm;
  yn = yn / norm;
  zn = zn / norm;


  //the first point of the bases
  double xbf, ybf, zbf;
  double xaf, yaf, zaf;

  xbf = x2 + width * xn;
  ybf = y2 + width * yn;
  zbf = z2 + width * zn;

  xaf = x1 + width * xn;
  yaf = y1 + width * yn;
  zaf = z1 + width * zn;

  //two following points of the bases
  double xb1 = xbf;
  double yb1 = ybf;
  double zb1 = zbf;
  double xb2,yb2, zb2;

  double xa1 = xaf;
  double ya1 = yaf;
  double za1 = zaf;
  double xa2,ya2, za2;

  //r = AB^n for the future rotation
  double xr, yr, zr;

  createNewTriangleList("Cylinder");
  createNewQuadList("Cylinder");
  for (int i =0; i < nbPoints-1; i ++)
  {
    // r = AB^n
    xr = yab*zn - yn*zab;
    yr = xn*zab - xab*zn;
    zr = xab*yn - xn*yab;

    //rotate n by degree
    xn = cos(radian)*xn + sin(radian)*xr;
    yn = cos(radian)*yn + sin(radian)*yr;
    zn = cos(radian)*zn + sin(radian)*zr;

    //divide n by its norm (used when a bug appear)
    norm = sqrt( xn*xn + yn*yn + zn*zn);
    assert (norm > 0);
    xn = xn / norm;
    yn = yn / norm;
    zn = zn / norm;

    // calculate one point with the normal vector at a distance width
    xb2 = x2 + width * xn;
    yb2 = y2 + width * yn;
    zb2 = z2 + width * zn;

    xa2 = x1 + width * xn;
    ya2 = y1 + width * yn;
    za2 = z1 + width * zn;

    //adding the triangles and the quad associated with those points
    addTriangle(x1, y1, z1,
                xa1, ya1, za1,
                xa2, ya2, za2);
    addTriangle(x2, y2, z2,
                xb1, yb1, zb1,
                xb2, yb2, zb2);
    addQuad(xb1, yb1, zb1,
            xb2, yb2, zb2,
            xa2, ya2, za2,
            xa1, ya1, za1);

    xb1 = xb2;
    yb1 = yb2;
    zb1 = zb2;

    xa1 = xa2;
    ya1 = ya2;
    za1 = za2;

  }

  //Last part to close the cylinder
  addTriangle(x1, y1, z1,
              xa1, ya1, za1,
              xaf, yaf, zaf);
  addTriangle(x2, y2, z2,
              xb1, yb1, zb1,
              xbf, ybf, zbf);
  addQuad(xb1, yb1, zb1,
          xbf, ybf, zbf,
          xaf, yaf, zaf,
          xa1, ya1, za1);
}



template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::addClippingPlane(double a, double b, double c, double d, bool drawPlane)
{
  ClippingPlaneD3D cp;
  cp.a=a; cp.b=b; cp.c=c; cp.d=d;
  myClippingPlaneList.push_back(cp);
  if(drawPlane)
  {
    double x1,x2,x3,x4;
    double y1,y2,y3,y4;
    double z1,z2,z3,z4;
    double norm = sqrt(a*a+b*b+c*c);
    double dec=0.1;
    // Z dominant projection of the upper face
    if(abs(c)>=abs(b) && abs(c) >= abs(a))
    {
      x1= myBoundingPtUp[0]+a*dec/norm; y1= myBoundingPtUp[1]+b*dec/norm;
      z1 = c*dec/norm +(-d-a*myBoundingPtUp[0]-b*myBoundingPtUp[1])/c;
      x2= myBoundingPtLow[0]+a*dec/norm; y2= myBoundingPtUp[1]+b*dec/norm;
      z2= c*dec/norm+(-d-a*myBoundingPtLow[0]-b*myBoundingPtUp[1])/c;
      x3= myBoundingPtLow[0]+a*dec/norm; y3= myBoundingPtLow[1]+b*dec/norm;
      z3= c*dec/norm+(-d-a*myBoundingPtLow[0]-b*myBoundingPtLow[1])/c;
      x4= myBoundingPtUp[0]+a*dec/norm; y4= myBoundingPtLow[1]+b*dec/norm;
      z4= c*dec/norm+(-d-a*myBoundingPtUp[0]-b*myBoundingPtLow[1])/c;
      if(c>0)
      {
        addQuad(x4,y4,z4,x3,y3,z3, x2,y2,z2, x1,y1,z1 );
      }else
      {
        addQuad( x1,y1,z1, x2,y2,z2, x3,y3,z3,x4,y4,z4);
      }
    }// Y dominant projection of the upper face
    else if(abs(b)>=abs(c) && abs(b) >= abs(a))
    {
      x1= myBoundingPtUp[0]+a*dec/norm; z1= myBoundingPtUp[2]+c*dec/norm;
      y1= b*dec/norm +(-d-a*myBoundingPtUp[0]-c*myBoundingPtUp[2])/b;
      x2= myBoundingPtUp[0]+a*dec/norm; z2= myBoundingPtLow[2]+c*dec/norm;
      y2= b*dec/norm +(-d-a*myBoundingPtUp[0]-c*myBoundingPtLow[2])/b;
      x3= myBoundingPtLow[0]+a*dec/norm; z3= myBoundingPtLow[2]+c*dec/norm;
      y3= b*dec/norm +(-d-a*myBoundingPtLow[0]-c*myBoundingPtLow[2])/b;
      x4= myBoundingPtLow[0]+a*dec/norm; z4= myBoundingPtUp[2]+c*dec/norm;
      y4= b*dec/norm +(-d-a*myBoundingPtLow[0]-c*myBoundingPtUp[2])/b;
      if(b>0)
      {
        addQuad(x4,y4,z4,x3,y3,z3, x2,y2,z2, x1,y1,z1);
      }else
      {
        addQuad( x1,y1,z1, x2,y2,z2, x3,y3,z3,x4,y4,z4);
      }
    }// X dominant projection of the upper face
    else if(abs(a)>=abs(c) && abs(a) >= abs(b))
    {
      y1= myBoundingPtUp[1]+b*dec/norm; z1= myBoundingPtUp[2]+c*dec/norm;
      x1= a*dec/norm +(-d-b*myBoundingPtUp[1]-c*myBoundingPtUp[2])/a;
      y2= myBoundingPtLow[1]+b*dec/norm; z2= myBoundingPtUp[2]+c*dec/norm;
      x2= a*dec/norm +(-d-b*myBoundingPtLow[1]-c*myBoundingPtUp[2])/a;
      y3= myBoundingPtLow[1]+b*dec/norm; z3= myBoundingPtLow[2]+c*dec/norm;
      x3= a*dec/norm +(-d-b*myBoundingPtLow[1]-c*myBoundingPtLow[2])/a;
      y4= myBoundingPtUp[1]+b*dec/norm; z4= myBoundingPtLow[2]+c*dec/norm;
      x4= a*dec/norm +(-d-b*myBoundingPtUp[1]-c*myBoundingPtLow[2])/a;

      if(a>0)
      {

        addQuad(x4,y4,z4,x3,y3,z3, x2,y2,z2, x1,y1,z1);
      }else
      {
        addQuad( x1,y1,z1, x2,y2,z2, x3,y3,z3,x4,y4,z4);
      }
    }
  }
}


template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::updateBoundingBox(double x, double y, double z)
{
  if (myBoundingPtEmptyTag)
  {
    myBoundingPtLow[0]= x;
    myBoundingPtLow[1]= y;
    myBoundingPtLow[2]= z;
    myBoundingPtUp[0]= x;
    myBoundingPtUp[1]= y;
    myBoundingPtUp[2]= z;
    myBoundingPtEmptyTag = false;
  }
  else
  {
    if(x <myBoundingPtLow[0]) myBoundingPtLow[0]= x;
    if(y <myBoundingPtLow[1]) myBoundingPtLow[1]= y;
    if(z <myBoundingPtLow[2]) myBoundingPtLow[2]= z;

    if(x >myBoundingPtUp[0]) myBoundingPtUp[0]= x;
    if(y >myBoundingPtUp[1]) myBoundingPtUp[1]= y;
    if(z >myBoundingPtUp[2]) myBoundingPtUp[2]= z;
  }
}


template < typename Space ,typename KSpace >
inline
typename DGtal::CanonicEmbedder<Space>::RealPoint
DGtal::Display3D< Space ,KSpace >::embed( const DGtal::Z3i::Point & dp ) const
{
  ASSERT( myEmbedder.isValid());
  return myEmbedder.embed(dp);
}

template < typename Space ,typename KSpace >
inline
typename DGtal::CanonicSCellEmbedder<KSpace >::RealPoint
DGtal::Display3D< Space ,KSpace >::embedKS( const DGtal::Z3i::SCell & scell ) const
{
  ASSERT( mySCellEmbedder.isValid());
  return mySCellEmbedder.embed(scell);
}

template < typename Space ,typename KSpace >
inline
typename DGtal::CanonicSCellEmbedder<KSpace >::RealPoint
DGtal::Display3D< Space ,KSpace >::embedKS( const TransformedSurfelPrism & aTrans ) const
{
  ASSERT( mySCellEmbedder.isValid());
  return mySCellEmbedder.embed(aTrans.mySurfel);
}


template < typename Space ,typename KSpace >
inline
typename DGtal::CanonicCellEmbedder<KSpace >::RealPoint
DGtal::Display3D< Space ,KSpace >::embedK( const DGtal::Z3i::Cell & cell ) const
{
  ASSERT( myCellEmbedder.isValid());
  return myCellEmbedder.embed(cell);
}

template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::exportToMesh(DGtal::Mesh<BallD3D> &aMesh) const
{
  unsigned int vertexIndex=0;

  // Export of SurfelPrism lists (generated from KhalimskyCell or SignedKhalimskyCell (through addSurfelPrism))
  for (unsigned int i=0; i< mySurfelPrismList.size(); i++)
  {
    QuadD3D quad = mySurfelPrismList.at(i);
    BallD3D p1, p2, p3, p4;
    p1.x=quad.x1; p1.y=quad.y1; p1.z=quad.z1;
    p2.x=quad.x2; p2.y=quad.y2; p2.z=quad.z2;
    p3.x=quad.x3; p3.y=quad.y3; p3.z=quad.z3;
    p4.x=quad.x4; p4.y=quad.y4; p4.z=quad.z4;
    aMesh.addVertex(p1);
    aMesh.addVertex(p2);
    aMesh.addVertex(p3);
    aMesh.addVertex(p4);
    aMesh.addQuadFace(vertexIndex, vertexIndex+1, vertexIndex+2,vertexIndex+3,
                      DGtal::Color(quad.R, quad.G, quad.B, quad.T));
    vertexIndex+=4;
  }

  // Export QuadList
  for (typename std::vector<std::vector<QuadD3D> >::const_iterator it = myQuadSetList.begin(); it != myQuadSetList.end(); it++)
  {
    for (typename std::vector<QuadD3D>::const_iterator aQuad = it->begin(); aQuad!=it->end();aQuad ++)
    {
      BallD3D p1, p2, p3, p4;
      p1.x=aQuad->x1; p1.y=aQuad->y1; p1.z=aQuad->z1;
      p2.x=aQuad->x2; p2.y=aQuad->y2; p2.z=aQuad->z2;
      p3.x=aQuad->x3; p3.y=aQuad->y3; p3.z=aQuad->z3;
      p4.x=aQuad->x4; p4.y=aQuad->y4; p4.z=aQuad->z4;
      aMesh.addVertex(p4);
      aMesh.addVertex(p3);
      aMesh.addVertex(p2);
      aMesh.addVertex(p1);
      aMesh.addQuadFace(vertexIndex,vertexIndex+1, vertexIndex+2, vertexIndex+3,
                        DGtal::Color(aQuad->R, aQuad->G, aQuad->B, aQuad->T));
      vertexIndex+=4;
    }
  }

  // Export the mesh from TriangleList
  for ( typename std::vector<std::vector<TriangleD3D> >::const_iterator it =myTriangleSetList.begin(); it != myTriangleSetList.end(); it++)
  {
    for (typename std::vector<TriangleD3D>::const_iterator aTriangle = it->begin(); aTriangle!=it->end();aTriangle ++)
    {
      BallD3D p1, p2, p3;
      p1.x = aTriangle->x1; p1.y = aTriangle->y1; p1.z = aTriangle->z1;
      p2.x = aTriangle->x2; p2.y = aTriangle->y2; p2.z = aTriangle->z2;
      p3.x = aTriangle->x3; p3.y = aTriangle->y3; p3.z = aTriangle->z3;
      aMesh.addVertex(p1);
      aMesh.addVertex(p2);
      aMesh.addVertex(p3);
      aMesh.addTriangularFace(vertexIndex, vertexIndex+1, vertexIndex+2,
                              DGtal::Color(aTriangle->R, aTriangle->G,
                                           aTriangle->B, aTriangle->T));
      vertexIndex+=3;
    }
  }

  // Export of cubeSet (generated from addCube)
  for(unsigned int j=0; j<myCubeSetList.size(); j++)
  {
    for (unsigned int i=0; i< myCubeSetList.at(j).size(); i++)
    {
      CubeD3D cube = myCubeSetList.at(j).at(i);
      BallD3D p1, p2, p3, p4, p5, p6, p7, p8;
      double width= cube.width;

      p1.x = (cube.x-width); p1.y = (cube.y+width); p1.z = (cube.z+width);
      p2.x = (cube.x+width); p2.y = (cube.y+width); p2.z = (cube.z+width);
      p3.x = (cube.x+width); p3.y = (cube.y-width); p3.z = (cube.z+width);
      p4.x = (cube.x-width); p4.y = (cube.y-width); p4.z = (cube.z+width);
      p5.x = (cube.x-width); p5.y = (cube.y+width); p5.z = (cube.z-width);
      p6.x = (cube.x+width); p6.y = (cube.y+width); p6.z = (cube.z-width);
      p7.x = (cube.x+width); p7.y = (cube.y-width); p7.z = (cube.z-width);
      p8.x = (cube.x-width); p8.y = (cube.y-width); p8.z = (cube.z-width);

      aMesh.addVertex(p1);
      aMesh.addVertex(p2);
      aMesh.addVertex(p3);
      aMesh.addVertex(p4);
      aMesh.addVertex(p5);
      aMesh.addVertex(p6);
      aMesh.addVertex(p7);
      aMesh.addVertex(p8);

      //z+
      aMesh.addQuadFace(vertexIndex, vertexIndex+3, vertexIndex+2, vertexIndex+1,
                        DGtal::Color(cube.R, cube.G, cube.B, cube.T));
      //z-
      aMesh.addQuadFace(vertexIndex+4, vertexIndex+5, vertexIndex+6, vertexIndex+7,
                        DGtal::Color(cube.R, cube.G, cube.B, cube.T));
      //y+
      aMesh.addQuadFace(vertexIndex+1, vertexIndex+2, vertexIndex+6, vertexIndex+5,
                        DGtal::Color(cube.R, cube.G, cube.B, cube.T));
      //y-
      aMesh.addQuadFace(vertexIndex, vertexIndex+4, vertexIndex+7, vertexIndex+3,
                        DGtal::Color(cube.R, cube.G, cube.B, cube.T));
      //x+
      aMesh.addQuadFace(vertexIndex, vertexIndex+1, vertexIndex+5, vertexIndex+4,
                        DGtal::Color(cube.R, cube.G, cube.B, cube.T));
      //x-
      aMesh.addQuadFace(vertexIndex+3, vertexIndex+7, vertexIndex+6, vertexIndex+2,
                        DGtal::Color(cube.R, cube.G, cube.B, cube.T));

      vertexIndex+=8;
    }
  }
}


template < typename Space ,typename KSpace >
template<typename TDrawableWithDisplay3D>
inline
DGtal::Display3D< Space ,KSpace >&
DGtal::Display3D< Space ,KSpace >::operator <<( const TDrawableWithDisplay3D & object )
{
  // BOOST_CONCEPT_ASSERT((CDrawableWithDisplay3D< TDrawableWithDisplay3D >));

  DGtal::Display3DFactory<Space,KSpace>::draw(*this, object);
  return *this;
}


template < typename Space ,typename KSpace >
inline
std::ostream&
DGtal::operator<< ( std::ostream & out,
                    const Display3D< Space ,KSpace >& object )
{
  object.selfDisplay ( out );
  return out;
}


template < typename Space ,typename KSpace >
inline
void
DGtal::operator>> ( const Display3D< Space ,KSpace >&aDisplay3D, DGtal::Mesh< typename Display3D< Space ,KSpace >::BallD3D> &aMesh)
{
  aDisplay3D.exportToMesh(aMesh);
}


template < typename Space ,typename KSpace >
inline
void
DGtal::operator>> ( const Display3D< Space ,KSpace >&aDisplay3D, std::string aFilename)
{
  // exporting with a mesh containing color (parameter constructor to true):
  DGtal::Mesh<typename Display3D< Space ,KSpace >::BallD3D> mesh(true);
  aDisplay3D >> mesh;
  trace.info() << "generating faces done." << std::endl;
  mesh >> aFilename;
  trace.info() << "file exported in file: " << aFilename << std::endl;
}


template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::cross (double dst[3], double srcA[3], double srcB[3])
{
  dst[0] = srcA[1]*srcB[2] - srcA[2]*srcB[1];
  dst[1] = srcA[2]*srcB[0] - srcA[0]*srcB[2];
  dst[2] = srcA[0]*srcB[1] - srcA[1]*srcB[0];
}


template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::normalize (double vec[3])
{
  const double squaredLen = vec[0]*vec[0] + vec[1]*vec[1] + vec[2]*vec[2];
  vec[0] /= sqrt (squaredLen);
  vec[1] /= sqrt (squaredLen);
  vec[2] /= sqrt (squaredLen);
}





// //
///////////////////////////////////////////////////////////////////////////////
