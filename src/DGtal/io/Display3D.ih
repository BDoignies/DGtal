/**
 * This program is free software: you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file Display3D.ih
 * @author Bertrand Kerautret (\c kerautre@loria.fr )
 * LORIA (CNRS, UMR 7503), University of Nancy, France
 *
 * @date 2011/08/08
 *
 * Implementation of inline methods defined in Display3D.h
 *
 * This file is part of the DGtal library.
 */

///////////////////////////////////////////////////////////////////////////////
// IMPLEMENTATION of inline methods.
///////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
#include <cstdlib>
#include <cmath>
#include "DGtal/io/CDrawableWithDisplay3D.h"
#include "DGtal/io/Display3DFactory.h"
#include "DGtal/io/writers/MeshWriter.h"


//tmp
#include <iostream>

//////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Implementation of inline methods //


// //
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions and external operators //


template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::setFillColor(DGtal::Color aColor)
{
    *myCurrentStyle.color = aColor;
}

template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::setFillTransparency(unsigned char alpha)
{
     myCurrentStyle.color->alpha(alpha);
}

template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::setLineColor(DGtal::Color aColor)
{
    *myCurrentStyle.color = aColor;
}


template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::setKSpace( const KSpace & aKSpace )
{
  myKSpace = aKSpace;
  *myCellEmbedder  = CellEmbedder( myKSpace );
  *mySCellEmbedder = SCellEmbedder( myKSpace );
}


template < typename Space ,typename KSpace >
inline
DGtal::Color
DGtal::Display3D< Space ,KSpace >::getLineColor()
{
   return *myCurrentStyle.color;
}

template < typename Space ,typename KSpace >
inline
DGtal::Color
DGtal::Display3D< Space ,KSpace >::getFillColor()
{
    return *myCurrentStyle.color;
}

//-----------------------------------------------------------------------------
template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::
setName3d( DGtal::int32_t name )
{
   myName3d = name;
}

//-----------------------------------------------------------------------------
template < typename Space ,typename KSpace >
inline
DGtal::int32_t
DGtal::Display3D< Space ,KSpace >::
name3d() const
{ 
    return myName3d;
}
//-----------------------------------------------------------------------------
template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::
setSelectCallback3D( SelectCallbackFct fct, void* data,
                     DGtal::int32_t min_name, DGtal::int32_t max_name )
{
  mySelectCallBackFcts.insert( SelectCallbackFctStore( fct, data, min_name, max_name ) );
}
//-----------------------------------------------------------------------------
template < typename Space ,typename KSpace >
inline
typename DGtal::Display3D< Space ,KSpace >::SelectCallbackFct 
DGtal::Display3D< Space ,KSpace >::
getSelectCallback3D( DGtal::int32_t aName, void*& data ) const
{
  typedef typename std::set<SelectCallbackFctStore>::const_iterator SetConstIterator;
  SelectCallbackFctStore seek( 0, 0, aName, aName );
  SetConstIterator it_up = mySelectCallBackFcts.upper_bound( seek );
  if ( ( it_up != mySelectCallBackFcts.end() ) && it_up->isSelected( aName ) )
    {
      data = it_up->data;
      return it_up->fct;
    }
  if (it_up == mySelectCallBackFcts.begin()){
    return 0;
  }
  --it_up;
  
  if ( ( it_up != mySelectCallBackFcts.end() ) && it_up->isSelected( aName ) )
    {
      data = it_up->data;
      return it_up->fct;
    }
  return 0;
}


//-----------------------------------------------------------------------------
template < typename Space ,typename KSpace >
inline
std::string
DGtal::Display3D< Space ,KSpace >::getMode( const std::string & objectName ) const
{
  ModeMapping::const_iterator itm = myModes.find( objectName );
  return itm == myModes.end() ? "" : itm->second;
}


template < typename Space ,typename KSpace >
inline
std::string
DGtal::Display3D< Space ,KSpace >::createNewCubeList(std::string str)
{
    return myCubesMap.newGroup(str, myCurrentStyle, name3d());
}

template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::setDefaultCubeList()
{
    return myCubesMap.endGroup();
}

template < typename Space ,typename KSpace >
inline
bool
DGtal::Display3D< Space ,KSpace >::deleteCubeList(std::string name)
{
  return myCubesMap.groups.erase(name);
}


template < typename Space ,typename KSpace >
inline
std::string
DGtal::Display3D< Space ,KSpace >::createNewBallList(std::string str)
{
    return myBallSetList.newGroup(str, myCurrentStyle, name3d());
}

template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::setDefaultBallList()
{
    return myBallSetList.endGroup();
}

template < typename Space ,typename KSpace >
inline
std::string
DGtal::Display3D< Space ,KSpace >::createNewLineList(std::string str)
{
    return myLineSetList.newGroup(str, myCurrentStyle, name3d());
} 

template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::setDefaultLineList()
{
    return myLineSetList.endGroup();
}

template < typename Space ,typename KSpace >
inline
std::string
DGtal::Display3D< Space ,KSpace >::createNewQuadList(std::string s)
{
    return myQuadsMap.newGroup(s, myCurrentStyle, name3d());
}

template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::setDefaultQuadList()
{
    return myQuadsMap.endGroup();
}

template < typename Space ,typename KSpace >
inline
bool
DGtal::Display3D< Space ,KSpace >::deleteQuadList(std::string name)
{
  return myQuadsMap.groups.erase(name);
}

template < typename Space ,typename KSpace >
inline
std::string
DGtal::Display3D< Space ,KSpace >::createNewTriangleList(std::string str)
{
    return myTriangleSetList.newGroup(str, myCurrentStyle, name3d());
}

template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::setDefaultTriangleList()
{
    return myTriangleSetList.endGroup();
}


template < typename Space ,typename KSpace >
inline
std::string
DGtal::Display3D< Space ,KSpace >::createNewPolygonList(std::string str)
{
    return myPolygonSetList.newGroup(str, myCurrentStyle, name3d());
}

template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::setDefaultPolygonList()
{
    return myPolygonSetList.endGroup();
}

template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::addCube(const RealPoint &center, double width)
{
    updateBoundingBox(center);
    static const RealPoint cubePositions[8] = { 
          {-1, -1, -1}, 
          { 1, -1, -1},
          { 1,  1, -1},
          {-1,  1, -1},
          {-1, -1,  1},
          { 1, -1,  1},
          { 1,  1,  1},
          {-1,  1,  1}
      };

    const std::array<RealPoint, 8> points = {
        center + 0.5 * width * cubePositions[0], 
        center + 0.5 * width * cubePositions[1], 
        center + 0.5 * width * cubePositions[2], 
        center + 0.5 * width * cubePositions[3], 
        center + 0.5 * width * cubePositions[4], 
        center + 0.5 * width * cubePositions[5], 
        center + 0.5 * width * cubePositions[6], 
        center + 0.5 * width * cubePositions[7] 
    };

    myCubesMap.Append(points, *myCurrentStyle.color, name3d());
}


template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::addBall(const RealPoint &center,
                                           const double radius,
                                           const unsigned int resolution)
{
    ((void) radius); ((void) resolution);
    updateBoundingBox(center);

    const std::array<RealPoint, 1> points = {
        center
    };
    myBallSetList.Append(points, *myCurrentStyle.color, name3d());
}



template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::addLine(const RealPoint &p1, const RealPoint &p2, const double width)
{
    ((void) width);
    updateBoundingBox(p1);
    updateBoundingBox(p2);

    const std::array<RealPoint, 2> points = {
        p1, p2
    };
    myLineSetList.Append(points, *myCurrentStyle.color, name3d());
}

template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::addQuad(const RealPoint &p1, const RealPoint &p2,
					   const RealPoint &p3, const RealPoint &p4)
{

  double u[3]; double v [3]; double n [3];
  u[0]=p2[0]-p1[0]; u[1]=p2[1]-p1[1]; u[2]=p2[2]-p1[2];
  v[0]=p3[0]-p1[0]; v[1]=p3[1]-p1[1]; v[2]=p3[2]-p1[2];
  cross(n, u, v );
  normalize(n);
  addQuadWithNormal(p1, p2, p3, p4, RealPoint(n[0], n[1], n[2]), false);
}

template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::addQuadWithNormal(const RealPoint &p1, const RealPoint &p2,
                                                     const RealPoint &p3, const RealPoint &p4,
                                                     const RealPoint &n,
                                                     const bool enableReorientation,
                                                     const bool enableDoubleFace)
{
    updateBoundingBox(p1);
    updateBoundingBox(p2);
    updateBoundingBox(p3);
    updateBoundingBox(p4);

    const RealPoint u = p2 - p1;
    const RealPoint v = p3 - p2;
    const RealPoint cp = crossProduct(u, v);
    const auto scal = dotProduct(cp, n);

    auto pp2 = p2;
    auto pp4 = p4;
    
    if (enableReorientation && (scal < 0.))
      std::swap(pp4, pp2);
    
    const std::array<RealPoint, 4> points = {
      p1, pp2, p3, pp4
    };
    myQuadsMap.Append(points, *myCurrentStyle.color, name3d());
}


template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::addTriangle(const RealPoint &p1, const RealPoint &p2, const RealPoint &p3)
{
    updateBoundingBox(p1);
    updateBoundingBox(p2);
    updateBoundingBox(p3);

    const std::array<RealPoint, 3> points = {
      p1, p2, p3
    };
    myTriangleSetList.Append(points, *myCurrentStyle.color, name3d());
}

template < typename Space ,typename KSpace>
inline
void
DGtal::Display3D< Space ,KSpace >::addPolygon(const std::vector<RealPoint> &vertices)
{
    for(unsigned int i=0; i< vertices.size();i++)
        updateBoundingBox(vertices[i]);

    myPolygonSetList.Append(vertices, *myCurrentStyle.color, name3d());
}



template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::addPrism(const RealPoint &baseQuadCenter,
                                            bool xSurfel, bool ySurfel, bool zSurfel,
                                            double sizeShiftFactor,
                                            double sizeFactor, bool isSigned, bool aSign)
{
  updateBoundingBox(baseQuadCenter);
  double retract = 0.05*(sizeShiftFactor+myCurrentfShiftVisuPrisms);
  double width   = 0.03*(sizeShiftFactor+myCurrentfShiftVisuPrisms);

  double x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4;
  double x5, y5, z5, x6, y6, z6, x7, y7, z7, x8, y8, z8;
  double dx, dy, dz;

  ASSERT( xSurfel || ySurfel || zSurfel );
  boost::ignore_unused_variable_warning( xSurfel );

  if(zSurfel)
    {
      x1= baseQuadCenter[0]-(0.5*sizeFactor); y1= baseQuadCenter[1]-(0.5*sizeFactor); z1= baseQuadCenter[2]-0.5;
      x2= baseQuadCenter[0]+(0.5*sizeFactor); y2= baseQuadCenter[1]-(0.5*sizeFactor); z2= baseQuadCenter[2]-0.5;
      x3= baseQuadCenter[0]+(0.5*sizeFactor); y3= baseQuadCenter[1]+(0.5*sizeFactor); z3= baseQuadCenter[2]-0.5;
      x4= baseQuadCenter[0]-(0.5*sizeFactor); y4= baseQuadCenter[1]+(0.5*sizeFactor); z4= baseQuadCenter[2]-0.5;
      y1+=retract; y2+=retract; y3-=retract; y4-=retract;
      x1+=retract; x2-=retract; x3-=retract; x4+=retract;
      dx=0.0; dy=0.0; dz=width;
    }
  else if(ySurfel)
    {
      x1= baseQuadCenter[0]-(0.5*sizeFactor); y1= baseQuadCenter[1]-0.5; z1= baseQuadCenter[2]-(0.5*sizeFactor);
      x2= baseQuadCenter[0]-(0.5*sizeFactor); y2= baseQuadCenter[1]-0.5; z2= baseQuadCenter[2]+(0.5*sizeFactor);
      x3= baseQuadCenter[0]+(0.5*sizeFactor); y3= baseQuadCenter[1]-0.5; z3= baseQuadCenter[2]+(0.5*sizeFactor);
      x4= baseQuadCenter[0]+(0.5*sizeFactor); y4= baseQuadCenter[1]-0.5; z4= baseQuadCenter[2]-(0.5*sizeFactor);
      x1+=retract; x2+=retract; x3-=retract; x4-=retract;
      z1+=retract; z2-=retract; z3-=retract; z4+=retract;
      dx=0.0; dy=width; dz=0.0;
    }
  else
    {
      x1= baseQuadCenter[0]-0.5; y1= baseQuadCenter[1]-(0.5*sizeFactor); z1= baseQuadCenter[2]-(0.5*sizeFactor);
      x2= baseQuadCenter[0]-0.5; y2= baseQuadCenter[1]+(0.5*sizeFactor); z2= baseQuadCenter[2]-(0.5*sizeFactor);
      x3= baseQuadCenter[0]-0.5; y3= baseQuadCenter[1]+(0.5*sizeFactor); z3= baseQuadCenter[2]+(0.5*sizeFactor);
      x4= baseQuadCenter[0]-0.5; y4= baseQuadCenter[1]-(0.5*sizeFactor); z4= baseQuadCenter[2]+(0.5*sizeFactor);
      y1+=retract; y2-=retract; y3-=retract; y4+=retract;
      z1+=retract; z2+=retract; z3-=retract; z4-=retract;
      dx=width; dy=0.0; dz=0.0;
    }

  double xcenter= (x1+x2+x3+x4)/4.0;
  double ycenter= (y1+y2+y3+y4)/4.0;
  double zcenter= (z1+z2+z3+z4)/4.0;

  x5=x1-dx; y5=y1-dy; z5= z1-dz;
  x6=x2-dx; y6=y2-dy; z6= z2-dz;
  x7=x3-dx; y7=y3-dy; z7= z3-dz;
  x8=x4-dx; y8=y4-dy; z8= z4-dz;

  x1=x1+dx; y1=y1+dy; z1= z1+dz;
  x2=x2+dx; y2=y2+dy; z2= z2+dz;
  x3=x3+dx; y3=y3+dy; z3= z3+dz;
  x4=x4+dx; y4=y4+dy; z4= z4+dz;

  //if cell is oriented positively we retrac the upper face:
  if(isSigned && aSign)
    {
      x1= 0.6*x1+0.4*xcenter; x2= 0.6*x2+0.4*xcenter; x3= 0.6*x3+0.4*xcenter; x4= 0.6*x4+0.4*xcenter;
      y1= 0.6*y1+0.4*ycenter; y2= 0.6*y2+0.4*ycenter; y3= 0.6*y3+0.4*ycenter; y4= 0.6*y4+0.4*ycenter;
      z1= 0.6*z1+0.4*zcenter; z2= 0.6*z2+0.4*zcenter; z3= 0.6*z3+0.4*zcenter; z4= 0.6*z4+0.4*zcenter;
    }else if (isSigned)
    {
      x5= 0.6*x5+0.4*xcenter; x6= 0.6*x6+0.4*xcenter; x7= 0.6*x7+0.4*xcenter; x8= 0.6*x8+0.4*xcenter;
      y5= 0.6*y5+0.4*ycenter; y6= 0.6*y6+0.4*ycenter; y7= 0.6*y7+0.4*ycenter; y8= 0.6*y8+0.4*ycenter;
      z5= 0.6*z5+0.4*zcenter; z6= 0.6*z6+0.4*zcenter; z7= 0.6*z7+0.4*zcenter; z8= 0.6*z8+0.4*zcenter;
    }

  const std::array<std::array<RealPoint, 4>, 6> points {
      std::array<RealPoint, 4> {
        RealPoint(x1, y1, z1), 
        RealPoint(x2, y2, z2), 
        RealPoint(x3, y3, z3), 
        RealPoint(x4, y4, z4)
      },
      std::array<RealPoint, 4> {
        RealPoint(x5, y5, z5), 
        RealPoint(x8, y8, z8), 
        RealPoint(x7, y7, z7), 
        RealPoint(x6, y6, z6)
      },
      std::array<RealPoint, 4> {
        RealPoint(x1, y1, z1), 
        RealPoint(x5, y5, z5), 
        RealPoint(x6, y6, z6), 
        RealPoint(x2, y2, z2)
      },
      std::array<RealPoint, 4> {
        RealPoint(x2, y2, z2), 
        RealPoint(x6, y6, z6), 
        RealPoint(x7, y7, z7), 
        RealPoint(x3, y3, z3)
      },
      std::array<RealPoint, 4> {
        RealPoint(x3, y3, z3), 
        RealPoint(x7, y7, z7), 
        RealPoint(x8, y8, z8), 
        RealPoint(x4, y4, z4)
      },
      std::array<RealPoint, 4> {
        RealPoint(x4, y4, z4), 
        RealPoint(x8, y8, z8), 
        RealPoint(x5, y5, z5), 
        RealPoint(x1, y1, z1)
      }
  };
  
  for (const auto& pts : points) {
      myPrismList.Append(pts, *myCurrentStyle.color, name3d());
  }
}

template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::addQuadFromSurfelCenter(const RealPoint &baseQuadCenter,
                                                           bool xSurfel, bool ySurfel, bool zSurfel)
{
  updateBoundingBox(baseQuadCenter);
  ASSERT( xSurfel || ySurfel || zSurfel );
  boost::ignore_unused_variable_warning( xSurfel );

  double x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4;

  if(zSurfel)
    {
      x1= baseQuadCenter[0]-0.5; y1= baseQuadCenter[1]-0.5; z1= baseQuadCenter[2]-0.5;
      x2= baseQuadCenter[0]+0.5; y2= baseQuadCenter[1]-0.5; z2= baseQuadCenter[2]-0.5;
      x3= baseQuadCenter[0]+0.5; y3= baseQuadCenter[1]+0.5; z3= baseQuadCenter[2]-0.5;
      x4= baseQuadCenter[0]-0.5; y4= baseQuadCenter[1]+0.5; z4= baseQuadCenter[2]-0.5;
    }
  else if(ySurfel)
    {
      x1= baseQuadCenter[0]-0.5; y1= baseQuadCenter[1]-0.5; z1= baseQuadCenter[2]-0.5;
      x2= baseQuadCenter[0]-0.5; y2= baseQuadCenter[1]-0.5; z2= baseQuadCenter[2]+0.5;
      x3= baseQuadCenter[0]+0.5; y3= baseQuadCenter[1]-0.5; z3= baseQuadCenter[2]+0.5;
      x4= baseQuadCenter[0]+0.5; y4= baseQuadCenter[1]-0.5; z4= baseQuadCenter[2]-0.5;
    }
  else
    {
      x1= baseQuadCenter[0]-0.5; y1= baseQuadCenter[1]-0.5; z1= baseQuadCenter[2]-0.5;
      x2= baseQuadCenter[0]-0.5; y2= baseQuadCenter[1]+0.5; z2= baseQuadCenter[2]-0.5;
      x3= baseQuadCenter[0]-0.5; y3= baseQuadCenter[1]+0.5; z3= baseQuadCenter[2]+0.5;
      x4= baseQuadCenter[0]-0.5; y4= baseQuadCenter[1]-0.5; z4= baseQuadCenter[2]+0.5;
    }

  addQuad(RealPoint(x1, y1, z1), RealPoint(x2 ,y2, z2),
          RealPoint(x3, y3, z3), RealPoint(x4, y4, z4));
}


template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::addQuadFromSurfelCenterWithNormal(const RealPoint &baseQuadCenter,
                                                                     bool xSurfel, bool ySurfel, bool zSurfel,
                                                                     const RealVector &aNormal,
                                                                     const bool enableReorientation,
                                                                     const bool sign,
                                                                     const bool enableDoubleFace )
{
  updateBoundingBox(baseQuadCenter);
  ASSERT( xSurfel || ySurfel || zSurfel );
  boost::ignore_unused_variable_warning( xSurfel );
  
  double x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4;

  if(zSurfel)
    {
      x1= baseQuadCenter[0]-0.5; y1= baseQuadCenter[1]-0.5; z1= baseQuadCenter[2]-0.5;
      x2= baseQuadCenter[0]+0.5; y2= baseQuadCenter[1]-0.5; z2= baseQuadCenter[2]-0.5;
      x3= baseQuadCenter[0]+0.5; y3= baseQuadCenter[1]+0.5; z3= baseQuadCenter[2]-0.5;
      x4= baseQuadCenter[0]-0.5; y4= baseQuadCenter[1]+0.5; z4= baseQuadCenter[2]-0.5;
    }
  else
    if(ySurfel)
      {
        x1= baseQuadCenter[0]-0.5; y1= baseQuadCenter[1]-0.5; z1= baseQuadCenter[2]-0.5;
        x2= baseQuadCenter[0]-0.5; y2= baseQuadCenter[1]-0.5; z2= baseQuadCenter[2]+0.5;
        x3= baseQuadCenter[0]+0.5; y3= baseQuadCenter[1]-0.5; z3= baseQuadCenter[2]+0.5;
        x4= baseQuadCenter[0]+0.5; y4= baseQuadCenter[1]-0.5; z4= baseQuadCenter[2]-0.5;
      }
    else
      {
        x1= baseQuadCenter[0]-0.5; y1= baseQuadCenter[1]-0.5; z1= baseQuadCenter[2]-0.5;
        x2= baseQuadCenter[0]-0.5; y2= baseQuadCenter[1]+0.5; z2= baseQuadCenter[2]-0.5;
        x3= baseQuadCenter[0]-0.5; y3= baseQuadCenter[1]+0.5; z3= baseQuadCenter[2]+0.5;
        x4= baseQuadCenter[0]-0.5; y4= baseQuadCenter[1]-0.5; z4= baseQuadCenter[2]+0.5;
      }
  
  //If we need to use the surfel sign and if it is negative, we
  //reorder the points (see drawOriented... vs drawUnoriented methods
  //in Display3DFactory).
  if ((!enableReorientation) && (!sign))
    addQuadWithNormal(RealPoint(x1, y1, z1),RealPoint(x4, y4, z4),
                      RealPoint(x3, y3, z3),
                      RealPoint(x2 ,y2, z2),  aNormal,
                      enableReorientation,
                      enableDoubleFace);
  else
    addQuadWithNormal(RealPoint(x1, y1, z1), RealPoint(x2 ,y2, z2),
                      RealPoint(x3, y3, z3), RealPoint(x4, y4, z4), aNormal,
                      enableReorientation,
                      enableDoubleFace);
}




// add multiple triangular faces which form a hexagonal-based pyramid
template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::addCone(const RealPoint &p1, const RealPoint &p2,
                                           double width)
{
  updateBoundingBox(p1);
  updateBoundingBox(p2);

  int nbPoints = 6; //the number of point on the base of the cone
  double degree = 360 / nbPoints; // the angle between two points
  double radian = degree * M_PI/180.0;
  double norm; // norm of the vectors

  // A(x1,y1,z1) and B(x2,y2,z2) vector AB
  double xab, yab, zab;

  xab = p2[0]-p1[0];
  yab = p2[1]-p1[1];
  zab = p2[2]-p1[2];

  norm = sqrt( xab*xab + yab*yab + zab*zab);
	if (norm == 0) return;
	xab /= norm;
	yab /= norm;
	zab /= norm;

  //take a third point M different from A and B
  double xm = 0;
  double ym = 0;
  double zm = 0;

  while (p1[0] == xm || p2[0] ==xm) xm++;
  while (p1[1] == ym || p2[1] ==ym) ym++;
  while (p1[2] == zm || p2[2] ==zm) zm++;

	//vector AM
	double xam, yam, zam;
	//normal vector n = AB^AM
	double xn, yn, zn;

	// ensure that M is not collinear to AB
	while (true)
	{
			xam = xm-p1[0];
			yam = ym-p1[1];
			zam = zm-p1[2];

			norm = sqrt( xam*xam + yam*yam + zam*zam);
			ASSERT( norm > 0 );
			xam /= norm;
			yam /= norm;
			zam /= norm;

			xn = yab*zam - yam*zab;
			yn = xam*zab - xab*zam;
			zn = xab*yam - xam*yab;

			//divide n by its norm
			norm = sqrt( xn*xn + yn*yn + zn*zn);
			if (norm > 0) break;
			xm += .1;
			ym -= M_PI;
	}

	ASSERT( norm > 0 );
	xn /= norm;
	yn /= norm;
	zn /= norm;

  //the first point of the base
  double xf, yf, zf;

  xf = p2[0] + width * xn;
  yf = p2[1] + width * yn;
  zf = p2[2] + width * zn;

  //two following points of the base
  double xb1 = xf;
  double yb1 = yf;
  double zb1 = zf;
  double xb2,yb2, zb2;

  //r = AB^n for the future rotation
  double xr, yr, zr;

  createNewTriangleList("Cone");
  for (int i =0; i < nbPoints-1; i ++)
    {
      // r = AB^n
      xr = yab*zn - yn*zab;
      yr = xn*zab - xab*zn;
      zr = xab*yn - xn*yab;

      //rotate n by degree
      xn = cos(radian)*xn + sin(radian)*xr;
      yn = cos(radian)*yn + sin(radian)*yr;
      zn = cos(radian)*zn + sin(radian)*zr;

      //divide n by its norm
      norm = sqrt( xn*xn + yn*yn + zn*zn);
      if (norm > 0)
			{
					xn = xn / norm;
					yn = yn / norm;
					zn = zn / norm;
			}

      // calculate one point with the normal vector at a distance width
      xb2 = p2[0] + width * xn;
      yb2 = p2[1] + width * yn;
      zb2 = p2[2] + width * zn;

      //adding the triangles associated with this point
      addTriangle(p1,
		  RealPoint(xb1, yb1, zb1),
		  RealPoint(xb2, yb2, zb2));
      addTriangle(p2,
		  RealPoint(xb1, yb1, zb1),
		  RealPoint(xb2, yb2, zb2));

      xb1 = xb2;
      yb1 = yb2;
      zb1 = zb2;
    }

  //Last part to close the cone
  addTriangle(p1,
              RealPoint(xb1, yb1,zb1),
              RealPoint(xf, yf, zf));
  addTriangle(p2,
              RealPoint(xb1, yb1, zb1),
              RealPoint(xf, yf, zf));
}

// add multiple triangular faces which form a hexagonal-based cylinder
template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::addCylinder(const RealPoint &p1, const RealPoint &p2,
                                               const double width)
{
  updateBoundingBox(p1);
  updateBoundingBox(p2);

  int nbPoints = 6; //the number of point on the base of the cone
  double degree = 360 / nbPoints; // the angle between two points
  double radian = degree * M_PI/180.0;
  double norm; // norm of the vectors

  // A(p1[0],p1[1],p1[2]) and B(p2[0],p2[1],p2[2]) vector AB
  double xab, yab, zab;

  xab = p2[0]-p1[0];
  yab = p2[1]-p1[1];
  zab = p2[2]-p1[2];

  norm = sqrt( xab*xab + yab*yab + zab*zab);
  assert (norm > 0);
  xab = xab / norm;
  yab = yab / norm;
  zab = zab / norm;

  //take a third point M different from A and B
  double xm = 0;
  double ym = 0;
  double zm = 0;

  while (p1[0] == xm || p2[0] ==xm) xm++;
  while (p1[1] == ym || p2[1] ==ym) ym++;
  while (p1[2] == zm || p2[2] ==zm) zm++;

  //vector AM
  double xam, yam, zam;

  xam = xm-p1[0];
  yam = ym-p1[1];
  zam = zm-p1[2];

  norm = sqrt( xam*xam + yam*yam + zam*zam);
  assert (norm > 0);
  xam = xam / norm;
  yam = yam / norm;
  zam = zam / norm;

  //normal vector n = AB^AM
  double xn, yn, zn;

  xn = yab*zam - yam*zab;
  yn = xam*zab - xab*zam;
  zn = xab*yam - xam*yab;

  //divide n by its norm
  norm = sqrt( xn*xn + yn*yn + zn*zn);
  assert (norm > 0);
  xn = xn / norm;
  yn = yn / norm;
  zn = zn / norm;


  //the first point of the bases
  double xbf, ybf, zbf;
  double xaf, yaf, zaf;

  xbf = p2[0] + width * xn;
  ybf = p2[1] + width * yn;
  zbf = p2[2] + width * zn;

  xaf = p1[0] + width * xn;
  yaf = p1[1] + width * yn;
  zaf = p1[2] + width * zn;

  //two following points of the bases
  double xb1 = xbf;
  double yb1 = ybf;
  double zb1 = zbf;
  double xb2,yb2, zb2;

  double xa1 = xaf;
  double ya1 = yaf;
  double za1 = zaf;
  double xa2,ya2, za2;

  //r = AB^n for the future rotation
  double xr, yr, zr;

  createNewTriangleList("Cylinder");
  //createNewQuadList("Cylinder");
  for (int i =0; i < nbPoints-1; i ++)
    {
      // r = AB^n
      xr = yab*zn - yn*zab;
      yr = xn*zab - xab*zn;
      zr = xab*yn - xn*yab;

      //rotate n by degree
      xn = cos(radian)*xn + sin(radian)*xr;
      yn = cos(radian)*yn + sin(radian)*yr;
      zn = cos(radian)*zn + sin(radian)*zr;

      //divide n by its norm (used when a bug appear)
      norm = sqrt( xn*xn + yn*yn + zn*zn);
      assert (norm > 0);
      xn = xn / norm;
      yn = yn / norm;
      zn = zn / norm;

      // calculate one point with the normal vector at a distance width
      xb2 = p2[0] + width * xn;
      yb2 = p2[1] + width * yn;
      zb2 = p2[2] + width * zn;

      xa2 = p1[0] + width * xn;
      ya2 = p1[1] + width * yn;
      za2 = p1[2] + width * zn;

      //adding the triangles and the quad associated with those poins
      addTriangle(p1,
		  RealPoint(xa1, ya1, za1),
		  RealPoint(xa2, ya2, za2));
      addTriangle(p2,
		  RealPoint(xb1, yb1, zb1),
		  RealPoint(xb2, yb2, zb2));
      addQuad(RealPoint(xb1, yb1, zb1),
	      RealPoint(xb2, yb2, zb2),
	      RealPoint(xa2, ya2, za2),
	      RealPoint(xa1, ya1, za1));

      xb1 = xb2;
      yb1 = yb2;
      zb1 = zb2;

      xa1 = xa2;
      ya1 = ya2;
      za1 = za2;

    }

  //Last part to close the cylinder
  addTriangle(p1,
	      RealPoint(xa1, ya1, za1),
	      RealPoint(xaf, yaf, zaf));
  addTriangle(p2,
	      RealPoint(xb1, yb1, zb1),
	      RealPoint(xbf, ybf, zbf));
  addQuad(RealPoint(xb1, yb1, zb1),
	  RealPoint(xbf, ybf, zbf),
	  RealPoint(xaf, yaf, zaf),
	  RealPoint(xa1, ya1, za1));
}

template<typename Space, typename KSpace>
template<typename TImage, typename TFunctor>
inline
void 
DGtal::Display3D<Space, KSpace>::addImage(const TImage& image, const TFunctor& functor)
{
    ImageD3D im;
    im.setData(image, functor);
    myImageSetList.push_back(std::move(im));
}

template<typename Space, typename KSpace>
inline
void 
DGtal::Display3D<Space, KSpace>::updateImagePosition(size_t index, RealPoint p, DGtal::ImageDirection dir)
{
    myImageSetList[index].transform.setIdentity();

    myImageSetList[index].transform.translate(Eigen::Vector3d(p[0], p[1], p[2]));
    myImageSetList[index].transform.rotate(myImageSetList[index].directionToRotation(dir));
}

template<typename Space, typename KSpace>
inline
void 
DGtal::Display3D<Space, KSpace>::updateLastImagePosition(RealPoint p, DGtal::ImageDirection dir)
{
    updateImagePosition(myImageSetList.size() - 1, p, dir);
}

template<typename Space, typename KSpace>
inline
void 
DGtal::Display3D<Space, KSpace>::update2DImage3DEmbedding(size_t index, RealPoint lowerLeft, RealPoint upperLeft, RealPoint lowerRight)
{
    Eigen::Vector3d a = { upperLeft[0]  - lowerLeft[0], upperLeft[1]  - lowerLeft[1], upperLeft[2]  - lowerLeft[2] };
    Eigen::Vector3d b = { lowerRight[0] - lowerLeft[0], lowerRight[1] - lowerLeft[1], lowerRight[2] - lowerLeft[2] };

    // Images are supposed to be defaulted at the x-direction
    Eigen::Vector3d x = {1, 0, 0};
    Eigen::Vector3d n = a.cross(b.normalized());
    
    auto& image = myImageSetList[index];
    image.transform.linear() = Eigen::Quaterniond().setFromTwoVectors(x, n).toRotationMatrix();
    image.transform.translation() = Eigen::Vector3d{lowerLeft[0], lowerLeft[1], lowerLeft[2]};
    
    // TODO: Allow for different values in x/y/z directions ?
    image.voxelWidth = std::min(a.norm(), b.norm());
}

template<typename Space, typename KSpace>
template<typename TImage, typename TFunctor>
inline
void 
DGtal::Display3D<Space, KSpace>::updateImage(size_t index, const TImage& newImage, const TFunctor& myFunctor, RealPoint translate, double rotate, DGtal::ImageDirection dir)
{
    myImageSetList[index].setData(newImage, functors::Cast<typename TImage::Value>());
    
    auto& transform = myImageSetList[index].transform;
    transform.translate(Eigen::Vector3d(translate[0], translate[1], translate[2]));
    
    Eigen::Vector3d center = transform.translation();
    Eigen::Matrix3d rotation;
    switch(dir)
    {
    case DGtal::yDirection:
        rotation = Eigen::AngleAxisd(rotate, Eigen::Vector3d::UnitY()).toRotationMatrix();
    case DGtal::zDirection:
        rotation = Eigen::AngleAxisd(rotate, Eigen::Vector3d::UnitZ()).toRotationMatrix();
    case DGtal::xDirection:
    case DGtal::undefDirection:
    default:
        rotation = Eigen::AngleAxisd(rotate, Eigen::Vector3d::UnitX()).toRotationMatrix();
    }
    
    transform.linear() = rotation * transform.linear();
    transform.translation() = center + rotation * (transform.translation() - center);
    return; 
}



template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::addClippingPlane(double a, double b, double c, double d, bool drawPlane)
{
  ClippingPlaneD3D cp;
  cp.a=a; cp.b=b; cp.c=c; cp.d=d;
  myClippingPlaneList.push_back(cp);
  if(drawPlane)
    {
      double x1,x2,x3,x4;
      double y1,y2,y3,y4;
      double z1,z2,z3,z4;
      double norm = sqrt(a*a+b*b+c*c);
      double dec=0.1;
      // Z dominant projection of the upper face
      if(std::abs(c)>=std::abs(b) && std::abs(c) >= std::abs(a))
	{
	  x1= myBoundingPtUp[0]+a*dec/norm; y1= myBoundingPtUp[1]+b*dec/norm;
	  z1 = c*dec/norm +(-d-a*myBoundingPtUp[0]-b*myBoundingPtUp[1])/c;
	  x2= myBoundingPtLow[0]+a*dec/norm; y2= myBoundingPtUp[1]+b*dec/norm;
	  z2= c*dec/norm+(-d-a*myBoundingPtLow[0]-b*myBoundingPtUp[1])/c;
	  x3= myBoundingPtLow[0]+a*dec/norm; y3= myBoundingPtLow[1]+b*dec/norm;
	  z3= c*dec/norm+(-d-a*myBoundingPtLow[0]-b*myBoundingPtLow[1])/c;
	  x4= myBoundingPtUp[0]+a*dec/norm; y4= myBoundingPtLow[1]+b*dec/norm;
	  z4= c*dec/norm+(-d-a*myBoundingPtUp[0]-b*myBoundingPtLow[1])/c;
	  if(c>0)
	    {
	      addQuad(RealPoint(x4,y4,z4),RealPoint(x3,y3,z3),
		      RealPoint(x2,y2,z2),RealPoint(x1,y1,z1) );
	    }else
	    {
	      addQuad(RealPoint(x1,y1,z1), RealPoint( x2,y2,z2),
		      RealPoint(x3,y3,z3), RealPoint(x4,y4,z4));
	    }
	}// Y dominant projection of the upper face
      else if(std::abs(b)>=std::abs(c) && std::abs(b) >= std::abs(a))
	{
	  x1= myBoundingPtUp[0]+a*dec/norm; z1= myBoundingPtUp[2]+c*dec/norm;
	  y1= b*dec/norm +(-d-a*myBoundingPtUp[0]-c*myBoundingPtUp[2])/b;
	  x2= myBoundingPtUp[0]+a*dec/norm; z2= myBoundingPtLow[2]+c*dec/norm;
	  y2= b*dec/norm +(-d-a*myBoundingPtUp[0]-c*myBoundingPtLow[2])/b;
	  x3= myBoundingPtLow[0]+a*dec/norm; z3= myBoundingPtLow[2]+c*dec/norm;
	  y3= b*dec/norm +(-d-a*myBoundingPtLow[0]-c*myBoundingPtLow[2])/b;
	  x4= myBoundingPtLow[0]+a*dec/norm; z4= myBoundingPtUp[2]+c*dec/norm;
	  y4= b*dec/norm +(-d-a*myBoundingPtLow[0]-c*myBoundingPtUp[2])/b;
	  if(b>0)
	    {
	      addQuad(RealPoint(x4,y4,z4),RealPoint(x3, y3,z3),
		      RealPoint(x2,y2,z2), RealPoint(x1,y1,z1));
	    }else
	    {
	      addQuad(RealPoint(x1,y1,z1), RealPoint(x2,y2,z2),
		      RealPoint(x3,y3,z3), RealPoint(x4,y4,z4));
	    }
	}// X dominant projection of the upper face
      else if(std::abs(a)>=std::abs(c) && std::abs(a) >= std::abs(b))
	{
	  y1= myBoundingPtUp[1]+b*dec/norm; z1= myBoundingPtUp[2]+c*dec/norm;
	  x1= a*dec/norm +(-d-b*myBoundingPtUp[1]-c*myBoundingPtUp[2])/a;
	  y2= myBoundingPtLow[1]+b*dec/norm; z2= myBoundingPtUp[2]+c*dec/norm;
	  x2= a*dec/norm +(-d-b*myBoundingPtLow[1]-c*myBoundingPtUp[2])/a;
	  y3= myBoundingPtLow[1]+b*dec/norm; z3= myBoundingPtLow[2]+c*dec/norm;
	  x3= a*dec/norm +(-d-b*myBoundingPtLow[1]-c*myBoundingPtLow[2])/a;
	  y4= myBoundingPtUp[1]+b*dec/norm; z4= myBoundingPtLow[2]+c*dec/norm;
	  x4= a*dec/norm +(-d-b*myBoundingPtUp[1]-c*myBoundingPtLow[2])/a;

	  if(a>0)
	    {

	      addQuad(RealPoint(x4,y4,z4),
		      RealPoint(x3,y3,z3),
		      RealPoint(x2,y2,z2),
		      RealPoint(x1,y1,z1));
	    }else
	    {
	      addQuad( RealPoint(x1,y1,z1), RealPoint(x2,y2,z2),
		       RealPoint(x3,y3,z3),RealPoint(x4,y4,z4));
	    }
	}
    }
}


template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::updateBoundingBox(const RealPoint &p)
{
  if (myBoundingPtEmptyTag)
    {
      myBoundingPtLow[0]= p[0];
      myBoundingPtLow[1]= p[1];
      myBoundingPtLow[2]= p[2];
      myBoundingPtUp[0]= p[0];
      myBoundingPtUp[1]= p[1];
      myBoundingPtUp[2]= p[2];
      myBoundingPtEmptyTag = false;
      myBoundingPtChangedTag = true;
    }
  else
    {
      if ( p[ 0 ] < myBoundingPtLow[ 0 ] )
      {
        myBoundingPtLow[ 0 ]   = p[ 0 ];
        myBoundingPtChangedTag = true;
      }
      if ( p[ 1 ] < myBoundingPtLow[ 1 ] )
      {
        myBoundingPtLow[ 1 ]   = p[ 1 ];
        myBoundingPtChangedTag = true;
      }

      if ( p[ 2 ] < myBoundingPtLow[ 2 ] )
      {
        myBoundingPtLow[ 2 ]   = p[ 2 ];
        myBoundingPtChangedTag = true;
      }

      if ( p[ 0 ] > myBoundingPtUp[ 0 ] )
      {
        myBoundingPtUp[ 0 ]    = p[ 0 ];
        myBoundingPtChangedTag = true;
      }
      if ( p[ 1 ] > myBoundingPtUp[ 1 ] )
      {
        myBoundingPtUp[ 1 ]    = p[ 1 ];
        myBoundingPtChangedTag = true;
      }
      if ( p[ 2 ] > myBoundingPtUp[ 2 ] )
      {
        myBoundingPtUp[ 2 ]    = p[ 2 ];
        myBoundingPtChangedTag = true;
      }
    }
}


template < typename Space ,typename KSpace >
inline
typename DGtal::Display3D< Space ,KSpace >::RealPoint
DGtal::Display3D< Space ,KSpace >::embed( const typename Space::Point & dp ) const
{
  ASSERT( myEmbedder->isValid());
  return myEmbedder->embed(dp);
}

template < typename Space ,typename KSpace >
inline
typename DGtal::Display3D< Space ,KSpace >::RealPoint
DGtal::Display3D< Space ,KSpace >::embedKS( const typename KSpace::SCell & scell ) const
{
  ASSERT( mySCellEmbedder->isValid());
  return mySCellEmbedder->embed(scell);
}

template < typename Space ,typename KSpace >
inline
typename DGtal::Display3D< Space ,KSpace >::RealPoint
DGtal::Display3D< Space ,KSpace >::embedKS( const TransformedPrism & aTrans ) const
{
  ASSERT( mySCellEmbedder->isValid());
  return mySCellEmbedder->embed(aTrans.mySurfel);
}


template < typename Space ,typename KSpace >
inline
typename DGtal::Display3D< Space ,KSpace >::RealPoint
DGtal::Display3D< Space ,KSpace >::embedK( const typename KSpace::Cell & cell ) const
{
  ASSERT( myCellEmbedder->isValid());
  return myCellEmbedder->embed(cell);
}

template <typename Group>
inline void AddToMesh(
    DGtal::Mesh<typename Group::Data::Vetex>& aMesh, 
    const Group& group, 
    size_t& totalIndex
) {
  static constexpr std::array<std::array<int, 4>, 6> voxel_to_quads { {
      { 0, 1, 2, 3 }, // Front
      { 4, 5, 6, 7 }, // Back
      { 0, 1, 5, 4 }, // Down
      { 3, 2, 6, 7 }, // Up
      { 0, 4, 7, 3 }, // Left
      { 1, 5, 6, 2 }  // Right
  }};
  for (const auto& data : group.groups) {
    const std::string& colorName = data.DEFAULT_COLOR_NAME;
    const bool hasColor = data.colors[
      data.DEFAULT_COLOR_NAME
    ].size() != 0;
    
    const size_t indicesPerFace = data.indices[0].size();

    for (size_t i = 0; i < data.indices.size(); ++i) {
      for (size_t j = 0; j < data.indices[i].size(); ++j) {
        aMesh.addVertex(data.vertices[data.indices[i][j]]);
      }

      const DGtal::Color color = 
          hasColor ? data.colors[colorName][i] : data.style->color;

      switch(Group::Data::INDEX_SIZE) {
      case 3:
        aMesh.addTriangularFace(
          totalIndex + data.indices[i][0],
          totalIndex + data.indices[i][1], 
          totalIndex + data.indices[i][2],
          color
        );
        break;
      case 4: 
        aMesh.addQuadFace(
          totalIndex + data.indices[i][0],
          totalIndex + data.indices[i][1], 
          totalIndex + data.indices[i][2],
          totalIndex + data.indices[i][3],
          color
        );
        break;
      case 8:
        for (const auto& map : voxel_to_quads) {
          aMesh.addQuadFace(
              totalIndex + data.indices[i][map[0]],
              totalIndex + data.indices[i][map[1]],
              totalIndex + data.indices[i][map[2]],
              totalIndex + data.indices[i][map[3]],
              color
          );
        }
        break; 
      case 0: // variable size
      default:
        break;
      };
    }
    totalIndex += data.indices.size();
  }
}

template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::exportToMesh(DGtal::Mesh<RealPoint> &aMesh) const
{
  unsigned int vertexIndex=0;
  
  AddToMesh(myPrismList);
  AddToMesh(myQuadsMap);
  AddToMesh(myTriangleSetList);
  AddToMesh(myCubesMap);
}


template < typename Space ,typename KSpace >
template<typename TDrawableWithDisplay3D>
inline
DGtal::Display3D< Space ,KSpace >&
DGtal::Display3D< Space ,KSpace >::operator <<( const TDrawableWithDisplay3D & object )
{
  // BOOST_CONCEPT_ASSERT((CDrawableWithDisplay3D< TDrawableWithDisplay3D >));

  DGtal::Display3DFactory<Space,KSpace>::draw(*this, object);
  return *this;
}


template < typename Space ,typename KSpace >
inline
std::ostream&
DGtal::operator<< ( std::ostream & out,
                    const Display3D< Space ,KSpace >& object )
{
  object.selfDisplay ( out );
  return out;
}


template < typename Space ,typename KSpace >
inline
void
DGtal::operator>> ( const Display3D< Space ,KSpace >&aDisplay3D, DGtal::Mesh< typename Display3D<Space , KSpace >::RealPoint > &aMesh)
{
  aDisplay3D.exportToMesh(aMesh);
}


template < typename Space ,typename KSpace >
inline
void
DGtal::operator>> ( const Display3D< Space ,KSpace >&aDisplay3D, std::string aFilename)
{
  // exporting with a mesh containing color (parameter constructor to true):
  DGtal::Mesh<typename Display3D<Space , KSpace >::RealPoint> mesh(true);
  aDisplay3D >> mesh;
  trace.info() << "generating faces done." << std::endl;
  mesh >> aFilename;
  trace.info() << "file exported in file: " << aFilename << std::endl;
}


template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::cross (double dst[3], double srcA[3], double srcB[3])
{
  dst[0] = srcA[1]*srcB[2] - srcA[2]*srcB[1];
  dst[1] = srcA[2]*srcB[0] - srcA[0]*srcB[2];
  dst[2] = srcA[0]*srcB[1] - srcA[1]*srcB[0];
}


template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::normalize (double vec[3])
{
  const double squaredLen = vec[0]*vec[0] + vec[1]*vec[1] + vec[2]*vec[2];
  vec[0] /= sqrt (squaredLen);
  vec[1] /= sqrt (squaredLen);
  vec[2] /= sqrt (squaredLen);
}

template < typename Space ,typename KSpace >
inline
bool
DGtal::Display3D< Space ,KSpace >::isValid() const
{
  return      myEmbedder->isValid()
          &&  myCellEmbedder->isValid()
          &&  mySCellEmbedder->isValid();
}

template < typename Space ,typename KSpace >
inline
void
DGtal::Display3D< Space ,KSpace >::clear()
{
  myCubesMap.clear();
  myLineSetList.clear();
  myBallSetList.clear();
  myClippingPlaneList.clear();
  myPrismList.clear();
  myQuadsMap.clear();
  myTriangleSetList.clear();
  myPolygonSetList.clear();

  //Bounding box reset
  myBoundingPtEmptyTag = true;
  for (unsigned int i=0; i< 3; i++)
    {
      myBoundingPtUp[i] = 0.0;
      myBoundingPtLow[i] = 0.0;
    }
}



// //
///////////////////////////////////////////////////////////////////////////////
