/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 **/

/**
 * @file   Display2DFactory.ih
 * @author Martial Tola <http://liris.cnrs.fr/martial.tola/>
 * @date   mercredi 28 septembre 2011
 * 
 * @brief
 *
 * Implementation of inline methods defined in Display2DFactory.h
 *
 * This file is part of the DGtal library.
 */

///////////////////////////////////////////////////////////////////////////////
// Implementation of inline methods                                          //


///////////////////////////////////////////////////////////////////////////////
// Implementation of inline functions and external operators                 //


// ArithmeticalDSS
template <typename TIterator, typename TInteger, int connectivity>
inline
void drawAsBoundingBox( DGtal::Board2D & aBoard, 
           const DGtal::ArithmeticalDSS<TIterator,TInteger,connectivity> & a )
{
  typedef DGtal::PointVector<2,double> PointD;
  
  //draw bounding box
  PointD topLeft = a.project(*a.myF, a.myUf);
  PointD bottomLeft = a.project(*a.myF, a.myLf);
  PointD bottomRight = a.project(*a.myL, a.myLf);
  PointD topRight = a.project(*a.myL, a.myUf);
  

  LibBoard::Point topLeftBoard(topLeft[0],topLeft[1]);
  LibBoard::Point bottomLeftBoard(bottomLeft[0],bottomLeft[1]);
  LibBoard::Point bottomRightBoard(bottomRight[0],bottomRight[1]);
  LibBoard::Point topRightBoard(topRight[0],topRight[1]);
  
  vector<LibBoard::Point> bb;
  bb.push_back(topLeftBoard);
  bb.push_back(bottomLeftBoard);
  bb.push_back(bottomRightBoard);
  bb.push_back(topRightBoard);
  
  aBoard.drawClosedPolyline(bb);
}
  
template <typename TIterator, typename TInteger, int connectivity>
inline
void drawAsDigitalPoints( DGtal::Board2D & aBoard, 
           const DGtal::ArithmeticalDSS<TIterator,TInteger,connectivity> & a )
{
  typedef TIterator ConstIterator;
  typedef typename IteratorCirculatorTraits<ConstIterator>::Value Point; 
  
  ConstIterator itend = a.myL; ++itend;

  // Draw a linking polygonal line if the pixels are drawn as points. 
  if(aBoard.getMode("PointVector")=="Grid" || aBoard.getMode("PointVector")=="")
    {
      vector<LibBoard::Point> contour;
      for (ConstIterator i = a.myF; i != itend; ++i) {
        Point p = *i;
        double xp = NumberTraits<TInteger>::castToDouble(p[0]);
        double yp = NumberTraits<TInteger>::castToDouble(p[1]);
        contour.push_back(LibBoard::Point(xp,yp));
      }
      aBoard.drawPolyline(contour);
    }

  // Draw points
  for (ConstIterator i = a.myF; i != itend; ++i) {
    Point p = *i;
    aBoard << p;
  }
}
  
template <typename TIterator, typename TInteger, int connectivity>
inline
void draw( DGtal::Board2D & board, 
	   const DGtal::ArithmeticalDSS<TIterator,TInteger,connectivity> & a )
{
  std::string mode = board.getMode( a.styleName() );
  if ( mode == "BoundingBox" )
    drawAsBoundingBox( board, a );
  else if ( mode == "Points" )
    drawAsDigitalPoints( board, a );
  else if ( ( mode == "" ) )
    {
      drawAsDigitalPoints( board, a );
      drawAsBoundingBox( board, a );
    }
  else
    ASSERT(false && ("draw( DGtal::Board2D & board, const DGtal::ArithmeticalDSS<TIterator,TInteger,connectivity> & a ): Unknown mode "+mode)==""  );

}
// ArithmeticalDSS


// FreemanChain
template <typename TInteger>
inline
void drawAsGrid( DGtal::Board2D & aBoard,
           const DGtal::FreemanChain<TInteger> & f )
{
  typedef TInteger Integer;
  typedef PointVector<2, Integer> Point;
  
  vector<Point> aVContour;
  FreemanChain<TInteger>::getContourPoints(f, aVContour);
  TInteger minX, minY, maxX, maxY;
  f.computeBoundingBox(minX, minY, maxX, maxY);
  
  vector<LibBoard::Point> contour;
  for(unsigned int i=0; i< aVContour.size(); i++){
    contour.push_back(LibBoard::Point(NumberTraits<TInteger>::castToDouble(aVContour[i][0]),
              NumberTraits<TInteger>::castToDouble(aVContour[i][1])));
  }
  aBoard.drawPolyline(contour);
}

template <typename TInteger>
inline
void drawAsInterGrid( DGtal::Board2D & aBoard,
           const DGtal::FreemanChain<TInteger> & f )
{
  typedef TInteger Integer;
  typedef PointVector<2, Integer> Point;
  
  vector<Point> aVContour;
  FreemanChain<TInteger>::getContourPoints(f, aVContour);
  TInteger minX, minY, maxX, maxY;
  f.computeBoundingBox(minX, minY, maxX, maxY);
  
  vector<LibBoard::Point> contour;
  for(unsigned int i=0; i< aVContour.size(); i++){
    contour.push_back(LibBoard::Point(NumberTraits<TInteger>::castToInt64_t(aVContour[i][0])-0.5,
              NumberTraits<TInteger>::castToInt64_t(aVContour[i][1])+0.5));
  }
  aBoard.drawPolyline(contour);
}

template <typename TInteger>
inline
void draw( DGtal::Board2D & aBoard,
	   const DGtal::FreemanChain<TInteger> & f )
{
  std::string mode = aBoard.getMode( f.styleName() );
  ASSERT( (mode=="Grid" || mode=="" || mode=="InterGrid") ||
    ("draw( DGtal::Board2D & board, const DGtal::FreemanChain<TInteger> & f ): Unknown mode "+mode)==""  );
  
  if ( mode == "Grid"  || ( mode == "" )  )
    drawAsGrid( aBoard, f );
  else if ( mode == "InterGrid" )
    drawAsInterGrid( aBoard, f );
}
// FreemanChain


// GridCurve
// we use selfDraw because of inner classes
// GridCurve


// Preimage2D
template <typename Shape>
inline
void draw( DGtal::Board2D & aBoard,
	   const DGtal::Preimage2D<Shape> & p )
{
  typedef typename Shape::Point Point;
  typedef typename std::list<Point>::const_iterator ConstForwardIterator;
  
  Shape s( p.myShape ); 
  ConstForwardIterator i = p.myPHull.begin();
  Point pt(*i);
  ++i;
  while ( i != p.myPHull.end() ) {
    s.init(pt, *i);
    draw(aBoard, *i);//s.selfDraw(aBoard); // Caution, don't know if it's good
    pt = Point(*i);
    ++i;
  }

  i = p.myQHull.begin();
  pt = Point(*i);
  ++i;
  while ( i != p.myQHull.end() ) {
    s.init(pt, *i);
    draw(aBoard, *i);//s.selfDraw(aBoard); // Caution, don't know if it's good
    pt = Point(*i);
    ++i;
  }

  Point Pf(*p.myPHull.begin());
  Point Pl(*p.myPHull.rbegin());
  Point Qf(*p.myQHull.begin());
  Point Ql(*p.myQHull.rbegin());

  s.init(Pf, Ql);
  draw(aBoard, Ql);//s.selfDraw(aBoard); // Caution, don't know if it's good
  s.init(Qf, Pl);
  draw(aBoard, Pl);//s.selfDraw(aBoard); // Caution, don't know if it's good
}
// Preimage2D


// PointVector
template<Dimension dim, typename TComponent>
inline
void drawAsPaving( DGtal::Board2D & board, 
           const DGtal::PointVector<dim,TComponent> & p )
{
  ASSERT(dim == 2);
  board.drawRectangle( (float) NumberTraits<TComponent>::castToInt64_t(p.myArray[0]) - 0.5f, 
            (float) NumberTraits<TComponent>::castToInt64_t(p.myArray[1]) + 0.5f, 1, 1 );     
}

template<Dimension dim, typename TComponent>
inline
void drawAsGrid( DGtal::Board2D & board, 
           const DGtal::PointVector<dim,TComponent> & p )
{
  ASSERT(dim == 2);
  board.setPenColor(Color::Black);
  board.fillCircle((float) NumberTraits<TComponent>::castToInt64_t(p.myArray[0]), 
       (float) NumberTraits<TComponent>::castToInt64_t(p.myArray[1]),0.1);
}
  
template<Dimension dim, typename TComponent>
inline
void draw( DGtal::Board2D & board, 
	   const DGtal::PointVector<dim,TComponent> & p )
{
  std::string mode = board.getMode( p.styleName() );
  ASSERT( (mode=="Paving" || mode=="Grid" || mode=="Both" || mode=="") ||
    ("draw( DGtal::Board2D & board, const DGtal::PointVector<dim,TComponent> & p ): Unknown mode "+mode)==""  );

  if ( mode == "Paving"  || ( mode == "" )  )
    drawAsPaving( board, p );
  else if ( mode == "Grid" )
    drawAsGrid( board, p );
  else if ( ( mode == "Both" ))
    {
      drawAsPaving( board, p );
      drawAsGrid( board, p );
    }
}

template<Dimension dim, typename TComponent>
inline
void draw( DGtal::Board2D & board, 
          const DGtal::PointVector<dim,TComponent> & apoint, 
          const DGtal::PointVector<dim,TComponent> & p )
{
  ASSERT(dim == 2);

  board.drawArrow((float)apoint[0], (float) apoint[1],
      (float) apoint[0] + p.myArray[0], (float)apoint[1] + p.myArray[1],
      true);
}
// PointVector


// HyperRectDomain
template<typename TSpace>
inline
void drawAsGrid( DGtal::Board2D & aboard, 
           const DGtal::HyperRectDomain<TSpace> & h )
{
  typedef typename TSpace::Integer Integer;
  
  ASSERT(TSpace::dimension == 2 || "drawAsGrid-NOT-YET-IMPLEMENTED-in-ND");

  if (TSpace::dimension == 2)
  {
    for (double x = NumberTraits<Integer>::castToDouble(h.myLowerBound[0]); 
   x <=  NumberTraits<Integer>::castToDouble(h.myUpperBound[0]); x++)
      aboard.drawLine(x,
          NumberTraits<Integer>::castToDouble(h.myLowerBound[1]) -
          0.5,
          x, 
          NumberTraits<Integer>::castToDouble(h.myUpperBound[1]) +
          0.5);

    for (double y =  NumberTraits<Integer>::castToDouble(h.myLowerBound[1]);
   y <=  NumberTraits<Integer>::castToDouble(h.myUpperBound[1]); y++)
      aboard.drawLine(NumberTraits<Integer>::castToDouble(h.myLowerBound[0]) -
          0.5,
          y, 
          NumberTraits<Integer>::castToDouble(h.myUpperBound[0]) +
          0.5,
          y);

    for (double x =  NumberTraits<Integer>::castToDouble(h.myLowerBound[0]); 
   x <=  NumberTraits<Integer>::castToDouble(h.myUpperBound[0]); x++)
      for (double y =  NumberTraits<Integer>::castToDouble(h.myLowerBound[1]);
     y <=  NumberTraits<Integer>::castToDouble(h.myUpperBound[1]); y++)
        aboard.fillCircle(x, y, 0.1);
  }
}

template<typename TSpace>
inline
void drawAsPaving( DGtal::Board2D & aboard, 
           const DGtal::HyperRectDomain<TSpace> & h )
{
  typedef typename TSpace::Integer Integer;
  
  ASSERT(TSpace::dimension==2 || "drawAsPaving-NOT-YET-IMPLEMENTED-in-ND" );
  
  if (TSpace::dimension == 2)
  {
    for (DGtal::int64_t x = NumberTraits<Integer>::castToInt64_t(h.myLowerBound[0]); 
   x <= NumberTraits<Integer>::castToInt64_t(h.myUpperBound[0]); x++)
      for (DGtal::int64_t y = NumberTraits<Integer>::castToInt64_t(h.myLowerBound[1]); 
     y <= NumberTraits<Integer>::castToInt64_t(h.myUpperBound[1]); y++)
        aboard.drawRectangle(x - 0.5, y + 0.5, 1, 1);
  }
}

template<typename TSpace>
inline
void draw( DGtal::Board2D & board, 
	   const DGtal::HyperRectDomain<TSpace> & h )
{
  std::string mode = board.getMode( h.styleName() );
  ASSERT((mode=="" || mode=="Grid" || mode=="Paving") ||
   ("draw( DGtal::Board2D & board, const DGtal::HyperRectDomain<TSpace> & h ): Unknown mode "+mode)=="");
  
  if ( ( mode == "" ) || ( mode == "Grid" ) )
    drawAsGrid( board, h );
  else if ( mode == "Paving" )
    drawAsPaving( board, h );
  // drawAsGrid( board, h );
}
// HyperRectDomain


// DigitalSetBySTLSet
template<typename Domain>
inline
void draw( DGtal::Board2D & board, 
	   const DGtal::DigitalSetBySTLSet<Domain> & s )
{
  typedef typename Domain::Point Point;
  typedef typename std::set<Point>::const_iterator ConstIterator;
    
  ASSERT(Domain::Space::dimension == 2);
  for(ConstIterator it =  s.begin(); it != s.end(); ++it)       
    board.drawRectangle( (*it)[0]-0.5,(*it)[1]+0.5,1,1);      
}
// DigitalSetBySTLSet


// DigitalSetBySTLVector
template<typename Domain>
inline
void draw( DGtal::Board2D & board, 
	   const DGtal::DigitalSetBySTLVector<Domain> & v )
{
  typedef typename Domain::Point Point;
  typedef typename std::vector<Point>::const_iterator ConstIterator;
    
  if (Domain::dimension == 2)
  {
    for(ConstIterator it =  v.begin(); it != v.end(); ++it)       
      board.drawRectangle( (*it)[0]-0.5,(*it)[1]+0.5,1,1);      
  }
  else
    ASSERT(false && ("draw-NOT-YET-IMPLEMENTED-in-ND"));
}
// DigitalSetBySTLVector


// Object
template <typename TDigitalTopology, typename TDigitalSet>
inline
void drawWithAdjacencies( DGtal::Board2D & aBoard, 
           const DGtal::Object<TDigitalTopology, TDigitalSet> & o )
{
  typedef TDigitalSet DigitalSet;
  typedef typename DigitalSet::Point Point;
  
  typedef TDigitalTopology DigitalTopology;
  typedef typename DigitalSet::Domain Domain;
  typedef
      typename DigitalSetSelector < Domain,
      SMALL_DS + HIGH_ITER_DS >::Type SmallSet;
  typedef Object<DigitalTopology, SmallSet> SmallObject;
  
  Point p;
  
  for (typename TDigitalSet::ConstIterator it = o.pointSet().begin();
      it != o.pointSet().end();
      ++it)
  {
    //Brute-force scan of the neighborhood.
    SmallObject neig = o.properNeighborhood(*it);
    for (typename SmallObject::DigitalSet::ConstIterator it2 = neig.pointSet().begin();
        it2 != neig.pointSet().end();
        ++it2)
    {
      p = (*it2) - (*it);
      draw(aBoard, (*it));
    }
  }
}

template <typename TDigitalTopology, typename TDigitalSet>
inline
void draw( DGtal::Board2D & board, 
	   const DGtal::Object<TDigitalTopology, TDigitalSet> & o )
{
  std::string mode = board.getMode( o.styleName() );
  if ( mode == "" )
    draw( board, o.pointSet() );
  else
    if ( mode == "DrawAdjacencies" )
    {
      draw( board, o.pointSet() );
      drawWithAdjacencies( board, o );
    }
    else
      ASSERT(false && (("draw( DGtal::Board2D & board, const DGtal::Object<TDigitalTopology, TDigitalSet> & o ): Unknown mode " + mode) == ""));
}
// Object


// KhalimskyCell
template < Dimension dim, typename TInteger >
inline
void draw( DGtal::Board2D & board,
	   const DGtal::KhalimskyCell<dim, TInteger> & k )
{
  ASSERT( dim == 2 );
  float x = (float) 
    ( NumberTraits<TInteger>::castToInt64_t( k.myCoordinates[0] ) >> 1 );
  float y = (float) 
    ( NumberTraits<TInteger>::castToInt64_t( k.myCoordinates[1] ) >> 1 );
  float retract = 0.05f;
  bool xodd = ( k.myCoordinates[ 0 ] & 1 );
  bool yodd = ( k.myCoordinates[ 1 ] & 1 );
  float dx = xodd ? 1.0f - 2.0f*retract : 2.0f*retract;
  float dy = yodd ? 1.0f - 2.0f*retract : 2.0f*retract;
  board.drawRectangle( !xodd ? x - retract - 0.5 : x + retract - 0.5,
           !yodd ? y + retract - 0.5 : y - retract + 0.5,
           dx, dy );
}
// KhalimskyCell

// SignedKhalimskyCell
template < Dimension dim, typename TInteger >
inline
void draw( DGtal::Board2D & board,
	   const DGtal::SignedKhalimskyCell<dim, TInteger> & sk )
{
  ASSERT( dim == 2 );
  float x = (float) 
    ( NumberTraits<TInteger>::castToInt64_t( sk.myCoordinates[0] ) >> 1 );
  float y = (float) 
    ( NumberTraits<TInteger>::castToInt64_t( sk.myCoordinates[1] ) >> 1 );
  float retract = 0.05f;
  bool xodd = ( sk.myCoordinates[ 0 ] & 1 );
  bool yodd = ( sk.myCoordinates[ 1 ] & 1 );
  float dx = xodd ? 1.0f - 2.0f*retract : 2.0f*retract;
  float dy = yodd ? 1.0f - 2.0f*retract : 2.0f*retract;
  board.drawRectangle( !xodd ? x - retract - 0.5 : x + retract - 0.5,
           !yodd ? y + retract - 0.5 : y - retract + 0.5,
           dx, dy );
}
// SignedKhalimskyCell


// AngleLinearMinimizer
inline
void draw( DGtal::Board2D & board,
	   const DGtal::AngleLinearMinimizer & a )
{
  double distance=5.0;
  board.setLineWidth(3.0);
  board.setPenColor(Color(20,20,200));
  for(int i=0; i< (int)a.mySize; i++){
    board.drawArc(0.0, 0.0, distance, a.myValues[i].min, a.myValues[i].max, false, 1);
    board.drawDot(cos(a.myValues[i].value)*distance, sin(a.myValues[i].value)*distance );
    distance+=a.myValues[i].distToNext;
  }
  distance=5.0;
  double distanceNext;
  for(int i=0; i< (int) (a.mySize-1); i++){
    distanceNext= distance+ a.myValues[i].distToNext;
    board.setPenColor(Color(200,20,20));
    board.drawLine(cos(a.myValues[i].value)*distance, sin(a.myValues[i].value)*distance, 
                   cos(a.myValues[i+1].value)*distanceNext, sin(a.myValues[i+1].value)*distanceNext);
    distance=distanceNext;
  } 
}
// AngleLinearMinimizer


// FP
template <typename TIterator, typename TInteger, int connectivity>
inline
void drawAsPolygon( DGtal::Board2D & aBoard, 
           const DGtal::FP<TIterator,TInteger,connectivity> & fp )
{
  typedef DGtal::PointVector<2,TInteger> Point;
  typedef std::list<Point> Polygon;
  
  typedef typename Polygon::const_iterator ConstIterator;
  
  //polyline to draw
  vector<LibBoard::Point> polyline;

  ConstIterator i = fp.myPolygon.begin();
  for ( ;i != fp.myPolygon.end();++i) {
      Point p = (*i);
      double xp = NumberTraits<TInteger>::castToInt64_t(p[0]);
      double yp = NumberTraits<TInteger>::castToInt64_t(p[1]);
      polyline.push_back(LibBoard::Point(xp,yp));
  }

  if (fp.myFlagIsClosed) {
      Point p = (*fp.myPolygon.begin());
      double xp = NumberTraits<TInteger>::castToInt64_t(p[0]);
      double yp = NumberTraits<TInteger>::castToInt64_t(p[1]);
      polyline.push_back(LibBoard::Point(xp,yp));
  }
  aBoard.drawPolyline(polyline);
}

template <typename TIterator, typename TInteger, int connectivity>
inline
void draw( DGtal::Board2D & board, 
	   const DGtal::FP<TIterator,TInteger,connectivity> & fp )
{
  std::string mode = board.getMode( fp.styleName() );
  if ( mode == "Polygon" )
    drawAsPolygon( board, fp );
  else if ( ( mode == "Both" ) || ( mode == "" ) )
    {
      drawAsPolygon( board, fp );
    }
  else
    {
      mode = "draw( DGtal::Board2D & board, const DGtal::FP<TIterator,TInteger,connectivity> & a ): Unknown mode "+mode;
      ASSERT2(false,  mode  );
    }
}
// FP

//

inline
void draw( DGtal::Board2D & board, 
	   const DGtal::SetMode & sm )
{
  board.myModes[ sm.myClassname ] = sm.myMode;
}

inline
void draw( DGtal::Board2D & board,
	   const DGtal::CustomStyle & cs )
{
  board.myStyles[ cs.myClassname ] = cs.myStyle;
}

/*inline
void draw( Display3D & display, const DGtal::CustomColors3D & cc3d )
{
  display.setFillColor(cc3d.myFillColor);
  display.setLineColor(cc3d.myPenColor);
}*/

//                                                                           //
///////////////////////////////////////////////////////////////////////////////


