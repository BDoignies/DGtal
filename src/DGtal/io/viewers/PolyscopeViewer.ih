/**
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 **/

/**
 * @file PolyscopeViewer.ih
 * @author Bastien Doignies <bastien.doignies@liris.cnrs.fr>
 *
 * @date 2025/05/11
 *
 * Implementation file for 3D Polyscope Viewer
 *
 * This file is part of the DGtal library.
 */

namespace DGtal {
  namespace drawutils {
    glm::vec3 toglm(const DGtal::Color& col) {
      return glm::vec3{col.r(), col.g(), col.b()};
    }
    std::vector<glm::vec3> toglm(const std::vector<DGtal::Color>& col) {
      std::vector<glm::vec3> colors(col.size());
      for (size_t i = 0; i < colors.size(); ++i) {
        colors[i] = toglm(col[i]);
      }
      return colors;
    }

    glm::mat4 toglm(const Eigen::Affine3d& transform) {
      glm::mat4 glmmat(1.f);
      Eigen::Matrix4d mat = transform.matrix();

      for (int i = 0; i < 4; ++i) 
        for (int j = 0; j < 4; ++j)
          glmmat[i][j] = static_cast<float>(mat(j, i));
      return glmmat;
    }
  }
  
  template <typename Space, typename KSpace>
  void PolyscopeViewer<Space, KSpace>::renderClippingPlanes() {
    using namespace drawutils;

    // Draw clipping planes
    for (const auto& plane : this->planes) {
      const glm::vec3 normal { plane.a, plane.b, plane.c }; 
      glm::vec3 pos {0, 0, 0};

      if (plane.a != 0) { pos.x = -plane.d / plane.a; }
      else if (plane.b != 0) { pos.y = -plane.d / plane.b; }
      else if (plane.c != 0) { pos.z = -plane.d / plane.c; }
      else continue;

      polyscope::SlicePlane* ps = polyscope::addSceneSlicePlane();
      if (!plane.style.useDefaultColors)
        ps->setColor(toglm(plane.style.color));

      //TODO: Keep this as default ?  
      ps->setDrawPlane(true);
      ps->setPose(pos, normal);
    }
  }

  template <typename Space, typename KSpace>
  void PolyscopeViewer<Space, KSpace>::renderNewData() {
    using namespace drawutils;

    const double BallToCubeRatio = 0.025;
    const double VectorScale = 1. / 30.;

    for (const std::string& name : this->toRender) {
      auto it = this->data.find(name);
      if (it == this->data.end()) continue;

      const auto& data = it->second;
      const auto& vertices = data.vertices;

      if (vertices.size() == 0) continue;

      switch(data.elementSize) {
        case 1: {
            auto* pCloud = polyscope::registerPointCloud(name, vertices);
    
            pCloud->setTransform(toglm(data.transform));
            if (!data.style.useDefaultColors) {
              pCloud->setPointColor(toglm(data.style.color));
              pCloud->setTransparency(data.style.color.a());
            }
    
            // Apply properties
            for (const auto& [name, vals] : data.scalarProperties) {
              pCloud->addScalarQuantity(name, vals)->setEnabled(true);
            }
            for (const auto& [name, vals] : data.vectorProperties) {
              auto* q = pCloud->addVectorQuantity(name, vals);
              q->setEnabled(true);
              q->setVectorLengthScale(VectorScale);
            }
  
            for (const auto& [name, vals] : data.colorProperties) {
              pCloud->addColorQuantity(name, toglm(vals))->setEnabled(true);
            }
            pCloud->setPointRadius(data.style.width * BallToCubeRatio);
          }
          break;
        case 2: {
            auto* cNetwork = polyscope::registerCurveNetwork(name, vertices, makeIndices<2>(vertices.size() / 2));
  
            cNetwork->setTransform(toglm(data.transform));
            if (!data.style.useDefaultColors) {
              cNetwork->setColor(toglm(data.style.color));
              cNetwork->setTransparency(data.style.color.a());
            }
  
            // Apply properties
            for (const auto& [name, vals] : data.scalarProperties) {
              cNetwork->addEdgeScalarQuantity(name, vals)->setEnabled(true);
            }
            for (const auto& [name, vals] : data.vectorProperties) {
              auto* q = cNetwork->addEdgeVectorQuantity(name, vals);
              q->setEnabled(true);
              q->setVectorLengthScale(VectorScale);
            }
            for (const auto& [name, vals] : data.colorProperties) {
              cNetwork->addEdgeColorQuantity(name, toglm(vals))->setEnabled(true);
            }
          }
          break;
        case 0: {
            auto* mesh = polyscope::registerSurfaceMesh(name, vertices, data.indices);
  
            mesh->setTransform(toglm(data.transform));
            if (!data.style.useDefaultColors) {
              mesh->setSurfaceColor(toglm(data.style.color));
              mesh->setTransparency(data.style.color.a());
            }
  
            // Apply properties
            for (const auto& [name, vals] : data.scalarProperties) {
              mesh->addFaceScalarQuantity(name, vals)->setEnabled(true);
            }
            for (const auto& [name, vals] : data.vectorProperties) {
              auto* q = mesh->addFaceVectorQuantity(name, vals);
              q->setEnabled(true);
              q->setVectorLengthScale(VectorScale);
            }
            for (const auto& [name, vals] : data.colorProperties) {
              mesh->addFaceColorQuantity(name, toglm(vals))->setEnabled(true);
            }
          }
          break;
        case 3: {
            auto* mesh = polyscope::registerSurfaceMesh(name, vertices, makeIndices<3>(vertices.size() / 3));
  
            mesh->setTransform(toglm(data.transform));
            if (!data.style.useDefaultColors) {
              mesh->setSurfaceColor(toglm(data.style.color));
              mesh->setTransparency(data.style.color.a());
            }
  
            // Apply properties
            for (const auto& [name, vals] : data.scalarProperties) {
              mesh->addFaceScalarQuantity(name, vals)->setEnabled(true);
            }
            for (const auto& [name, vals] : data.vectorProperties) {
              auto* q = mesh->addFaceVectorQuantity(name, vals);
              q->setEnabled(true);
              q->setVectorLengthScale(VectorScale);
            }
            for (const auto& [name, vals] : data.colorProperties) {
              mesh->addFaceColorQuantity(name, toglm(vals))->setEnabled(true);
            }
          }
          break;
        case 4: {
            auto* mesh = polyscope::registerSurfaceMesh(name, vertices, makeIndices<4>(vertices.size() / 4));
  
            mesh->setTransform(toglm(data.transform));
            if (!data.style.useDefaultColors) {
              mesh->setSurfaceColor(toglm(data.style.color));
              mesh->setTransparency(data.style.color.a());
            }
  
            // Apply properties
            for (const auto& [name, vals] : data.scalarProperties) {
              mesh->addFaceScalarQuantity(name, vals)->setEnabled(true);
            }
            for (const auto& [name, vals] : data.vectorProperties) {
              auto* q = mesh->addFaceVectorQuantity(name, vals);
              q->setEnabled(true);
              q->setVectorLengthScale(VectorScale);
            }
            for (const auto& [name, vals] : data.colorProperties) {
              mesh->addFaceColorQuantity(name, toglm(vals))->setEnabled(true);
            }
          }
          break;
        case 8: {
            auto* mesh = polyscope::registerVolumeMesh(name, vertices, makeIndices<8>(vertices.size() / 8));
  
            mesh->setTransform(toglm(data.transform));
            if (!data.style.useDefaultColors) {
              mesh->setColor(toglm(data.style.color));
              mesh->setTransparency(data.style.color.a());
            }
  
            // Apply properties
            for (const auto& [name, vals] : data.scalarProperties) {
              mesh->addCellScalarQuantity(name, vals)->setEnabled(true);
            }
            for (const auto& [name, vals] : data.vectorProperties) {
              auto* q = mesh->addCellVectorQuantity(name, vals);
              q->setEnabled(true);
              q->setVectorLengthScale(VectorScale);
            }
            for (const auto& [name, vals] : data.colorProperties) {
              mesh->addCellColorQuantity(name, toglm(vals))->setEnabled(true);
            }
          }
          break;
        default:
          break;
      };
    }
  }


  template <typename Space, typename KSpace>
  void PolyscopeViewer<Space, KSpace>::polyscopeCallback() {
    if (this->callback)
        this->callback->OnUI(nullptr);

    ImGuiIO& io = ImGui::GetIO();
    if (io.MouseClicked[0])
    {
        glm::vec2 screenCoords{io.MousePos.x, io.MousePos.y};
        glm::vec3 worldRay = polyscope::view::screenCoordsToWorldRay(screenCoords);
        glm::vec3 worldPos = polyscope::view::screenCoordsToWorldPosition(screenCoords);
        auto [structure, index] = 
            polyscope::pick::pickAtScreenCoords(screenCoords);

        if (structure != nullptr) {
          void* viewerData = structure;
          std::string name = structure->getName();

          if (this->callback) {
            auto& data = this->data[name];
            this->callback->OnClick(name, index, data, viewerData);
          }
        }
    }
  }
}
