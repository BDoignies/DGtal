namespace DGtal
{
    template <typename TSpace, typename TKSpace>
    PolyscopeViewer3D<TSpace, TKSpace>::PolyscopeViewer3D()
    {
        polyscope::init();  
        polyscope::state::userCallback = [this](){ this->poyscopeCallback(); };
    }

    template <typename TSpace, typename TKSpace>
    void PolyscopeViewer3D<TSpace, TKSpace>::show() const
    {
        polyscope::show();
    }

    template <typename TSpace, typename TKSpace>
    void PolyscopeViewer3D<TSpace, TKSpace>::displayMessage(const std::string& text)
    {
        messageQueue.push_back(text);
    }

    template <typename TSpace, typename TKSpace>
    void PolyscopeViewer3D<TSpace, TKSpace>::poyscopeCallback()
    {
        ImGuiTreeNodeFlags flag = ImGuiTreeNodeFlags_DefaultOpen;
        if (ImGui::TreeNodeEx("Messages", flag))
        {
            for (unsigned int i = 0; i < messageQueue.size(); i++)
                ImGui::Text("[%d]: %s", i + 1, messageQueue[i].c_str());
            ImGui::TreePop();
        }

        // Handles selections
        ImGuiIO& io = ImGui::GetIO();
        if (io.MouseClicked[0])
        {
            glm::vec2 screenCoords{io.MousePos.x, io.MousePos.y};
            glm::vec3 worldRay = polyscope::view::screenCoordsToWorldRay(screenCoords);
            glm::vec3 worldPos = polyscope::view::screenCoordsToWorldPosition(screenCoords);
            std::pair<polyscope::Structure*, size_t> pickPair = 
                polyscope::pick::pickAtScreenCoords(screenCoords);

            // Selection
            if (pickPair.first != nullptr)
            {
                const std::string name = pickPair.first->getName();
                auto it = namesMap.find(name);
                if (it != namesMap.end())
                {
                    for (auto& callback : this->mySelectCallBackFcts)
                    {
                        DGtal::int32_t idx = -1;
                        
                        // Index of a subelement
                        auto itIdx1 = it->second.indexMap.find(pickPair.second);
                        if (itIdx1 == it->second.indexMap.end())
                        {
                            // Index of the global structure
                            auto itIdx2 = it->second.indexMap.find(-1);
                            if (itIdx2 != it->second.indexMap.end())
                            {
                                idx = itIdx2->second;
                            }
                        }
                        else
                        {
                            idx = itIdx1->second;
                        }

                        if (callback.fct && callback.isSelected(idx))
                        {
                            callback.fct(this, idx, callback.data);
                        }
                    }
                }
            }
        }
    }
    
    template <typename TSpace, typename TKSpace>
    PolyscopeViewer3D<TSpace, TKSpace>& 
    PolyscopeViewer3D<TSpace, TKSpace>::operator<<(
        const typename PolyscopeViewer3D<TSpace, TKSpace>::StreamKey & key
    )
    {
        switch (key)
        {
        case PolyscopeViewer3D<TSpace, TKSpace>::updateDisplay:
            clearAll();
            createPolyscopeObjects();
            break;
        case PolyscopeViewer3D<TSpace, TKSpace>::addNewList:
            break;    
        case PolyscopeViewer3D<TSpace, TKSpace>::shiftSurfelVisu:
            break;
        default:
            break;
        };
        return *this;
    }

    template <typename TSpace, typename TKSpace>
    template <typename TDrawableWithViewer3D>
    PolyscopeViewer3D<TSpace, TKSpace>& 
    PolyscopeViewer3D<TSpace, TKSpace>::operator<<(const TDrawableWithViewer3D & object)
    {
        Display3DFactory<TSpace, TKSpace>::draw(*this, object);
        return *this;
    }

    template <typename TSpace, typename TKSpace>
    PolyscopeViewer3D<TSpace, TKSpace>& 
    PolyscopeViewer3D<TSpace, TKSpace>::operator<<(const SetName3D& name)
    {
        IndexMapper mapper = { true, { {-1, name.name } }};
        namesMap[name.strName] = mapper;
        Display3DFactory<TSpace, TKSpace>::draw(*this, name);
        return *this;
    }
    
    template <typename TSpace, typename TKSpace>
    void PolyscopeViewer3D<TSpace, TKSpace>::clearAll()
    {
        polyscope::removeAllStructures();

        // First filter all values that were not specified by the user
        std::erase_if(namesMap, 
            [](const auto& pair) { return !pair.second.userSpecified; }
        );

        // For the one remaining, remove all content except the one 
        // that was specified
        for (auto it = namesMap.begin(); it != namesMap.end(); ++it)
        {
            std::erase_if(it->second.indexMap, 
                [](const auto& pair) { return pair.first != -1; }
            );
        }
    }


    template <typename TSpace, typename TKSpace>
    void PolyscopeViewer3D<TSpace, TKSpace>::createPolyscopeObjects() const
    {
        // This is debug for now, to be removed !
        std::cout << "[Creating polyscope objects]" << std::endl;
        std::cout << "Lines: "     << this->myLineSetList.size() << std::endl;
        std::cout << "Balls: "     << this->myBallSetList.size() << std::endl;
        std::cout << "Planes: "    << this->myClippingPlaneList.size() << std::endl;
        std::cout << "Prism: "     << this->myPrismList.size() << std::endl;
        std::cout << "QuadsMap: "  << this->myQuadsMap.size() << std::endl;
        std::cout << "Triangles: " << this->myTriangleSetList.size() << std::endl;
        std::cout << "Polygones: " << this->myPolygonSetList.size() << std::endl;
        std::cout << "CubesMap: "  << this->myCubesMap.size() << std::endl;

        registerLines();
        registerBalls();
        registerQuads();
        registerCubeMaps();
        registerClippingPlanes();
    }

    template <typename TSpace, typename TKSpace>
    void PolyscopeViewer3D<TSpace, TKSpace>::addClippingPlane(double a, double b, double c, double d, bool drawPlane)
    {
        typename Display3D<TSpace, TKSpace>::ClippingPlaneD3D cp;
        cp.a = a; cp.b = b; cp.c = c; cp.d = d;
        cp.color = DGtal::Color(0, 0, 0, 128);

        this->myClippingPlaneList.push_back(cp);
    }
    

    template <typename TSpace, typename TKSpace>
    void PolyscopeViewer3D<TSpace, TKSpace>::registerCubeMaps() const
    {
        static constexpr int cubePositions[8][3] = {
            {-1, -1, -1}, 
            { 1, -1, -1},
            { 1,  1, -1},
            {-1,  1, -1},
            {-1, -1,  1}, 
            { 1, -1,  1},
            { 1,  1,  1},
            {-1,  1,  1}
        };

        unsigned int count = 0;
        for (const auto& [id, cubes] : this->myCubesMap)
        {
            if (cubes.size() == 0) continue;

            const std::string& default_name = "cubes_" + std::to_string(count++);

            std::vector<std::array<double     , 3>> vertices(cubes.size() * 8);
            std::vector<std::array<double     , 3>> colors  (cubes.size());
            std::vector<std::array<std::size_t, 8>> indices (cubes.size());
            std::map<DGtal::int32_t, DGtal::int32_t> indexToName;

            for (unsigned int i = 0; i < cubes.size(); i++)
            {
                for (unsigned int v = 0; v < 8; v++)
                {
                    indices[i][v] = i * 8 + v;
                    for (unsigned int k = 0; k < 3; k++)
                    {
                        vertices[i * 8 + v][k] = 
                            cubes[i].center[k] + cubePositions[v][k] * cubes[i].width;
                    }

                    if (cubes[i].name != -1)
                        indexToName[i] = cubes[i].name;
                }

                colors[i][0] = cubes[i].color.r();
                colors[i][1] = cubes[i].color.g();
                colors[i][2] = cubes[i].color.b();
            }

            std::string name;
            auto it = std::find_if(namesMap.begin(), namesMap.end(), 
                [&](const auto& pair) 
                { 
                    auto it = pair.second.indexMap.find(-1);
                    if (it == pair.second.indexMap.end()) return false;
                    return it->second == id; 
                });
            if (it == namesMap.end() || it->first.empty())
            {
                indexToName[-1] = id;
                namesMap[default_name] = { false, indexToName};
                name = default_name;
            }
            else
            {
                name = it->first;
                it->second.indexMap.insert(indexToName.begin(), indexToName.end());
            }

            auto volume = polyscope::registerVolumeMesh(name, vertices, indices);
            volume->setColor({ 1, 1, 1 }); // White color so that no color is missinterpreted
            volume->setTransparency(cubes[0].color.a());
            volume->addCellColorQuantity("Colors", colors)->setEnabled(true);
        }
    }
    
    template <typename TSpace, typename TKSpace>
    void PolyscopeViewer3D<TSpace, TKSpace>::registerLines() const
    {
        unsigned int count = 0;
        for (const auto& lines : this->myLineSetList)
        {
            if (lines.size() == 0) continue;

            const std::string& default_name = "lines_" + std::to_string(count++);
            std::vector<std::array<double     , 3>> vertices(lines.size() * 2);
            std::vector<std::array<double     , 3>> colors  (lines.size());
            std::vector<std::array<std::size_t, 2>> indices (lines.size());
            std::map<DGtal::int32_t, DGtal::int32_t> indexToName;

            for (unsigned int i = 0; i < lines.size(); i++)
            {
                indices[i][0] = i * 2 + 0;
                indices[i][1] = i * 2 + 1;
                for (unsigned int k = 0; k < 3; k++)
                {
                    vertices[i * 2 + 0][k] = lines[i].point1[k]; 
                    vertices[i * 2 + 1][k] = lines[i].point2[k]; 
                }

                colors[i][0] = lines[i].color.r();
                colors[i][1] = lines[i].color.g();
                colors[i][2] = lines[i].color.b();

                if (lines[i].name != -1)
                    indexToName[i] = lines[i].name;
            }

            indexToName[-1] = -1;
            namesMap[default_name] = { false, indexToName};

            auto plines = polyscope::registerCurveNetwork(default_name, vertices, indices);
            plines->setColor({ 1, 1, 1 }); // White color so that no color is missinterpreted
            plines->setTransparency(lines[0].color.a());
            plines->addEdgeColorQuantity("Colors", colors)->setEnabled(true);
        }
    }

    template <typename TSpace, typename TKSpace>
    void PolyscopeViewer3D<TSpace, TKSpace>::registerBalls() const
    {
        static constexpr double DEFAULT_RADIUS_TO_POLYSCOPE_RATIO = 0.1;

        unsigned int count = 0;
        for (const auto& balls : this->myBallSetList)
        {
            if (balls.size() == 0) continue;

            const std::string& default_name = "balls_" + std::to_string(count++);
            std::vector<std::array<double, 3>> points(balls.size());
            std::vector<std::array<double, 3>> colors(balls.size());
            std::map<DGtal::int32_t, DGtal::int32_t> indexToName;

            for (unsigned int i = 0; i < balls.size(); i++)
            {
                points[i][0] = balls[i].center[0];
                points[i][1] = balls[i].center[1];
                points[i][2] = balls[i].center[2];

                colors[i][0] = balls[i].color.r();
                colors[i][1] = balls[i].color.g();
                colors[i][2] = balls[i].color.b();

                if (balls[i].name != -1)
                    indexToName[i] = balls[i].name;
            }

            indexToName[-1] = -1;
            namesMap[default_name] = { false, indexToName};

            auto cloud = polyscope::registerPointCloud(default_name, points);
            cloud->setPointColor({ 1, 1, 1 }); // White color so that no color is missinterpreted
            cloud->setPointRadius(balls[0].radius * DEFAULT_RADIUS_TO_POLYSCOPE_RATIO);
            cloud->setTransparency(balls[0].color.a());
            cloud->addColorQuantity("Colors", colors)->setEnabled(true);
        }
    }

    template <typename TSpace, typename TKSpace>
    void PolyscopeViewer3D<TSpace, TKSpace>::registerQuads() const
    {
        unsigned int count = 0;
        for (const auto& [id, quads] : this->myQuadsMap)
        {
            if (quads.size() == 0) continue;

            const std::string& default_name = "quads_" + std::to_string(count++);
            std::vector<std::array<double,      3>> points (quads.size() * 4);
            std::vector<std::array<std::size_t, 3>> indices(quads.size() * 2);
            std::vector<std::array<double,      3>> colors (quads.size() * 2);
            std::map<DGtal::int32_t, DGtal::int32_t> indexToName;

            for (unsigned int i = 0; i < quads.size(); i++)
            {
                for (unsigned int k = 0; k < 3; k++)
                {
                    points[i * 4 + 0][k] = quads[i].point1[k];
                    points[i * 4 + 1][k] = quads[i].point2[k];
                    points[i * 4 + 2][k] = quads[i].point3[k];
                    points[i * 4 + 3][k] = quads[i].point4[k];
                }

                indices[i * 2 + 0] = {i * 4 + 0, i * 4 + 1, i * 4 + 3};
                indices[i * 2 + 1] = {i * 4 + 3, i * 4 + 1, i * 4 + 2};

                colors[i * 2 + 0][0] = colors[i * 2 + 1][0] = quads[i].color.r();
                colors[i * 2 + 0][1] = colors[i * 2 + 1][1] = quads[i].color.g();
                colors[i * 2 + 0][2] = colors[i * 2 + 1][2] = quads[i].color.b();

                if (quads[i].name != -1)
                    indexToName[i] = quads[i].name;
            }

            std::string name;
            auto it = std::find_if(namesMap.begin(), namesMap.end(), 
                [&](const auto& pair) 
                { 
                    auto it = pair.second.indexMap.find(-1);
                    if (it == pair.second.indexMap.end()) return false;
                    return it->second == id; 
                });
            if (it == namesMap.end() || it->first.empty())
            {
                indexToName[-1] = id;
                namesMap[default_name] = { false, indexToName};
                name = default_name;
            }
            else
            {
                name = it->first;
                it->second.indexMap.insert(indexToName.begin(), indexToName.end());
            }

            auto mesh = polyscope::registerSurfaceMesh(name, points, indices);
            mesh->setTransparency(quads[0].color.a());
            mesh->addFaceColorQuantity("Colors", colors)->setEnabled(true);
            // Draw triangle in both directions to avoid computing the proper 
            // order from the normal
            mesh->setBackFacePolicy(polyscope::BackFacePolicy::Identical);
        }
    }


    template <typename TSpace, typename TKSpace>
    void PolyscopeViewer3D<TSpace, TKSpace>::registerClippingPlanes() const
    {
        unsigned int count = 0;
        for (const auto& cplane : this->myClippingPlaneList)
        {
            glm::vec3 normal{cplane.a, cplane.b, cplane.c};
            glm::vec3 point {0, 0, 0};

            if      (cplane.a != 0) point.x = -cplane.d / cplane.a;
            else if (cplane.b != 0) point.y = -cplane.d / cplane.b;
            else if (cplane.c != 0) point.z = -cplane.d / cplane.c;

            auto plane = polyscope::addSceneSlicePlane();
            plane->setDrawPlane(true);
            plane->setDrawWidget(false);

            plane->setPose(point, normal);
            plane->setColor({ cplane.color.r(), cplane.color.g(), cplane.color.b() });
            plane->setTransparency(cplane.color.a());
        }
    }

    template <typename TSpace, typename TKSpace>
    void PolyscopeViewer3D<TSpace, TKSpace>::selfDisplay(std::ostream & out) const
    {
        out << "[PolyscopeViewer3D]";       
    }

    template <typename TSpace, typename TKSpace>
    std::ostream & operator<<(std::ostream & out, const PolyscopeViewer3D<TSpace, TKSpace> & object)
    {
        object.selfDisplay(out);
        return out;
    }
}
