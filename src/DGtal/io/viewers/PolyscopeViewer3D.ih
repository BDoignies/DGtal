/**
 * @file PolyscopeViewer3D.ih
 * @author Bastien Doignies
 *
 * @date 2025/03/20
 *
 * This file is part of the DGtal library.
 */
#define DEFAULT_SINGLE_STRUCTURE

namespace DGtal
{   
    // Wether elements in default group are rendered as 
    // separate elements or batched together
    inline constexpr static bool SEPARATE_DEFAULT_GROUP = true;
    // For performances issues, force group the singletons
    inline constexpr static size_t SINGLETONS_THRESHOLD = 128;

    template <typename TSpace, typename TKSpace>
    PolyscopeViewer3D<TSpace, TKSpace>::PolyscopeViewer3D()
    {
        polyscope::init();  
        polyscope::state::userCallback = [this](){ this->poyscopeCallback(); };
    }
    
    template <typename TSpace, typename TKSpace>
    PolyscopeViewer3D<TSpace, TKSpace>::PolyscopeViewer3D(const TKSpace& embd) : Display3D<TSpace, TKSpace>(embd)
    {
        polyscope::init();  
        polyscope::state::userCallback = [this](){ this->poyscopeCallback(); };
    }

    template <typename TSpace, typename TKSpace>
    void PolyscopeViewer3D<TSpace, TKSpace>::show() const
    {
        polyscope::show();
    }

    template <typename TSpace, typename TKSpace>
    void PolyscopeViewer3D<TSpace, TKSpace>::displayMessage(const std::string& text)
    {
        messageQueue.push_back(text);
    }

    template <typename TSpace, typename TKSpace>
    void PolyscopeViewer3D<TSpace, TKSpace>::setExtension(Extension* ext)
    {
        setExtension(CountedPtr<Extension>(ext));
    }

    template <typename TSpace, typename TKSpace>
    void PolyscopeViewer3D<TSpace, TKSpace>::setExtension(CountedPtr<Extension> ext)
    {
        extension = ext;
    }

    template <typename TSpace, typename TKSpace>
    void PolyscopeViewer3D<TSpace, TKSpace>::poyscopeCallback()
    {
        ImGuiTreeNodeFlags flag = ImGuiTreeNodeFlags_DefaultOpen;
        if (ImGui::TreeNodeEx("Messages", flag))
        {
            for (unsigned int i = 0; i < messageQueue.size(); i++)
                ImGui::Text("[%d]: %s", i + 1, messageQueue[i].c_str());
            ImGui::TreePop();
        }

        if (extension.get())
            extension->UICallback();

        // Handles selections
        ImGuiIO& io = ImGui::GetIO();
        if (io.MouseClicked[0])
        {
            glm::vec2 screenCoords{io.MousePos.x, io.MousePos.y};
            glm::vec3 worldRay = polyscope::view::screenCoordsToWorldRay(screenCoords);
            glm::vec3 worldPos = polyscope::view::screenCoordsToWorldPosition(screenCoords);
            std::pair<polyscope::Structure*, size_t> pickPair = 
                polyscope::pick::pickAtScreenCoords(screenCoords);

            // Selection
            std::string name = "";
            if (pickPair.first != nullptr)
            {
                name = pickPair.first->getName();
                for (auto& callback : this->mySelectCallBackFcts)
                {                        
                    if (callback.fct && callback.isSelected(0))
                    {
                        callback.fct(this, 0, callback.data);
                    }
                }
            }

            if (extension.get())
                extension->OnSelect(this, pickPair.first, pickPair.second, 0);
        }
    }
    
    template <typename TSpace, typename TKSpace>
    PolyscopeViewer3D<TSpace, TKSpace>& 
    PolyscopeViewer3D<TSpace, TKSpace>::operator<<(
        const typename PolyscopeViewer3D<TSpace, TKSpace>::StreamKey & key
    )
    {
        switch (key)
        {
        case PolyscopeViewer3D<TSpace, TKSpace>::updateDisplay:
            clearAll();
            createPolyscopeObjects();
            break;
        case PolyscopeViewer3D<TSpace, TKSpace>::addNewList:
             PolyscopeViewer3D<TSpace, TKSpace>::createNewCubeList();
             break;    
        case PolyscopeViewer3D<TSpace, TKSpace>::shiftSurfelVisu:
             PolyscopeViewer3D<TSpace, TKSpace>::myCurrentfShiftVisuPrisms += 0.3;
             break;
        default:
            break;
        };
        return *this;
    }

    template <typename TSpace, typename TKSpace>
    template <typename TDrawableWithViewer3D>
    PolyscopeViewer3D<TSpace, TKSpace>& 
    PolyscopeViewer3D<TSpace, TKSpace>::operator<<(const TDrawableWithViewer3D & object)
    {
        Display3DFactory<TSpace, TKSpace>::draw(*this, object);
        return *this;
    }

    template <typename TSpace, typename TKSpace>
    PolyscopeViewer3D<TSpace, TKSpace>& 
    PolyscopeViewer3D<TSpace, TKSpace>::operator<<(const SetName3D& name)
    {
        Display3DFactory<TSpace, TKSpace>::draw(*this, name);
        return *this;
    }
    
    template <typename TSpace, typename TKSpace>
    void PolyscopeViewer3D<TSpace, TKSpace>::clearAll()
    {
        polyscope::removeAllStructures();
    }


    template <typename TSpace, typename TKSpace>
    void PolyscopeViewer3D<TSpace, TKSpace>::createPolyscopeObjects() const
    {
        // This is debug for now, to be removed !
        std::cout << "[Creating polyscope objects]" << std::endl;
        std::cout << "Lines: "     << this->myLineSetList.size() << std::endl;       // Ok
        std::cout << "Balls: "     << this->myBallSetList.size() << std::endl;       // Ok
        std::cout << "Planes: "    << this->myClippingPlaneList.size() << std::endl; // Ok
        std::cout << "Prism: "     << this->myPrismList.size() << std::endl;         // TODO
        std::cout << "QuadsMap: "  << this->myQuadsMap.size() << std::endl;          // Ok
        std::cout << "Triangles: " << this->myTriangleSetList.size() << std::endl;   // Ok
        std::cout << "Polygones: " << this->myPolygonSetList.size() << std::endl;    // Ok
        std::cout << "CubesMap: "  << this->myCubesMap.size() << std::endl;          // Ok
        std::cout << "Images: " << this->myImageSetList.size() << std::endl;
        
        registerLines();
        registerBalls();
        registerQuads();
        registerPrisms();
        registerCubeMaps();
        registerPolygons();
        registerTriangles();
        registerClippingPlanes();

        registerImages();
    }

    template <typename TSpace, typename TKSpace>
    void PolyscopeViewer3D<TSpace, TKSpace>::addClippingPlane(double a, double b, double c, double d, bool drawPlane)
    {
        ClippingPlaneD3D cp;
        cp.a = a; cp.b = b; cp.c = c; cp.d = d;
        cp.style = this->myCurrentStyle;
        cp.style.color = DGtal::Color(0, 0, 0, 128);

        this->myClippingPlaneList.push_back(cp);
    }
    
    template<typename Group, typename Register, typename ApplyStyle>
    inline void registerGroup(
        const Group& g, 
        Register registerGeometry, 
        ApplyStyle applyStyle
    ) { 
        for (const auto& [name, data] : g.groups) {
            const bool split_group = 
                (name == g.defaultGroupName) 
                && SINGLETONS_THRESHOLD < data.elementIndices.size()
                && SEPARATE_DEFAULT_GROUP;

            if (split_group) {
                // Default group, separate them into individual elements
                for (size_t i = 0; i < data.elementIndices.size(); ++i) {
                    std::cout << i << std::endl;
                    // Assume they are contiguous
                    std::span<const typename decltype(data)::Point> vertices {
                        data.vertices.begin() + data.elementIndices[i][0], 
                        data.elementIndices[i].size()
                    };
                    std::array<typename decltype(data)::Indices, 1> indices = {
                        data.elementIndices[i]
                    };
                    for (size_t j = 0; j < indices[0].size(); j++) indices[0][j] = j;
                    
                    auto* surface = registerGeometry(name + "_" + std::to_string(i), vertices, indices);
                    applyStyle(surface, data, i, 1);
                }
            } else {
                auto* surface = registerGeometry(name, data.vertices, data.elementIndices);
                applyStyle(surface, data, 0, data.elementIndices.size());
            }
        }
    }

    inline glm::vec3 glmColor(const DGtal::Color& col) {
        return { col.r(), col.g(), col.b() };
    }

    template <typename TSpace, typename TKSpace>
    void PolyscopeViewer3D<TSpace, TKSpace>::registerCubeMaps() const
    {
        registerGroup(
            this->myCubesMap, 
            // Register function
            [](const std::string& name, const auto& vertices, const auto& indices) { 
                return polyscope::registerHexMesh(name, vertices, indices); 
            }, 
            // Applies the style
            [](polyscope::VolumeMesh* mesh, const auto& data, size_t i, size_t c) { 
                if (data.style.color.has_value()) {
                    mesh->setColor(glmColor(*data.style.color));
                    mesh->setTransparency(data.style.color->a());
                } 

                for (const auto& [name, vals] : data.scalarQuantities) {
                    std::span<const double> values { vals.data() + i, c };
                    mesh->addCellScalarQuantity(name, values);
                }
                for (const auto& [name, vals] : data.vectorQuantities) {
                    // vals = const std::vector<Vector>&
                    // 
                    std::span<const typename std::remove_cvref_t<decltype(data)>::Vector> values { vals.data() + i, c };
                    mesh->addCellVectorQuantity(name, values);
                }
                for (const auto& [name, vals] : data.colorQuantities) {
                    std::vector<glm::vec3> colors(c);
                    for (size_t j = 0; j < c; ++j) {
                        colors[j] = glmColor(vals[i + j]);
                    }
                    mesh->addCellColorQuantity(name, colors);
                }
            }
        );
    }
    
    template <typename TSpace, typename TKSpace>
    void PolyscopeViewer3D<TSpace, TKSpace>::registerTriangles() const
    {
        registerGroup(
            this->myTriangleSetList, 
            [](const std::string& name, const auto& vertices, const auto& indices) { 
                return polyscope::registerSurfaceMesh(name, vertices, indices); 
            }, 
            // Applies the style
            [](polyscope::SurfaceMesh* surf, const auto& data, size_t i, size_t c) { 
                if (data.style.color.has_value()) {
                    surf->setSurfaceColor(glmColor(*data.style.color));
                    surf->setTransparency(data.style.color->a());
                } 
                if (data.style.drawBackFace) {
                    surf->setBackFacePolicy(polyscope::BackFacePolicy::Identical);
                }

                for (const auto& [name, vals] : data.scalarQuantities) {
                    std::span<const double> values { vals.data() + i, c };
                    surf->addFaceScalarQuantity(name, values);
                }
                for (const auto& [name, vals] : data.vectorQuantities) {
                    std::span<const typename std::remove_cvref_t<decltype(data)>::Vector> values { vals.data() + i, c };
                    surf->addFaceVectorQuantity(name, values);
                }
                for (const auto& [name, vals] : data.colorQuantities) {
                    std::vector<glm::vec3> colors(c);
                    for (size_t j = 0; j < c; ++j) {
                        colors[j] = glmColor(vals[i + j]);
                    }
                    surf->addFaceColorQuantity(name, colors);
                }
            }
        ); 
    }

    template <typename TSpace, typename TKSpace>
    void PolyscopeViewer3D<TSpace, TKSpace>::registerPolygons() const
    {
        registerGroup( 
            this->myPolygonSetList, 
            [](const std::string& name, const auto& vertices, const auto& indices) { 
                return polyscope::registerSurfaceMesh(name, vertices, indices); 
            }, 
            // Applies the style
            [](polyscope::SurfaceMesh* surf, const auto& data, size_t i, size_t c) { 
                if (data.style.color.has_value()) {
                    surf->setSurfaceColor(glmColor(*data.style.color));
                    surf->setTransparency(data.style.color->a());
                }  
                if (data.style.drawBackFace) {
                    surf->setBackFacePolicy(polyscope::BackFacePolicy::Identical);
                }

                for (const auto& [name, vals] : data.scalarQuantities) {
                    std::span<const double> values { vals.data() + i, c };
                    surf->addFaceScalarQuantity(name, values);
                }
                for (const auto& [name, vals] : data.vectorQuantities) {
                    std::span<const typename std::remove_cvref_t<decltype(data)>::Vector> values { vals.data() + i, c };
                    surf->addFaceVectorQuantity(name, values);
                }
                for (const auto& [name, vals] : data.colorQuantities) {
                    std::vector<glm::vec3> colors(c);
                    for (size_t j = 0; j < c; ++j) {
                        colors[j] = glmColor(vals[i + j]);
                    }
                    surf->addFaceColorQuantity(name, colors);
                }
            }
        ); 
    }

    template <typename TSpace, typename TKSpace>
    void PolyscopeViewer3D<TSpace, TKSpace>::registerLines() const
    {
        registerGroup( 
            this->myLineSetList, 
            [](const std::string& name, const auto& vertices, const auto& indices) { 
                return polyscope::registerCurveNetwork(name, vertices, indices); 
            }, 
            // Applies the style
            [](polyscope::CurveNetwork* lines, const auto& data, size_t i, size_t c) { 
                if (data.style.color.has_value()) {
                    lines->setColor(glmColor(*data.style.color));
                    lines->setTransparency(data.style.color->a());
                } 

                for (const auto& [name, vals] : data.scalarQuantities) {
                    std::span<const double> values { vals.data() + i, c };
                    lines->addEdgeScalarQuantity(name, values);
                }
                for (const auto& [name, vals] : data.vectorQuantities) {
                    std::span<const typename std::remove_cvref_t<decltype(data)>::Vector> values { vals.data() + i, c };
                    lines->addEdgeVectorQuantity(name, values);
                }
                for (const auto& [name, vals] : data.colorQuantities) {
                    std::vector<glm::vec3> colors(c);
                    for (size_t j = 0; j < c; ++j) {
                        colors[j] = glmColor(vals[i + j]);
                    }
                    lines->addEdgeColorQuantity(name, colors);
                }
            }
        ); 
    }

    template <typename TSpace, typename TKSpace>
    void PolyscopeViewer3D<TSpace, TKSpace>::registerBalls() const
    {
        registerGroup( 
            this->myBallSetList, 
            [](const std::string& name, const auto& vertices, const auto& indices) { 
                return polyscope::registerPointCloud(name, vertices); 
            }, 
            // Applies the style
            [](polyscope::PointCloud* points, const auto& data, size_t i, size_t c) { 
                if (data.style.color.has_value()) {
                    points->setPointColor(glmColor(*data.style.color));
                    points->setTransparency(data.style.color->a());
                } 

                if (c > data.style.ballToQuadThreshold) {
                    points->setPointRenderMode(polyscope::PointRenderMode::Quad);
                }

                for (const auto& [name, vals] : data.scalarQuantities) {
                    std::span<const double> values { vals.data() + i, c };
                    points->addScalarQuantity(name, values);
                }
                for (const auto& [name, vals] : data.vectorQuantities) {
                    std::span<const typename std::remove_cvref_t<decltype(data)>::Vector> values { vals.data() + i, c };
                    points->addVectorQuantity(name, values);
                }
                for (const auto& [name, vals] : data.colorQuantities) {
                    std::vector<glm::vec3> colors(c);
                    for (size_t j = 0; j < c; ++j) {
                        colors[j] = glmColor(vals[i + j]);
                    }
                    points->addColorQuantity(name, colors);
                }
            }
        ); 
    }

    template <typename TSpace, typename TKSpace>
    void PolyscopeViewer3D<TSpace, TKSpace>::registerQuads() const
    {
        registerGroup(
            this->myQuadsMap, 
            [](const std::string& name, const auto& vertices, const auto& indices) { 
                return polyscope::registerSurfaceMesh(name, vertices, indices); 
            }, 
            // Applies the style
            [](polyscope::SurfaceMesh* surf, const auto& data, size_t i, size_t c) { 
                if (data.style.color.has_value()) {
                    surf->setSurfaceColor(glmColor(*data.style.color));
                    surf->setTransparency(data.style.color->a());
                }
                if (data.style.drawBackFace) {
                    surf->setBackFacePolicy(polyscope::BackFacePolicy::Identical);
                }

                for (const auto& [name, vals] : data.scalarQuantities) {
                    std::span<const double> values { vals.data() + i, c };
                    surf->addFaceScalarQuantity(name, values);
                }
                for (const auto& [name, vals] : data.vectorQuantities) {
                    std::span<const typename std::remove_cvref_t<decltype(data)>::Vector> values { vals.data() + i, c };
                    surf->addFaceVectorQuantity(name, values);
                }
                for (const auto& [name, vals] : data.colorQuantities) {
                    std::vector<glm::vec3> colors(c);
                    for (size_t j = 0; j < c; ++j) {
                        colors[j] = glmColor(vals[i + j]);
                    }
                    surf->addFaceColorQuantity(name, colors);
                }
            }
        ); 
    }
    
    template <typename TSpace, typename TKSpace>
    void PolyscopeViewer3D<TSpace, TKSpace>::registerPrisms() const
    {
        registerGroup(
            this->myPrismList, 
            [](const std::string& name, const auto& vertices, const auto& indices) { 
                return polyscope::registerSurfaceMesh(name, vertices, indices); 
            }, 
            // Applies the style
            [](polyscope::SurfaceMesh* surf, const auto& data, size_t i, size_t c) { 
                if (data.style.color.has_value()) {
                    surf->setSurfaceColor(glmColor(*data.style.color));
                    surf->setTransparency(data.style.color->a());
                } 
                if (data.style.drawBackFace) {
                    surf->setBackFacePolicy(polyscope::BackFacePolicy::Identical);
                }

                for (const auto& [name, vals] : data.scalarQuantities) {
                    std::span<const double> values { vals.data() + i, c };
                    surf->addFaceScalarQuantity(name, values);
                }
                for (const auto& [name, vals] : data.vectorQuantities) {
                    std::span<const typename std::remove_cvref_t<decltype(data)>::Vector> values { vals.data() + i, c };
                    surf->addFaceVectorQuantity(name, values);
                }
                for (const auto& [name, vals] : data.colorQuantities) {
                    std::vector<glm::vec3> colors(c);
                    for (size_t j = 0; j < c; ++j) {
                        colors[j] = glmColor(vals[i + j]);
                    }
                    surf->addFaceColorQuantity(name, colors);
                }
            }
        ); 
   }

    template <typename TSpace, typename TKSpace>
    void PolyscopeViewer3D<TSpace, TKSpace>::registerClippingPlanes() const
    {
        unsigned int count = 0;
        for (const auto& cplane : this->myClippingPlaneList)
        {
            glm::vec3 normal{cplane.a, cplane.b, cplane.c};
            glm::vec3 point {0, 0, 0};

            if      (cplane.a != 0) point.x = -cplane.d / cplane.a;
            else if (cplane.b != 0) point.y = -cplane.d / cplane.b;
            else if (cplane.c != 0) point.z = -cplane.d / cplane.c;

            auto plane = polyscope::addSceneSlicePlane();
            plane->setDrawPlane(true);
            plane->setDrawWidget(false);

            plane->setPose(point, normal);

            const auto color = cplane.style.color;
            if (color.has_value()) {
                plane->setColor({ color->r(), color->g(), color->b() });
                plane->setTransparency(color->a());
            }
        }
    }

    template<typename TSpace, typename TKSpace>
    void PolyscopeViewer3D<TSpace, TKSpace>::registerImages() const
    {
        unsigned int count = 0;
        for (unsigned int id = 0; id < this->myImageSetList.size(); id++)
        {
            const auto& image = this->myImageSetList[id];

            std::string default_name = "Image_" + std::to_string(count++);
            
            glm::uvec3 dims = {image.dims[0], image.dims[1], image.dims[2]};
            glm::vec3 bound_low  = { 0, 0, 0};
            glm::vec3 bound_high = { image.dims[0] * image.voxelWidth, 
                                     image.dims[1] * image.voxelWidth, 
                                     image.dims[2] * image.voxelWidth };
            
            glm::mat4 gTransform;
            for (unsigned int i = 0; i < 16; i++)
                gTransform[i / 4][i % 4] = (float)image.transform.data()[i];
    
            auto grid = polyscope::registerVolumeGrid(default_name, dims, bound_low, bound_high);
            grid->setTransform(gTransform);
            auto scalar = grid->addNodeScalarQuantity("value", image.data);
            scalar->setEnabled(true);
        }  
    }

    template <typename TSpace, typename TKSpace>
    void PolyscopeViewer3D<TSpace, TKSpace>::selfDisplay(std::ostream & out) const
    {
        out << "[PolyscopeViewer3D]";       
    }

    template <typename TSpace, typename TKSpace>
    std::ostream & operator<<(std::ostream & out, const PolyscopeViewer3D<TSpace, TKSpace> & object)
    {
        object.selfDisplay(out);
        return out;
    }
}
